/**
 * @tanstack/react-router/src/index.tsx
 *
 * Copyright (c) TanStack
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react')) :
  typeof define === 'function' && define.amd ? define(['exports', 'react'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.ReactRouter = {}, global.React));
})(this, (function (exports, React) { 'use strict';

  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
      Object.keys(e).forEach(function (k) {
        if (k !== 'default') {
          var d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: true,
            get: function () { return e[k]; }
          });
        }
      });
    }
    n["default"] = e;
    return Object.freeze(n);
  }

  var React__namespace = /*#__PURE__*/_interopNamespace(React);

  /**
   * @tanstack/history/src/index.ts
   *
   * Copyright (c) TanStack
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   */
  // While the public API was clearly inspired by the "history" npm package,
  // This implementation attempts to be more lightweight by
  // making assumptions about the way TanStack Router works

  const pushStateEvent = 'pushstate';
  const popStateEvent = 'popstate';
  const beforeUnloadEvent = 'beforeunload';
  const beforeUnloadListener = event => {
    event.preventDefault();
    // @ts-ignore
    return event.returnValue = '';
  };
  const stopBlocking = () => {
    removeEventListener(beforeUnloadEvent, beforeUnloadListener, {
      capture: true
    });
  };
  function createHistory(opts) {
    let location = opts.getLocation();
    let subscribers = new Set();
    let blockers = [];
    let queue = [];
    const onUpdate = () => {
      location = opts.getLocation();
      subscribers.forEach(subscriber => subscriber());
    };
    const tryUnblock = () => {
      if (blockers.length) {
        blockers[0]?.(tryUnblock, () => {
          blockers = [];
          stopBlocking();
        });
        return;
      }
      while (queue.length) {
        queue.shift()?.();
      }
    };
    const queueTask = task => {
      queue.push(task);
      tryUnblock();
    };
    return {
      get location() {
        return location;
      },
      subscribe: cb => {
        subscribers.add(cb);
        return () => {
          subscribers.delete(cb);
        };
      },
      push: (path, state) => {
        state = assignKey(state);
        queueTask(() => {
          opts.pushState(path, state, onUpdate);
        });
      },
      replace: (path, state) => {
        state = assignKey(state);
        queueTask(() => {
          opts.replaceState(path, state, onUpdate);
        });
      },
      go: index => {
        queueTask(() => {
          opts.go(index);
        });
      },
      back: () => {
        queueTask(() => {
          opts.back();
        });
      },
      forward: () => {
        queueTask(() => {
          opts.forward();
        });
      },
      createHref: str => opts.createHref(str),
      block: cb => {
        blockers.push(cb);
        if (blockers.length === 1) {
          addEventListener(beforeUnloadEvent, beforeUnloadListener, {
            capture: true
          });
        }
        return () => {
          blockers = blockers.filter(b => b !== cb);
          if (!blockers.length) {
            stopBlocking();
          }
        };
      },
      flush: () => opts.flush?.(),
      destroy: () => opts.destroy?.(),
      notify: onUpdate
    };
  }
  function assignKey(state) {
    if (!state) {
      state = {};
    }
    return {
      ...state,
      key: createRandomKey()
    };
  }

  /**
   * Creates a history object that can be used to interact with the browser's
   * navigation. This is a lightweight API wrapping the browser's native methods.
   * It is designed to work with TanStack Router, but could be used as a standalone API as well.
   * IMPORTANT: This API implements history throttling via a microtask to prevent
   * excessive calls to the history API. In some browsers, calling history.pushState or
   * history.replaceState in quick succession can cause the browser to ignore subsequent
   * calls. This API smooths out those differences and ensures that your application
   * state will *eventually* match the browser state. In most cases, this is not a problem,
   * but if you need to ensure that the browser state is up to date, you can use the
   * `history.flush` method to immediately flush all pending state changes to the browser URL.
   * @param opts
   * @param opts.getHref A function that returns the current href (path + search + hash)
   * @param opts.createHref A function that takes a path and returns a href (path + search + hash)
   * @returns A history instance
   */
  function createBrowserHistory(opts) {
    const getHref = opts?.getHref ?? (() => `${window.location.pathname}${window.location.search}${window.location.hash}`);
    const createHref = opts?.createHref ?? (path => path);
    let currentLocation = parseLocation(getHref(), window.history.state);
    const getLocation = () => currentLocation;
    let next;

    // Because we are proactively updating the location
    // in memory before actually updating the browser history,
    // we need to track when we are doing this so we don't
    // notify subscribers twice on the last update.
    let tracking = true;

    // We need to track the current scheduled update to prevent
    // multiple updates from being scheduled at the same time.
    let scheduled;

    // This function is a wrapper to prevent any of the callback's
    // side effects from causing a subscriber notification
    const untrack = fn => {
      tracking = false;
      fn();
      tracking = true;
    };

    // This function flushes the next update to the browser history
    const flush = () => {
      // Do not notify subscribers about this push/replace call
      untrack(() => {
        if (!next) return;
        window.history[next.isPush ? 'pushState' : 'replaceState'](next.state, '', next.href);
        // Reset the nextIsPush flag and clear the scheduled update
        next = undefined;
        scheduled = undefined;
      });
    };

    // This function queues up a call to update the browser history
    const queueHistoryAction = (type, path, state, onUpdate) => {
      const href = createHref(path);

      // Update the location in memory
      currentLocation = parseLocation(href, state);

      // Keep track of the next location we need to flush to the URL
      next = {
        href,
        state,
        isPush: next?.isPush || type === 'push'
      };
      // Notify subscribers
      onUpdate();
      if (!scheduled) {
        // Schedule an update to the browser history
        scheduled = Promise.resolve().then(() => flush());
      }
    };
    const onPushPop = () => {
      currentLocation = parseLocation(getHref(), window.history.state);
      history.notify();
    };
    var originalPushState = window.history.pushState;
    var originalReplaceState = window.history.replaceState;
    const history = createHistory({
      getLocation,
      pushState: (path, state, onUpdate) => queueHistoryAction('push', path, state, onUpdate),
      replaceState: (path, state, onUpdate) => queueHistoryAction('replace', path, state, onUpdate),
      back: () => window.history.back(),
      forward: () => window.history.forward(),
      go: n => window.history.go(n),
      createHref: path => createHref(path),
      flush,
      destroy: () => {
        window.history.pushState = originalPushState;
        window.history.replaceState = originalReplaceState;
        window.removeEventListener(pushStateEvent, onPushPop);
        window.removeEventListener(popStateEvent, onPushPop);
      }
    });
    window.addEventListener(pushStateEvent, onPushPop);
    window.addEventListener(popStateEvent, onPushPop);
    window.history.pushState = function () {
      let res = originalPushState.apply(window.history, arguments);
      if (tracking) history.notify();
      return res;
    };
    window.history.replaceState = function () {
      let res = originalReplaceState.apply(window.history, arguments);
      if (tracking) history.notify();
      return res;
    };
    return history;
  }
  function createHashHistory() {
    return createBrowserHistory({
      getHref: () => window.location.hash.substring(1),
      createHref: path => `#${path}`
    });
  }
  function createMemoryHistory(opts = {
    initialEntries: ['/']
  }) {
    const entries = opts.initialEntries;
    let index = opts.initialIndex ?? entries.length - 1;
    let currentState = {
      key: createRandomKey()
    };
    const getLocation = () => parseLocation(entries[index], currentState);
    return createHistory({
      getLocation,
      pushState: (path, state) => {
        currentState = state;
        entries.push(path);
        index++;
      },
      replaceState: (path, state) => {
        currentState = state;
        entries[index] = path;
      },
      back: () => {
        index--;
      },
      forward: () => {
        index = Math.min(index + 1, entries.length - 1);
      },
      go: n => window.history.go(n),
      createHref: path => path
    });
  }
  function parseLocation(href, state) {
    let hashIndex = href.indexOf('#');
    let searchIndex = href.indexOf('?');
    return {
      href,
      pathname: href.substring(0, hashIndex > 0 ? searchIndex > 0 ? Math.min(hashIndex, searchIndex) : hashIndex : searchIndex > 0 ? searchIndex : href.length),
      hash: hashIndex > -1 ? href.substring(hashIndex) : '',
      search: searchIndex > -1 ? href.slice(searchIndex, hashIndex === -1 ? undefined : hashIndex) : '',
      state: state || {}
    };
  }

  // Thanks co-pilot!
  function createRandomKey() {
    return (Math.random() + 1).toString(36).substring(7);
  }

  var prefix = 'Invariant failed';
  function invariant(condition, message) {
      if (condition) {
          return;
      }
      var provided = typeof message === 'function' ? message() : message;
      var value = provided ? "".concat(prefix, ": ").concat(provided) : prefix;
      throw new Error(value);
  }

  function warning(condition, message) {
    {
      if (condition) {
        return;
      }

      var text = "Warning: " + message;

      if (typeof console !== 'undefined') {
        console.warn(text);
      }

      try {
        throw Error(text);
      } catch (x) {}
    }
  }

  function CatchBoundary(props) {
    const errorComponent = props.errorComponent ?? ErrorComponent;
    return /*#__PURE__*/React__namespace.createElement(CatchBoundaryImpl, {
      resetKey: props.resetKey,
      onCatch: props.onCatch,
      children: ({
        error
      }) => {
        if (error) {
          return /*#__PURE__*/React__namespace.createElement(errorComponent, {
            error
          });
        }
        return props.children;
      }
    });
  }
  class CatchBoundaryImpl extends React__namespace.Component {
    state = {
      error: null
    };
    static getDerivedStateFromError(error) {
      return {
        error
      };
    }
    componentDidUpdate(prevProps, prevState) {
      if (prevState.error && prevProps.resetKey !== this.props.resetKey) {
        this.setState({
          error: null
        });
      }
    }
    componentDidCatch(error) {
      console.error(error);
      this.props.onCatch?.(error);
    }
    render() {
      return this.props.children(this.state);
    }
  }
  function ErrorComponent({
    error
  }) {
    const [show, setShow] = React__namespace.useState("development" !== 'production');
    return /*#__PURE__*/React__namespace.createElement("div", {
      style: {
        padding: '.5rem',
        maxWidth: '100%'
      }
    }, /*#__PURE__*/React__namespace.createElement("div", {
      style: {
        display: 'flex',
        alignItems: 'center',
        gap: '.5rem'
      }
    }, /*#__PURE__*/React__namespace.createElement("strong", {
      style: {
        fontSize: '1rem'
      }
    }, "Something went wrong!"), /*#__PURE__*/React__namespace.createElement("button", {
      style: {
        appearance: 'none',
        fontSize: '.6em',
        border: '1px solid currentColor',
        padding: '.1rem .2rem',
        fontWeight: 'bold',
        borderRadius: '.25rem'
      },
      onClick: () => setShow(d => !d)
    }, show ? 'Hide Error' : 'Show Error')), /*#__PURE__*/React__namespace.createElement("div", {
      style: {
        height: '.25rem'
      }
    }), show ? /*#__PURE__*/React__namespace.createElement("div", null, /*#__PURE__*/React__namespace.createElement("pre", {
      style: {
        fontSize: '.7em',
        border: '1px solid red',
        borderRadius: '.25rem',
        padding: '.3rem',
        color: 'red',
        overflow: 'auto'
      }
    }, error.message ? /*#__PURE__*/React__namespace.createElement("code", null, error.message) : null)) : null);
  }

  // export type Expand<T> = T

  // type Compute<T> = { [K in keyof T]: T[K] } | never

  // type AllKeys<T> = T extends any ? keyof T : never

  // export type MergeUnion<T, Keys extends keyof T = keyof T> = Compute<
  //   {
  //     [K in Keys]: T[Keys]
  //   } & {
  //     [K in AllKeys<T>]?: T extends any
  //       ? K extends keyof T
  //         ? T[K]
  //         : never
  //       : never
  //   }
  // >
  // // Sample types to merge
  // type TypeA = {
  //   shared: string
  //   onlyInA: string
  //   nested: {
  //     shared: string
  //     aProp: string
  //   }
  //   array: string[]
  // }
  // type TypeB = {
  //   shared: number
  //   onlyInB: number
  //   nested: {
  //     shared: number
  //     bProp: number
  //   }
  //   array: number[]
  // }
  // type TypeC = {
  //   shared: boolean
  //   onlyInC: boolean
  //   nested: {
  //     shared: boolean
  //     cProp: boolean
  //   }
  //   array: boolean[]
  // }
  // type Test = Expand<Assign<TypeA, TypeB>>
  // // Using DeepMerge to merge TypeA and TypeB
  // type MergedType = Expand<AssignAll<[TypeA, TypeB, TypeC]>>
  //

  const isServer = typeof document === 'undefined';
  function last(arr) {
    return arr[arr.length - 1];
  }
  function isFunction(d) {
    return typeof d === 'function';
  }
  function functionalUpdate(updater, previous) {
    if (isFunction(updater)) {
      return updater(previous);
    }
    return updater;
  }
  function pick(parent, keys) {
    return keys.reduce((obj, key) => {
      obj[key] = parent[key];
      return obj;
    }, {});
  }

  /**
   * This function returns `a` if `b` is deeply equal.
   * If not, it will replace any deeply equal children of `b` with those of `a`.
   * This can be used for structural sharing between immutable JSON values for example.
   * Do not use this with signals
   */
  function replaceEqualDeep(prev, _next) {
    if (prev === _next) {
      return prev;
    }
    const next = _next;
    const array = Array.isArray(prev) && Array.isArray(next);
    if (array || isPlainObject(prev) && isPlainObject(next)) {
      const prevSize = array ? prev.length : Object.keys(prev).length;
      const nextItems = array ? next : Object.keys(next);
      const nextSize = nextItems.length;
      const copy = array ? [] : {};
      let equalItems = 0;
      for (let i = 0; i < nextSize; i++) {
        const key = array ? i : nextItems[i];
        copy[key] = replaceEqualDeep(prev[key], next[key]);
        if (copy[key] === prev[key]) {
          equalItems++;
        }
      }
      return prevSize === nextSize && equalItems === prevSize ? prev : copy;
    }
    return next;
  }

  // Copied from: https://github.com/jonschlinkert/is-plain-object
  function isPlainObject(o) {
    if (!hasObjectPrototype(o)) {
      return false;
    }

    // If has modified constructor
    const ctor = o.constructor;
    if (typeof ctor === 'undefined') {
      return true;
    }

    // If has modified prototype
    const prot = ctor.prototype;
    if (!hasObjectPrototype(prot)) {
      return false;
    }

    // If constructor does not have an Object-specific method
    if (!prot.hasOwnProperty('isPrototypeOf')) {
      return false;
    }

    // Most likely a plain Object
    return true;
  }
  function hasObjectPrototype(o) {
    return Object.prototype.toString.call(o) === '[object Object]';
  }
  function partialDeepEqual(a, b) {
    if (a === b) {
      return true;
    }
    if (typeof a !== typeof b) {
      return false;
    }
    if (isPlainObject(a) && isPlainObject(b)) {
      return !Object.keys(b).some(key => !partialDeepEqual(a[key], b[key]));
    }
    if (Array.isArray(a) && Array.isArray(b)) {
      return !(a.length !== b.length || a.some((item, index) => !partialDeepEqual(item, b[index])));
    }
    return false;
  }
  function useStableCallback(fn) {
    const fnRef = React__namespace.useRef(fn);
    fnRef.current = fn;
    const ref = React__namespace.useRef((...args) => fnRef.current(...args));
    return ref.current;
  }
  function shallow(objA, objB) {
    if (Object.is(objA, objB)) {
      return true;
    }
    if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
      return false;
    }
    const keysA = Object.keys(objA);
    if (keysA.length !== Object.keys(objB).length) {
      return false;
    }
    for (let i = 0; i < keysA.length; i++) {
      if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !Object.is(objA[keysA[i]], objB[keysA[i]])) {
        return false;
      }
    }
    return true;
  }
  function useRouteContext(opts) {
    return useMatch({
      ...opts,
      select: match => opts?.select ? opts.select(match.context) : match.context
    });
  }
  const useLayoutEffect$1 = typeof window !== 'undefined' ? React__namespace.useLayoutEffect : React__namespace.useEffect;

  function joinPaths(paths) {
    return cleanPath(paths.filter(Boolean).join('/'));
  }
  function cleanPath(path) {
    // remove double slashes
    return path.replace(/\/{2,}/g, '/');
  }
  function trimPathLeft(path) {
    return path === '/' ? path : path.replace(/^\/{1,}/, '');
  }
  function trimPathRight(path) {
    return path === '/' ? path : path.replace(/\/{1,}$/, '');
  }
  function trimPath(path) {
    return trimPathRight(trimPathLeft(path));
  }
  function resolvePath(basepath, base, to) {
    base = base.replace(new RegExp(`^${basepath}`), '/');
    to = to.replace(new RegExp(`^${basepath}`), '/');
    let baseSegments = parsePathname(base);
    const toSegments = parsePathname(to);
    toSegments.forEach((toSegment, index) => {
      if (toSegment.value === '/') {
        if (!index) {
          // Leading slash
          baseSegments = [toSegment];
        } else if (index === toSegments.length - 1) {
          // Trailing Slash
          baseSegments.push(toSegment);
        } else ;
      } else if (toSegment.value === '..') {
        // Extra trailing slash? pop it off
        if (baseSegments.length > 1 && last(baseSegments)?.value === '/') {
          baseSegments.pop();
        }
        baseSegments.pop();
      } else if (toSegment.value === '.') {
        return;
      } else {
        baseSegments.push(toSegment);
      }
    });
    const joined = joinPaths([basepath, ...baseSegments.map(d => d.value)]);
    return cleanPath(joined);
  }
  function parsePathname(pathname) {
    if (!pathname) {
      return [];
    }
    pathname = cleanPath(pathname);
    const segments = [];
    if (pathname.slice(0, 1) === '/') {
      pathname = pathname.substring(1);
      segments.push({
        type: 'pathname',
        value: '/'
      });
    }
    if (!pathname) {
      return segments;
    }

    // Remove empty segments and '.' segments
    const split = pathname.split('/').filter(Boolean);
    segments.push(...split.map(part => {
      if (part === '$' || part === '*') {
        return {
          type: 'wildcard',
          value: part
        };
      }
      if (part.charAt(0) === '$') {
        return {
          type: 'param',
          value: part
        };
      }
      return {
        type: 'pathname',
        value: part
      };
    }));
    if (pathname.slice(-1) === '/') {
      pathname = pathname.substring(1);
      segments.push({
        type: 'pathname',
        value: '/'
      });
    }
    return segments;
  }
  function interpolatePath(path, params, leaveWildcards = false) {
    const interpolatedPathSegments = parsePathname(path);
    return joinPaths(interpolatedPathSegments.map(segment => {
      if (segment.type === 'wildcard') {
        const value = params[segment.value];
        if (leaveWildcards) return `${segment.value}${value ?? ''}`;
        return value;
      }
      if (segment.type === 'param') {
        return params[segment.value.substring(1)] ?? '';
      }
      return segment.value;
    }));
  }
  function matchPathname(basepath, currentPathname, matchLocation) {
    const pathParams = matchByPath(basepath, currentPathname, matchLocation);
    // const searchMatched = matchBySearch(location.search, matchLocation)

    if (matchLocation.to && !pathParams) {
      return;
    }
    return pathParams ?? {};
  }
  function matchByPath(basepath, from, matchLocation) {
    // Remove the base path from the pathname
    from = basepath != '/' ? from.substring(basepath.length) : from;
    // Default to to $ (wildcard)
    const to = `${matchLocation.to ?? '$'}`;
    // Parse the from and to
    const baseSegments = parsePathname(from);
    const routeSegments = parsePathname(to);
    if (!from.startsWith('/')) {
      baseSegments.unshift({
        type: 'pathname',
        value: '/'
      });
    }
    if (!to.startsWith('/')) {
      routeSegments.unshift({
        type: 'pathname',
        value: '/'
      });
    }
    const params = {};
    let isMatch = (() => {
      for (let i = 0; i < Math.max(baseSegments.length, routeSegments.length); i++) {
        const baseSegment = baseSegments[i];
        const routeSegment = routeSegments[i];
        const isLastBaseSegment = i >= baseSegments.length - 1;
        const isLastRouteSegment = i >= routeSegments.length - 1;
        if (routeSegment) {
          if (routeSegment.type === 'wildcard') {
            if (baseSegment?.value) {
              params['*'] = joinPaths(baseSegments.slice(i).map(d => d.value));
              return true;
            }
            return false;
          }
          if (routeSegment.type === 'pathname') {
            if (routeSegment.value === '/' && !baseSegment?.value) {
              return true;
            }
            if (baseSegment) {
              if (matchLocation.caseSensitive) {
                if (routeSegment.value !== baseSegment.value) {
                  return false;
                }
              } else if (routeSegment.value.toLowerCase() !== baseSegment.value.toLowerCase()) {
                return false;
              }
            }
          }
          if (!baseSegment) {
            return false;
          }
          if (routeSegment.type === 'param') {
            if (baseSegment?.value === '/') {
              return false;
            }
            if (baseSegment.value.charAt(0) !== '$') {
              params[routeSegment.value.substring(1)] = baseSegment.value;
            }
          }
        }
        if (!isLastBaseSegment && isLastRouteSegment) {
          return !!matchLocation.fuzzy;
        }
      }
      return true;
    })();
    return isMatch ? params : undefined;
  }

  // Detect if we're in the DOM

  function redirect(opts) {
    opts.isRedirect = true;
    return opts;
  }
  function isRedirect(obj) {
    return !!obj?.isRedirect;
  }

  // @ts-nocheck

  // qss has been slightly modified and inlined here for our use cases (and compression's sake). We've included it as a hard dependency for MIT license attribution.

  function encode(obj, pfx) {
    var k,
      i,
      tmp,
      str = '';
    for (k in obj) {
      if ((tmp = obj[k]) !== void 0) {
        if (Array.isArray(tmp)) {
          for (i = 0; i < tmp.length; i++) {
            str && (str += '&');
            str += encodeURIComponent(k) + '=' + encodeURIComponent(tmp[i]);
          }
        } else {
          str && (str += '&');
          str += encodeURIComponent(k) + '=' + encodeURIComponent(tmp);
        }
      }
    }
    return (pfx || '') + str;
  }
  function toValue(mix) {
    if (!mix) return '';
    var str = decodeURIComponent(mix);
    if (str === 'false') return false;
    if (str === 'true') return true;
    return +str * 0 === 0 && +str + '' === str ? +str : str;
  }
  function decode(str) {
    var tmp,
      k,
      out = {},
      arr = str.split('&');
    while (tmp = arr.shift()) {
      tmp = tmp.split('=');
      k = tmp.shift();
      if (out[k] !== void 0) {
        out[k] = [].concat(out[k], toValue(tmp.shift()));
      } else {
        out[k] = toValue(tmp.shift());
      }
    }
    return out;
  }

  const defaultParseSearch = parseSearchWith(JSON.parse);
  const defaultStringifySearch = stringifySearchWith(JSON.stringify, JSON.parse);
  function parseSearchWith(parser) {
    return searchStr => {
      if (searchStr.substring(0, 1) === '?') {
        searchStr = searchStr.substring(1);
      }
      let query = decode(searchStr);

      // Try to parse any query params that might be json
      for (let key in query) {
        const value = query[key];
        if (typeof value === 'string') {
          try {
            query[key] = parser(value);
          } catch (err) {
            //
          }
        }
      }
      return query;
    };
  }
  function stringifySearchWith(stringify, parser) {
    function stringifyValue(val) {
      if (typeof val === 'object' && val !== null) {
        try {
          return stringify(val);
        } catch (err) {
          // silent
        }
      } else if (typeof val === 'string' && typeof parser === 'function') {
        try {
          // Check if it's a valid parseable string.
          // If it is, then stringify it again.
          parser(val);
          return stringify(val);
        } catch (err) {
          // silent
        }
      }
      return val;
    }
    return search => {
      search = {
        ...search
      };
      if (search) {
        Object.keys(search).forEach(key => {
          const val = search[key];
          if (typeof val === 'undefined' || val === undefined) {
            delete search[key];
          } else {
            search[key] = stringifyValue(val);
          }
        });
      }
      const searchStr = encode(search).toString();
      return searchStr ? `?${searchStr}` : '';
    };
  }

  //

  //

  const componentTypes = ['component', 'errorComponent', 'pendingComponent'];
  class Router {
    // dehydratedData?: TDehydrated
    // resetNextScroll = false
    // tempLocationKey = `${Math.round(Math.random() * 10000000)}`
    constructor(options) {
      this.options = {
        defaultPreloadDelay: 50,
        context: undefined,
        ...options,
        stringifySearch: options?.stringifySearch ?? defaultStringifySearch,
        parseSearch: options?.parseSearch ?? defaultParseSearch
      };
      this.routeTree = this.options.routeTree;
    }
    subscribers = new Set();
    subscribe = (eventType, fn) => {
      const listener = {
        eventType,
        fn
      };
      this.subscribers.add(listener);
      return () => {
        this.subscribers.delete(listener);
      };
    };
    emit = routerEvent => {
      this.subscribers.forEach(listener => {
        if (listener.eventType === routerEvent.type) {
          listener.fn(routerEvent);
        }
      });
    };

    // dehydrate = (): DehydratedRouter => {
    //   return {
    //     state: {
    //       dehydratedMatches: state.matches.map((d) =>
    //         pick(d, ['fetchedAt', 'invalid', 'id', 'status', 'updatedAt']),
    //       ),
    //     },
    //   }
    // }

    // hydrate = async (__do_not_use_server_ctx?: HydrationCtx) => {
    //   let _ctx = __do_not_use_server_ctx
    //   // Client hydrates from window
    //   if (typeof document !== 'undefined') {
    //     _ctx = window.__TSR_DEHYDRATED__
    //   }

    //   invariant(
    //     _ctx,
    //     'Expected to find a __TSR_DEHYDRATED__ property on window... but we did not. Did you forget to render <DehydrateRouter /> in your app?',
    //   )

    //   const ctx = _ctx
    //   this.dehydratedData = ctx.payload as any
    //   this.options.hydrate?.(ctx.payload as any)
    //   const dehydratedState = ctx.router.state

    //   let matches = this.matchRoutes(
    //     state.location.pathname,
    //     state.location.search,
    //   ).map((match) => {
    //     const dehydratedMatch = dehydratedState.dehydratedMatches.find(
    //       (d) => d.id === match.id,
    //     )

    //     invariant(
    //       dehydratedMatch,
    //       `Could not find a client-side match for dehydrated match with id: ${match.id}!`,
    //     )

    //     if (dehydratedMatch) {
    //       return {
    //         ...match,
    //         ...dehydratedMatch,
    //       }
    //     }
    //     return match
    //   })

    //   this.setState((s) => {
    //     return {
    //       ...s,
    //       matches: dehydratedState.dehydratedMatches as any,
    //     }
    //   })
    // }

    // TODO:
    // injectedHtml: (string | (() => Promise<string> | string))[] = []

    // TODO:
    // injectHtml = async (html: string | (() => Promise<string> | string)) => {
    //   this.injectedHtml.push(html)
    // }

    // TODO:
    // dehydrateData = <T>(key: any, getData: T | (() => Promise<T> | T)) => {
    //   if (typeof document === 'undefined') {
    //     const strKey = typeof key === 'string' ? key : JSON.stringify(key)

    //     this.injectHtml(async () => {
    //       const id = `__TSR_DEHYDRATED__${strKey}`
    //       const data =
    //         typeof getData === 'function' ? await (getData as any)() : getData
    //       return `<script id='${id}' suppressHydrationWarning>window["__TSR_DEHYDRATED__${escapeJSON(
    //         strKey,
    //       )}"] = ${JSON.stringify(data)}
    //       ;(() => {
    //         var el = document.getElementById('${id}')
    //         el.parentElement.removeChild(el)
    //       })()
    //       </script>`
    //     })

    //     return () => this.hydrateData<T>(key)
    //   }

    //   return () => undefined
    // }

    // hydrateData = <T = unknown>(key: any) => {
    //   if (typeof document !== 'undefined') {
    //     const strKey = typeof key === 'string' ? key : JSON.stringify(key)

    //     return window[`__TSR_DEHYDRATED__${strKey}` as any] as T
    //   }

    //   return undefined
    // }

    // resolveMatchPromise = (matchId: string, key: string, value: any) => {
    //   state.matches
    //     .find((d) => d.id === matchId)
    //     ?.__promisesByKey[key]?.resolve(value)
    // }

    // setRouteMatch = (
    //   id: string,
    //   pending: boolean,
    //   updater: NonNullableUpdater<RouteMatch<TRouteTree>>,
    // ) => {
    //   const key = pending ? 'pendingMatches' : 'matches'

    //   this.setState((prev) => {
    //     return {
    //       ...prev,
    //       [key]: prev[key].map((d) => {
    //         if (d.id === id) {
    //           return functionalUpdate(updater, d)
    //         }

    //         return d
    //       }),
    //     }
    //   })
    // }

    // setPendingRouteMatch = (
    //   id: string,
    //   updater: NonNullableUpdater<RouteMatch<TRouteTree>>,
    // ) => {
    //   this.setRouteMatch(id, true, updater)
    // }
  }

  // A function that takes an import() argument which is a function and returns a new function that will
  // proxy arguments from the caller to the imported function, retaining all type
  // information along the way
  function lazyFn(fn, key) {
    return async (...args) => {
      const imported = await fn();
      return imported[key || 'default'](...args);
    };
  }

  const routerContext = /*#__PURE__*/React__namespace.createContext(null);
  if (typeof document !== 'undefined') {
    window.__TSR_ROUTER_CONTEXT__ = routerContext;
  }
  const preloadWarning = 'Error preloading route! ☝️';
  function isCtrlEvent(e) {
    return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);
  }
  class SearchParamError extends Error {}
  class PathParamError extends Error {}
  function getInitialRouterState(location) {
    return {
      status: 'idle',
      resolvedLocation: location,
      location,
      matches: [],
      pendingMatches: [],
      lastUpdated: Date.now()
    };
  }
  function RouterProvider({
    router,
    ...rest
  }) {
    const options = {
      ...router.options,
      ...rest,
      context: {
        ...router.options.context,
        ...rest?.context
      }
    };
    const history = React__namespace.useState(() => options.history ?? createBrowserHistory())[0];
    const tempLocationKeyRef = React__namespace.useRef(`${Math.round(Math.random() * 10000000)}`);
    const resetNextScrollRef = React__namespace.useRef(true);
    const navigateTimeoutRef = React__namespace.useRef(null);
    const latestLoadPromiseRef = React__namespace.useRef(Promise.resolve());
    const checkLatest = promise => {
      return latestLoadPromiseRef.current !== promise ? latestLoadPromiseRef.current : undefined;
    };
    const parseLocation = useStableCallback(previousLocation => {
      const parse = ({
        pathname,
        search,
        hash,
        state
      }) => {
        const parsedSearch = options.parseSearch(search);
        return {
          pathname: pathname,
          searchStr: search,
          search: replaceEqualDeep(previousLocation?.search, parsedSearch),
          hash: hash.split('#').reverse()[0] ?? '',
          href: `${pathname}${search}${hash}`,
          state: replaceEqualDeep(previousLocation?.state, state)
        };
      };
      const location = parse(history.location);
      let {
        __tempLocation,
        __tempKey
      } = location.state;
      if (__tempLocation && (!__tempKey || __tempKey === tempLocationKeyRef.current)) {
        // Sync up the location keys
        const parsedTempLocation = parse(__tempLocation);
        parsedTempLocation.state.key = location.state.key;
        delete parsedTempLocation.state.__tempLocation;
        return {
          ...parsedTempLocation,
          maskedLocation: location
        };
      }
      return location;
    });
    const latestLocationRef = React__namespace.useRef(parseLocation());
    const [preState, setState] = React__namespace.useState(() => getInitialRouterState(latestLocationRef.current));
    const [isTransitioning, startReactTransition] = React__namespace.useTransition();
    const state = React__namespace.useMemo(() => ({
      ...preState,
      status: isTransitioning ? 'pending' : 'idle',
      location: isTransitioning ? latestLocationRef.current : preState.location
    }), [preState, isTransitioning]);
    React__namespace.useLayoutEffect(() => {
      if (!isTransitioning && state.resolvedLocation !== state.location) {
        router.emit({
          type: 'onResolved',
          fromLocation: state.resolvedLocation,
          toLocation: state.location,
          pathChanged: state.location.href !== state.resolvedLocation?.href
        });
        setState(s => ({
          ...s,
          resolvedLocation: s.location
        }));
      }
    });
    const basepath = `/${trimPath(options.basepath ?? '') ?? ''}`;
    const resolvePathWithBase = useStableCallback((from, path) => {
      return resolvePath(basepath, from, cleanPath(path));
    });
    const [routesById, routesByPath] = React__namespace.useMemo(() => {
      const routesById = {};
      const routesByPath = {};
      const recurseRoutes = routes => {
        routes.forEach((route, i) => {
          route.init({
            originalIndex: i
          });
          const existingRoute = routesById[route.id];
          invariant(!existingRoute, `Duplicate routes found with id: ${String(route.id)}`);
          routesById[route.id] = route;
          if (!route.isRoot && route.path) {
            const trimmedFullPath = trimPathRight(route.fullPath);
            if (!routesByPath[trimmedFullPath] || route.fullPath.endsWith('/')) {
              routesByPath[trimmedFullPath] = route;
            }
          }
          const children = route.children;
          if (children?.length) {
            recurseRoutes(children);
          }
        });
      };
      recurseRoutes([router.routeTree]);
      return [routesById, routesByPath];
    }, []);
    const looseRoutesById = routesById;
    const flatRoutes = React__namespace.useMemo(() => Object.values(routesByPath).map((d, i) => {
      const trimmed = trimPath(d.fullPath);
      const parsed = parsePathname(trimmed);
      while (parsed.length > 1 && parsed[0]?.value === '/') {
        parsed.shift();
      }
      const score = parsed.map(d => {
        if (d.type === 'param') {
          return 0.5;
        }
        if (d.type === 'wildcard') {
          return 0.25;
        }
        return 1;
      });
      return {
        child: d,
        trimmed,
        parsed,
        index: i,
        score
      };
    }).sort((a, b) => {
      let isIndex = a.trimmed === '/' ? 1 : b.trimmed === '/' ? -1 : 0;
      if (isIndex !== 0) return isIndex;
      const length = Math.min(a.score.length, b.score.length);

      // Sort by length of score
      if (a.score.length !== b.score.length) {
        return b.score.length - a.score.length;
      }

      // Sort by min available score
      for (let i = 0; i < length; i++) {
        if (a.score[i] !== b.score[i]) {
          return b.score[i] - a.score[i];
        }
      }

      // Sort by min available parsed value
      for (let i = 0; i < length; i++) {
        if (a.parsed[i].value !== b.parsed[i].value) {
          return a.parsed[i].value > b.parsed[i].value ? 1 : -1;
        }
      }

      // Sort by length of trimmed full path
      if (a.trimmed !== b.trimmed) {
        return a.trimmed > b.trimmed ? 1 : -1;
      }

      // Sort by original index
      return a.index - b.index;
    }).map((d, i) => {
      d.child.rank = i;
      return d.child;
    }), [routesByPath]);
    const matchRoutes = useStableCallback((pathname, locationSearch, opts) => {
      let routeParams = {};
      let foundRoute = flatRoutes.find(route => {
        const matchedParams = matchPathname(basepath, trimPathRight(pathname), {
          to: route.fullPath,
          caseSensitive: route.options.caseSensitive ?? options.caseSensitive,
          fuzzy: false
        });
        if (matchedParams) {
          routeParams = matchedParams;
          return true;
        }
        return false;
      });
      let routeCursor = foundRoute || routesById['__root__'];
      let matchedRoutes = [routeCursor];
      // let includingLayouts = true
      while (routeCursor?.parentRoute) {
        routeCursor = routeCursor.parentRoute;
        if (routeCursor) matchedRoutes.unshift(routeCursor);
      }

      // Existing matches are matches that are already loaded along with
      // pending matches that are still loading

      const parseErrors = matchedRoutes.map(route => {
        let parsedParamsError;
        if (route.options.parseParams) {
          try {
            const parsedParams = route.options.parseParams(routeParams);
            // Add the parsed params to the accumulated params bag
            Object.assign(routeParams, parsedParams);
          } catch (err) {
            parsedParamsError = new PathParamError(err.message, {
              cause: err
            });
            if (opts?.throwOnError) {
              throw parsedParamsError;
            }
            return parsedParamsError;
          }
        }
        return;
      });
      const matches = matchedRoutes.map((route, index) => {
        const interpolatedPath = interpolatePath(route.path, routeParams);
        const matchId = interpolatePath(route.id, routeParams, true);

        // Waste not, want not. If we already have a match for this route,
        // reuse it. This is important for layout routes, which might stick
        // around between navigation actions that only change leaf routes.
        const existingMatch = getRouteMatch(state, matchId);
        if (existingMatch) {
          return {
            ...existingMatch
          };
        }

        // Create a fresh route match
        const hasLoaders = !!(route.options.load || componentTypes.some(d => route.options[d]?.preload));
        const routeMatch = {
          id: matchId,
          routeId: route.id,
          params: routeParams,
          pathname: joinPaths([basepath, interpolatedPath]),
          updatedAt: Date.now(),
          routeSearch: {},
          search: {},
          status: hasLoaders ? 'pending' : 'success',
          isFetching: false,
          invalid: false,
          error: undefined,
          paramsError: parseErrors[index],
          searchError: undefined,
          loadPromise: Promise.resolve(),
          context: undefined,
          abortController: new AbortController(),
          fetchedAt: 0
        };
        return routeMatch;
      });

      // Take each match and resolve its search params and context
      // This has to happen after the matches are created or found
      // so that we can use the parent match's search params and context
      matches.forEach((match, i) => {
        const parentMatch = matches[i - 1];
        const route = looseRoutesById[match.routeId];
        const searchInfo = (() => {
          // Validate the search params and stabilize them
          const parentSearchInfo = {
            search: parentMatch?.search ?? locationSearch,
            routeSearch: parentMatch?.routeSearch ?? locationSearch
          };
          try {
            const validator = typeof route.options.validateSearch === 'object' ? route.options.validateSearch.parse : route.options.validateSearch;
            let routeSearch = validator?.(parentSearchInfo.search) ?? {};
            let search = {
              ...parentSearchInfo.search,
              ...routeSearch
            };
            routeSearch = replaceEqualDeep(match.routeSearch, routeSearch);
            search = replaceEqualDeep(match.search, search);
            return {
              routeSearch,
              search,
              searchDidChange: match.routeSearch !== routeSearch
            };
          } catch (err) {
            match.searchError = new SearchParamError(err.message, {
              cause: err
            });
            if (opts?.throwOnError) {
              throw match.searchError;
            }
            return parentSearchInfo;
          }
        })();
        Object.assign(match, searchInfo);
      });
      return matches;
    });
    const cancelMatch = useStableCallback(id => {
      getRouteMatch(state, id)?.abortController?.abort();
    });
    const cancelMatches = useStableCallback(state => {
      state.matches.forEach(match => {
        cancelMatch(match.id);
      });
    });
    const buildLocation = useStableCallback(opts => {
      const build = (dest = {}, matches) => {
        const from = latestLocationRef.current;
        const fromPathname = dest.from ?? from.pathname;
        let pathname = resolvePathWithBase(fromPathname, `${dest.to ?? ''}`);
        const fromMatches = matchRoutes(fromPathname, from.search);
        const stayingMatches = matches?.filter(d => fromMatches?.find(e => e.routeId === d.routeId));
        const prevParams = {
          ...last(fromMatches)?.params
        };
        let nextParams = (dest.params ?? true) === true ? prevParams : functionalUpdate(dest.params, prevParams);
        if (nextParams) {
          matches?.map(d => looseRoutesById[d.routeId].options.stringifyParams).filter(Boolean).forEach(fn => {
            nextParams = {
              ...nextParams,
              ...fn(nextParams)
            };
          });
        }
        pathname = interpolatePath(pathname, nextParams ?? {});
        const preSearchFilters = stayingMatches?.map(match => looseRoutesById[match.routeId].options.preSearchFilters ?? []).flat().filter(Boolean) ?? [];
        const postSearchFilters = stayingMatches?.map(match => looseRoutesById[match.routeId].options.postSearchFilters ?? []).flat().filter(Boolean) ?? [];

        // Pre filters first
        const preFilteredSearch = preSearchFilters?.length ? preSearchFilters?.reduce((prev, next) => next(prev), from.search) : from.search;

        // Then the link/navigate function
        const destSearch = dest.search === true ? preFilteredSearch // Preserve resolvedFrom true
        : dest.search ? functionalUpdate(dest.search, preFilteredSearch) ?? {} // Updater
        : preSearchFilters?.length ? preFilteredSearch // Preserve resolvedFrom filters
        : {};

        // Then post filters
        const postFilteredSearch = postSearchFilters?.length ? postSearchFilters.reduce((prev, next) => next(prev), destSearch) : destSearch;
        const search = replaceEqualDeep(from.search, postFilteredSearch);
        const searchStr = options.stringifySearch(search);
        const hash = dest.hash === true ? from.hash : dest.hash ? functionalUpdate(dest.hash, from.hash) : from.hash;
        const hashStr = hash ? `#${hash}` : '';
        let nextState = dest.state === true ? from.state : dest.state ? functionalUpdate(dest.state, from.state) : from.state;
        nextState = replaceEqualDeep(from.state, nextState);
        return {
          pathname,
          search,
          searchStr,
          state: nextState,
          hash,
          href: history.createHref(`${pathname}${searchStr}${hashStr}`),
          unmaskOnReload: dest.unmaskOnReload
        };
      };
      const buildWithMatches = (dest = {}, maskedDest) => {
        let next = build(dest);
        let maskedNext = maskedDest ? build(maskedDest) : undefined;
        if (!maskedNext) {
          let params = {};
          let foundMask = options.routeMasks?.find(d => {
            const match = matchPathname(basepath, next.pathname, {
              to: d.from,
              caseSensitive: false,
              fuzzy: false
            });
            if (match) {
              params = match;
              return true;
            }
            return false;
          });
          if (foundMask) {
            foundMask = {
              ...foundMask,
              from: interpolatePath(foundMask.from, params)
            };
            maskedDest = foundMask;
            maskedNext = build(maskedDest);
          }
        }
        const nextMatches = matchRoutes(next.pathname, next.search);
        const maskedMatches = maskedNext ? matchRoutes(maskedNext.pathname, maskedNext.search) : undefined;
        const maskedFinal = maskedNext ? build(maskedDest, maskedMatches) : undefined;
        const final = build(dest, nextMatches);
        if (maskedFinal) {
          final.maskedLocation = maskedFinal;
        }
        return final;
      };
      if (opts.mask) {
        return buildWithMatches(opts, {
          ...pick(opts, ['from']),
          ...opts.mask
        });
      }
      return buildWithMatches(opts);
    });
    const commitLocation = useStableCallback(async ({
      startTransition,
      ...next
    }) => {
      if (navigateTimeoutRef.current) clearTimeout(navigateTimeoutRef.current);
      const isSameUrl = latestLocationRef.current.href === next.href;

      // If the next urls are the same and we're not replacing,
      // do nothing
      if (!isSameUrl || !next.replace) {
        let {
          maskedLocation,
          ...nextHistory
        } = next;
        if (maskedLocation) {
          nextHistory = {
            ...maskedLocation,
            state: {
              ...maskedLocation.state,
              __tempKey: undefined,
              __tempLocation: {
                ...nextHistory,
                search: nextHistory.searchStr,
                state: {
                  ...nextHistory.state,
                  __tempKey: undefined,
                  __tempLocation: undefined,
                  key: undefined
                }
              }
            }
          };
          if (nextHistory.unmaskOnReload ?? options.unmaskOnReload ?? false) {
            nextHistory.state.__tempKey = tempLocationKeyRef.current;
          }
        }
        const apply = () => {
          history[next.replace ? 'replace' : 'push'](nextHistory.href, nextHistory.state);
        };
        if (startTransition ?? true) {
          startReactTransition(apply);
        } else {
          apply();
        }
      }
      resetNextScrollRef.current = next.resetScroll ?? true;
      return latestLoadPromiseRef.current;
    });
    const buildAndCommitLocation = useStableCallback(({
      replace,
      resetScroll,
      startTransition,
      ...rest
    } = {}) => {
      const location = buildLocation(rest);
      return commitLocation({
        ...location,
        startTransition,
        replace,
        resetScroll
      });
    });
    const navigate = useStableCallback(({
      from,
      to = '',
      ...rest
    }) => {
      // If this link simply reloads the current route,
      // make sure it has a new key so it will trigger a data refresh

      // If this `to` is a valid external URL, return
      // null for LinkUtils
      const toString = String(to);
      const fromString = typeof from === 'undefined' ? from : String(from);
      let isExternal;
      try {
        new URL(`${toString}`);
        isExternal = true;
      } catch (e) {}
      invariant(!isExternal, 'Attempting to navigate to external url with this.navigate!');
      return buildAndCommitLocation({
        ...rest,
        from: fromString,
        to: toString
      });
    });
    const loadMatches = useStableCallback(async ({
      checkLatest,
      matches,
      preload
    }) => {
      let latestPromise;
      let firstBadMatchIndex;

      // Check each match middleware to see if the route can be accessed
      try {
        for (let [index, match] of matches.entries()) {
          const parentMatch = matches[index - 1];
          const route = looseRoutesById[match.routeId];
          const handleError = (err, code) => {
            err.routerCode = code;
            firstBadMatchIndex = firstBadMatchIndex ?? index;
            if (isRedirect(err)) {
              throw err;
            }
            try {
              route.options.onError?.(err);
            } catch (errorHandlerErr) {
              err = errorHandlerErr;
              if (isRedirect(errorHandlerErr)) {
                throw errorHandlerErr;
              }
            }
            matches[index] = match = {
              ...match,
              error: err,
              status: 'error',
              updatedAt: Date.now()
            };
          };
          try {
            if (match.paramsError) {
              handleError(match.paramsError, 'PARSE_PARAMS');
            }
            if (match.searchError) {
              handleError(match.searchError, 'VALIDATE_SEARCH');
            }
            const parentContext = parentMatch?.context ?? options.context ?? {};
            const beforeLoadContext = (await route.options.beforeLoad?.({
              search: match.search,
              abortController: match.abortController,
              params: match.params,
              preload: !!preload,
              context: parentContext,
              location: state.location,
              navigate: opts => navigate({
                ...opts,
                from: match.pathname
              }),
              buildLocation
            })) ?? {};
            const context = {
              ...parentContext,
              ...beforeLoadContext
            };
            matches[index] = match = {
              ...match,
              context: replaceEqualDeep(match.context, context)
            };
          } catch (err) {
            handleError(err, 'BEFORE_LOAD');
            break;
          }
        }
      } catch (err) {
        if (isRedirect(err)) {
          if (!preload) navigate(err);
          return matches;
        }
        throw err;
      }
      const validResolvedMatches = matches.slice(0, firstBadMatchIndex);
      const matchPromises = [];
      validResolvedMatches.forEach((match, index) => {
        matchPromises.push((async () => {
          const parentMatchPromise = matchPromises[index - 1];
          const route = looseRoutesById[match.routeId];
          if (match.isFetching) {
            return getRouteMatch(state, match.id)?.loadPromise;
          }
          const handleIfRedirect = err => {
            if (isRedirect(err)) {
              if (!preload) {
                navigate(err);
              }
              return true;
            }
            return false;
          };
          const load = async () => {
            try {
              const componentsPromise = Promise.all(componentTypes.map(async type => {
                const component = route.options[type];
                if (component?.preload) {
                  await component.preload();
                }
              }));
              const loaderPromise = route.options.load?.({
                params: match.params,
                search: match.search,
                preload: !!preload,
                parentMatchPromise,
                abortController: match.abortController,
                context: match.context,
                location: state.location,
                navigate: opts => navigate({
                  ...opts,
                  from: match.pathname
                })
              });
              const [_, loaderContext] = await Promise.all([componentsPromise, loaderPromise]);
              if (latestPromise = checkLatest()) return await latestPromise;
              matches[index] = match = {
                ...match,
                error: undefined,
                status: 'success',
                isFetching: false,
                updatedAt: Date.now()
              };
            } catch (error) {
              if (latestPromise = checkLatest()) return await latestPromise;
              if (handleIfRedirect(error)) return;
              try {
                route.options.onError?.(error);
              } catch (onErrorError) {
                error = onErrorError;
                if (handleIfRedirect(onErrorError)) return;
              }
              matches[index] = match = {
                ...match,
                error,
                status: 'error',
                isFetching: false,
                updatedAt: Date.now()
              };
            }
            if (!preload) {
              setState(s => ({
                ...s,
                matches: s.matches.map(d => d.id === match.id ? match : d)
              }));
            }
          };
          let loadPromise;
          matches[index] = match = {
            ...match,
            isFetching: true,
            fetchedAt: Date.now(),
            invalid: false
          };
          loadPromise = load();
          matches[index] = match = {
            ...match,
            loadPromise
          };
          await loadPromise;
        })());
      });
      await Promise.all(matchPromises);
      return matches;
    });
    const load = useStableCallback(async () => {
      const promise = new Promise(async (resolve, reject) => {
        const next = latestLocationRef.current;
        const prevLocation = state.resolvedLocation;
        const pathDidChange = prevLocation.href !== next.href;
        let latestPromise;

        // Cancel any pending matches
        cancelMatches(state);
        router.emit({
          type: 'onBeforeLoad',
          fromLocation: prevLocation,
          toLocation: next,
          pathChanged: pathDidChange
        });

        // Match the routes
        let matches = matchRoutes(next.pathname, next.search, {
          debug: true
        });
        const previousMatches = state.matches;

        // Ingest the new matches
        setState(s => ({
          ...s,
          status: 'pending',
          location: next,
          matches
        }));
        try {
          try {
            // Load the matches
            await loadMatches({
              matches,
              checkLatest: () => checkLatest(promise)
            });
          } catch (err) {
            // swallow this error, since we'll display the
            // errors on the route components
          }

          // Only apply the latest transition
          if (latestPromise = checkLatest(promise)) {
            return latestPromise;
          }
          const exitingMatchIds = previousMatches.filter(id => !state.pendingMatches.includes(id));
          const enteringMatchIds = state.pendingMatches.filter(id => !previousMatches.includes(id));
          const stayingMatchIds = previousMatches.filter(id => state.pendingMatches.includes(id))

          // setState((s) => ({
          //   ...s,
          //   status: 'idle',
          //   resolvedLocation: s.location,
          // }))

          //
          ;
          [[exitingMatchIds, 'onLeave'], [enteringMatchIds, 'onEnter'], [stayingMatchIds, 'onTransition']].forEach(([matches, hook]) => {
            matches.forEach(match => {
              looseRoutesById[match.routeId].options[hook]?.(match);
            });
          });
          router.emit({
            type: 'onLoad',
            fromLocation: prevLocation,
            toLocation: next,
            pathChanged: pathDidChange
          });
          resolve();
        } catch (err) {
          // Only apply the latest transition
          if (latestPromise = checkLatest(promise)) {
            return latestPromise;
          }
          reject(err);
        }
      });
      latestLoadPromiseRef.current = promise;
      return latestLoadPromiseRef.current;
    });
    const preloadRoute = useStableCallback(async (navigateOpts = state.location) => {
      let next = buildLocation(navigateOpts);
      let matches = matchRoutes(next.pathname, next.search, {
        throwOnError: true
      });
      await loadMatches({
        matches,
        preload: true,
        checkLatest: () => undefined
      });
      return [last(matches), matches];
    });
    const buildLink = useStableCallback(dest => {
      // If this link simply reloads the current route,
      // make sure it has a new key so it will trigger a data refresh

      // If this `to` is a valid external URL, return
      // null for LinkUtils

      const {
        to,
        preload: userPreload,
        preloadDelay: userPreloadDelay,
        activeOptions,
        disabled,
        target,
        replace,
        resetScroll,
        startTransition
      } = dest;
      try {
        new URL(`${to}`);
        return {
          type: 'external',
          href: to
        };
      } catch (e) {}
      const nextOpts = dest;
      const next = buildLocation(nextOpts);
      const preload = userPreload ?? options.defaultPreload;
      const preloadDelay = userPreloadDelay ?? options.defaultPreloadDelay ?? 0;

      // Compare path/hash for matches
      const currentPathSplit = latestLocationRef.current.pathname.split('/');
      const nextPathSplit = next.pathname.split('/');
      const pathIsFuzzyEqual = nextPathSplit.every((d, i) => d === currentPathSplit[i]);
      // Combine the matches based on user options
      const pathTest = activeOptions?.exact ? latestLocationRef.current.pathname === next.pathname : pathIsFuzzyEqual;
      const hashTest = activeOptions?.includeHash ? latestLocationRef.current.hash === next.hash : true;
      const searchTest = activeOptions?.includeSearch ?? true ? partialDeepEqual(latestLocationRef.current.search, next.search) : true;

      // The final "active" test
      const isActive = pathTest && hashTest && searchTest;

      // The click handler
      const handleClick = e => {
        if (!disabled && !isCtrlEvent(e) && !e.defaultPrevented && (!target || target === '_self') && e.button === 0) {
          e.preventDefault();

          // All is well? Navigate!
          commitLocation({
            ...next,
            replace,
            resetScroll,
            startTransition
          });
        }
      };

      // The click handler
      const handleFocus = e => {
        if (preload) {
          preloadRoute(nextOpts).catch(err => {
            console.warn(err);
            console.warn(preloadWarning);
          });
        }
      };
      const handleTouchStart = e => {
        preloadRoute(nextOpts).catch(err => {
          console.warn(err);
          console.warn(preloadWarning);
        });
      };
      const handleEnter = e => {
        const target = e.target || {};
        if (preload) {
          if (target.preloadTimeout) {
            return;
          }
          target.preloadTimeout = setTimeout(() => {
            target.preloadTimeout = null;
            preloadRoute(nextOpts).catch(err => {
              console.warn(err);
              console.warn(preloadWarning);
            });
          }, preloadDelay);
        }
      };
      const handleLeave = e => {
        const target = e.target || {};
        if (target.preloadTimeout) {
          clearTimeout(target.preloadTimeout);
          target.preloadTimeout = null;
        }
      };
      return {
        type: 'internal',
        next,
        handleFocus,
        handleClick,
        handleEnter,
        handleLeave,
        handleTouchStart,
        isActive,
        disabled
      };
    });
    React__namespace.useLayoutEffect(() => {
      const unsub = history.subscribe(() => {
        latestLocationRef.current = parseLocation(latestLocationRef.current);
        if (state.location !== latestLocationRef.current) {
          startReactTransition(() => {
            try {
              load();
            } catch (err) {
              console.error(err);
            }
          });
        }
      });
      const nextLocation = buildLocation({
        search: true,
        params: true,
        hash: true,
        state: true
      });
      if (state.location.href !== nextLocation.href) {
        commitLocation({
          ...nextLocation,
          replace: true
        });
      }
      return () => {
        unsub();
      };
    }, [history]);
    const initialLoad = React__namespace.useRef(true);
    if (initialLoad.current) {
      initialLoad.current = false;
      startReactTransition(() => {
        try {
          load();
        } catch (err) {
          console.error(err);
        }
      });
    }
    const matchRoute = useStableCallback((location, opts) => {
      location = {
        ...location,
        to: location.to ? resolvePathWithBase(location.from || '', location.to) : undefined
      };
      const next = buildLocation(location);
      if (opts?.pending && state.status !== 'pending') {
        return false;
      }
      const baseLocation = opts?.pending ? latestLocationRef.current : state.resolvedLocation;

      // const baseLocation = state.resolvedLocation

      if (!baseLocation) {
        return false;
      }
      const match = matchPathname(basepath, baseLocation.pathname, {
        ...opts,
        to: next.pathname
      });
      if (!match) {
        return false;
      }
      if (match && (opts?.includeSearch ?? true)) {
        return partialDeepEqual(baseLocation.search, next.search) ? match : false;
      }
      return match;
    });
    const routerContextValue = {
      routeTree: router.routeTree,
      navigate,
      buildLink,
      state,
      matchRoute,
      routesById,
      options,
      history,
      load,
      buildLocation,
      subscribe: router.subscribe,
      resetNextScrollRef
    };
    return /*#__PURE__*/React__namespace.createElement(routerContext.Provider, {
      value: routerContextValue
    }, /*#__PURE__*/React__namespace.createElement(Matches, null));
  }
  function getRouteMatch(state, id) {
    return [...state.pendingMatches, ...state.matches].find(d => d.id === id);
  }
  function useRouterState(opts) {
    const {
      state
    } = useRouter();
    // return useStore(router.__store, opts?.select as any)
    return opts?.select ? opts.select(state) : state;
  }
  function useRouter() {
    const resolvedContext = window.__TSR_ROUTER_CONTEXT__ || routerContext;
    const value = React__namespace.useContext(resolvedContext);
    warning(value, 'useRouter must be used inside a <RouterProvider> component!');
    return value;
  }

  function Matches() {
    const {
      routesById,
      state
    } = useRouter();
    const {
      matches
    } = state;
    const locationKey = useRouterState().location.state.key;
    const route = routesById[rootRouteId];
    const errorComponent = React__namespace.useCallback(props => {
      return /*#__PURE__*/React__namespace.createElement(ErrorComponent, {
        ...props,
        useMatch: route.useMatch,
        useRouteContext: route.useRouteContext,
        useSearch: route.useSearch,
        useParams: route.useParams
      });
    }, [route]);
    return /*#__PURE__*/React__namespace.createElement(matchesContext.Provider, {
      value: matches
    }, /*#__PURE__*/React__namespace.createElement(CatchBoundary, {
      resetKey: locationKey,
      errorComponent: errorComponent,
      onCatch: () => {
        warning(false, `Error in router! Consider setting an 'errorComponent' in your RootRoute! 👍`);
      }
    }, matches.length ? /*#__PURE__*/React__namespace.createElement(Match, {
      matches: matches
    }) : null));
  }
  const defaultPending = () => null;
  function Match({
    matches
  }) {
    const {
      options,
      routesById
    } = useRouter();
    const match = matches[0];
    const routeId = match?.routeId;
    const route = routesById[routeId];
    const locationKey = useRouterState().location.state?.key;
    const PendingComponent = route.options.pendingComponent ?? options.defaultPendingComponent ?? defaultPending;
    const routeErrorComponent = route.options.errorComponent ?? options.defaultErrorComponent ?? ErrorComponent;
    const ResolvedSuspenseBoundary = route.options.wrapInSuspense ?? React__namespace.Suspense;
    // const ResolvedSuspenseBoundary = SafeFragment

    const errorComponent = React__namespace.useCallback(props => {
      return /*#__PURE__*/React__namespace.createElement(routeErrorComponent, {
        ...props,
        useMatch: route.useMatch,
        useRouteContext: route.useRouteContext,
        useSearch: route.useSearch,
        useParams: route.useParams
      });
    }, [route]);
    return /*#__PURE__*/React__namespace.createElement(matchesContext.Provider, {
      value: matches
    }, /*#__PURE__*/React__namespace.createElement(ResolvedSuspenseBoundary, {
      fallback: /*#__PURE__*/React__namespace.createElement(PendingComponent, {
        useMatch: route.useMatch,
        useRouteContext: route.useRouteContext,
        useSearch: route.useSearch,
        useParams: route.useParams
      })
    }, /*#__PURE__*/React__namespace.createElement(CatchBoundary, {
      resetKey: locationKey,
      errorComponent: errorComponent,
      onCatch: () => {
        warning(false, `Error in route match: ${match.id}`);
      }
    }, /*#__PURE__*/React__namespace.createElement(MatchInner, {
      match: match
    }))));
  }
  function MatchInner({
    match
  }) {
    const {
      options,
      routesById
    } = useRouter();
    const route = routesById[match.routeId];
    if (match.status === 'error') {
      throw match.error;
    }
    if (match.status === 'pending') {
      throw match.loadPromise;
    }
    if (match.status === 'success') {
      let comp = route.options.component ?? options.defaultComponent;
      if (comp) {
        return /*#__PURE__*/React__namespace.createElement(comp, {
          useMatch: route.useMatch,
          useRouteContext: route.useRouteContext,
          useSearch: route.useSearch,
          useParams: route.useParams
        });
      }
      return /*#__PURE__*/React__namespace.createElement(Outlet, null);
    }
    invariant(false, 'Idle routeMatch status encountered during rendering! You should never see this. File an issue!');
  }
  function Outlet() {
    const matches = React__namespace.useContext(matchesContext).slice(1);
    if (!matches[0]) {
      return null;
    }
    return /*#__PURE__*/React__namespace.createElement(Match, {
      matches: matches
    });
  }
  function useMatchRoute() {
    const {
      matchRoute
    } = useRouter();
    return React__namespace.useCallback(opts => {
      const {
        pending,
        caseSensitive,
        ...rest
      } = opts;
      return matchRoute(rest, {
        pending,
        caseSensitive
      });
    }, []);
  }
  function MatchRoute(props) {
    const matchRoute = useMatchRoute();
    const params = matchRoute(props);
    if (typeof props.children === 'function') {
      return props.children(params);
    }
    return !!params ? props.children : null;
  }
  function useMatch(opts) {
    const nearestMatch = React__namespace.useContext(matchesContext)[0];
    const nearestMatchRouteId = nearestMatch?.routeId;
    const matchRouteId = useRouterState({
      select: state => {
        const match = opts?.from ? state.matches.find(d => d.routeId === opts?.from) : state.matches.find(d => d.id === nearestMatch.id);
        return match.routeId;
      }
    });
    if (opts?.strict ?? true) {
      invariant(nearestMatchRouteId == matchRouteId, `useMatch("${matchRouteId}") is being called in a component that is meant to render the '${nearestMatchRouteId}' route. Did you mean to 'useMatch("${matchRouteId}", { strict: false })' or 'useRoute("${matchRouteId}")' instead?`);
    }
    const matchSelection = useRouterState({
      select: state => {
        const match = opts?.from ? state.matches.find(d => d.routeId === opts?.from) : state.matches.find(d => d.id === nearestMatch.id);
        invariant(match, `Could not find ${opts?.from ? `an active match from "${opts.from}"` : 'a nearest match!'}`);
        return opts?.select ? opts.select(match) : match;
      }
    });
    return matchSelection;
  }
  const matchesContext = /*#__PURE__*/React__namespace.createContext(null);
  function useMatches(opts) {
    const contextMatches = React__namespace.useContext(matchesContext);
    return useRouterState({
      select: state => {
        const matches = state.matches.slice(state.matches.findIndex(d => d.id === contextMatches[0]?.id));
        return opts?.select ? opts.select(matches) : matches;
      }
    });
  }

  function useParams(opts) {
    return useRouterState({
      select: state => {
        const params = last(state.matches)?.params;
        return opts?.select ? opts.select(params) : params;
      }
    });
  }

  function useSearch(opts) {
    return useMatch({
      ...opts,
      select: match => {
        return opts?.select ? opts.select(match.search) : match.search;
      }
    });
  }

  const rootRouteId = '__root__';

  // The parse type here allows a zod schema to be passed directly to the validator

  class Route {
    // Set up in this.init()

    // customId!: TCustomId

    // Optional

    constructor(options) {
      this.options = options || {};
      this.isRoot = !options?.getParentRoute;
      Route.__onInit(this);
    }
    init = opts => {
      this.originalIndex = opts.originalIndex;
      const options = this.options;
      const isRoot = !options?.path && !options?.id;
      this.parentRoute = this.options?.getParentRoute?.();
      if (isRoot) {
        this.path = rootRouteId;
      } else {
        invariant(this.parentRoute, `Child Route instances must pass a 'getParentRoute: () => ParentRoute' option that returns a Route instance.`);
      }
      let path = isRoot ? rootRouteId : options.path;

      // If the path is anything other than an index path, trim it up
      if (path && path !== '/') {
        path = trimPath(path);
      }
      const customId = options?.id || path;

      // Strip the parentId prefix from the first level of children
      let id = isRoot ? rootRouteId : joinPaths([this.parentRoute.id === rootRouteId ? '' : this.parentRoute.id, customId]);
      if (path === rootRouteId) {
        path = '/';
      }
      if (id !== rootRouteId) {
        id = joinPaths(['/', id]);
      }
      const fullPath = id === rootRouteId ? '/' : joinPaths([this.parentRoute.fullPath, path]);
      this.path = path;
      this.id = id;
      // this.customId = customId as TCustomId
      this.fullPath = fullPath;
      this.to = fullPath;
    };
    addChildren = children => {
      this.children = children;
      return this;
    };
    update = options => {
      Object.assign(this.options, options);
      return this;
    };
    static __onInit = route => {
      // This is a dummy static method that should get
      // replaced by a framework specific implementation if necessary
    };
    useMatch = opts => {
      return useMatch({
        ...opts,
        from: this.id
      });
    };
    useRouteContext = opts => {
      return useMatch({
        ...opts,
        from: this.id,
        select: d => opts?.select ? opts.select(d.context) : d.context
      });
    };
    useSearch = opts => {
      return useSearch({
        ...opts,
        from: this.id
      });
    };
    useParams = opts => {
      return useParams({
        ...opts,
        from: this.id
      });
    };
  }
  function rootRouteWithContext() {
    return options => {
      return new RootRoute(options);
    };
  }
  class RootRoute extends Route {
    constructor(options) {
      super(options);
    }
  }
  function createRouteMask(opts) {
    return opts;
  }

  //

  class FileRoute {
    constructor(path) {
      this.path = path;
    }
    createRoute = options => {
      const route = new Route(options);
      route.isRoot = false;
      return route;
    };
  }

  function lazyRouteComponent(importer, exportName) {
    let loadPromise;
    const load = () => {
      if (!loadPromise) {
        loadPromise = importer();
      }
      return loadPromise;
    };
    const lazyComp = /*#__PURE__*/React__namespace.lazy(async () => {
      const moduleExports = await load();
      const comp = moduleExports[exportName ?? 'default'];
      return {
        default: comp
      };
    });
    lazyComp.preload = load;
    return lazyComp;
  }

  function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends.apply(this, arguments);
  }

  function useLinkProps(options) {
    const {
      buildLink
    } = useRouter();
    const match = useMatch({
      strict: false
    });
    const {
      // custom props
      type,
      children,
      target,
      activeProps = () => ({
        className: 'active'
      }),
      inactiveProps = () => ({}),
      activeOptions,
      disabled,
      hash,
      search,
      params,
      to,
      state,
      mask,
      preload,
      preloadDelay,
      replace,
      startTransition,
      resetScroll,
      // element props
      style,
      className,
      onClick,
      onFocus,
      onMouseEnter,
      onMouseLeave,
      onTouchStart,
      ...rest
    } = options;
    const linkInfo = buildLink({
      from: options.to ? match.pathname : undefined,
      ...options
    });
    if (linkInfo.type === 'external') {
      const {
        href
      } = linkInfo;
      return {
        href
      };
    }
    const {
      handleClick,
      handleFocus,
      handleEnter,
      handleLeave,
      handleTouchStart,
      isActive,
      next
    } = linkInfo;
    const composeHandlers = handlers => e => {
      if (e.persist) e.persist();
      handlers.filter(Boolean).forEach(handler => {
        if (e.defaultPrevented) return;
        handler(e);
      });
    };

    // Get the active props
    const resolvedActiveProps = isActive ? functionalUpdate(activeProps, {}) ?? {} : {};

    // Get the inactive props
    const resolvedInactiveProps = isActive ? {} : functionalUpdate(inactiveProps, {}) ?? {};
    return {
      ...resolvedActiveProps,
      ...resolvedInactiveProps,
      ...rest,
      href: disabled ? undefined : next.maskedLocation ? next.maskedLocation.href : next.href,
      onClick: composeHandlers([onClick, handleClick]),
      onFocus: composeHandlers([onFocus, handleFocus]),
      onMouseEnter: composeHandlers([onMouseEnter, handleEnter]),
      onMouseLeave: composeHandlers([onMouseLeave, handleLeave]),
      onTouchStart: composeHandlers([onTouchStart, handleTouchStart]),
      target,
      style: {
        ...style,
        ...resolvedActiveProps.style,
        ...resolvedInactiveProps.style
      },
      className: [className, resolvedActiveProps.className, resolvedInactiveProps.className].filter(Boolean).join(' ') || undefined,
      ...(disabled ? {
        role: 'link',
        'aria-disabled': true
      } : undefined),
      ['data-status']: isActive ? 'active' : undefined
    };
  }
  const Link = /*#__PURE__*/React__namespace.forwardRef((props, ref) => {
    const linkProps = useLinkProps(props);
    return /*#__PURE__*/React__namespace.createElement("a", _extends({
      ref: ref
    }, linkProps, {
      children: typeof props.children === 'function' ? props.children({
        isActive: linkProps['data-status'] === 'active'
      }) : props.children
    }));
  });

  const useLayoutEffect = typeof window !== 'undefined' ? React__namespace.useLayoutEffect : React__namespace.useEffect;
  const windowKey = 'window';
  const delimiter = '___';
  let weakScrolledElements = new WeakSet();
  let cache;
  const sessionsStorage = typeof window !== 'undefined' && window.sessionStorage;
  const defaultGetKey = location => location.state.key;
  function useScrollRestoration(options) {
    const {
      state,
      subscribe,
      resetNextScrollRef
    } = useRouter();
    useLayoutEffect(() => {
      const getKey = options?.getKey || defaultGetKey;
      if (sessionsStorage) {
        if (!cache) {
          cache = (() => {
            const storageKey = 'tsr-scroll-restoration-v2';
            const state = JSON.parse(window.sessionStorage.getItem(storageKey) || 'null') || {
              cached: {},
              next: {}
            };
            return {
              state,
              set: updater => {
                cache.state = functionalUpdate(updater, cache.state);
                window.sessionStorage.setItem(storageKey, JSON.stringify(cache.state));
              }
            };
          })();
        }
      }
      const {
        history
      } = window;
      if (history.scrollRestoration) {
        history.scrollRestoration = 'manual';
      }
      const onScroll = event => {
        if (weakScrolledElements.has(event.target)) return;
        weakScrolledElements.add(event.target);
        const elementSelector = event.target === document || event.target === window ? windowKey : getCssSelector(event.target);
        if (!cache.state.next[elementSelector]) {
          cache.set(c => ({
            ...c,
            next: {
              ...c.next,
              [elementSelector]: {
                scrollX: NaN,
                scrollY: NaN
              }
            }
          }));
        }
      };
      const getCssSelector = el => {
        let path = [],
          parent;
        while (parent = el.parentNode) {
          path.unshift(`${el.tagName}:nth-child(${[].indexOf.call(parent.children, el) + 1})`);
          el = parent;
        }
        return `${path.join(' > ')}`.toLowerCase();
      };
      if (typeof document !== 'undefined') {
        document.addEventListener('scroll', onScroll, true);
      }
      const unsubOnBeforeLoad = subscribe('onBeforeLoad', event => {
        if (event.pathChanged) {
          const restoreKey = getKey(event.fromLocation);
          for (const elementSelector in cache.state.next) {
            const entry = cache.state.next[elementSelector];
            if (elementSelector === windowKey) {
              entry.scrollX = window.scrollX || 0;
              entry.scrollY = window.scrollY || 0;
            } else if (elementSelector) {
              const element = document.querySelector(elementSelector);
              entry.scrollX = element?.scrollLeft || 0;
              entry.scrollY = element?.scrollTop || 0;
            }
            cache.set(c => {
              const next = {
                ...c.next
              };
              delete next[elementSelector];
              return {
                ...c,
                next,
                cached: {
                  ...c.cached,
                  [[restoreKey, elementSelector].join(delimiter)]: entry
                }
              };
            });
          }
        }
      });
      const unsubOnResolved = subscribe('onResolved', event => {
        if (event.pathChanged) {
          if (!resetNextScrollRef.current) {
            return;
          }
          resetNextScrollRef.current = true;
          const getKey = options?.getKey || defaultGetKey;
          const restoreKey = getKey(event.toLocation);
          let windowRestored = false;
          for (const cacheKey in cache.state.cached) {
            const entry = cache.state.cached[cacheKey];
            const [key, elementSelector] = cacheKey.split(delimiter);
            if (key === restoreKey) {
              if (elementSelector === windowKey) {
                windowRestored = true;
                window.scrollTo(entry.scrollX, entry.scrollY);
              } else if (elementSelector) {
                const element = document.querySelector(elementSelector);
                if (element) {
                  element.scrollLeft = entry.scrollX;
                  element.scrollTop = entry.scrollY;
                }
              }
            }
          }
          if (!windowRestored) {
            window.scrollTo(0, 0);
          }
          cache.set(c => ({
            ...c,
            next: {}
          }));
          weakScrolledElements = new WeakSet();
        }
      });
      return () => {
        document.removeEventListener('scroll', onScroll);
        unsubOnBeforeLoad();
        unsubOnResolved();
      };
    }, []);
  }
  function ScrollRestoration(props) {
    useScrollRestoration(props);
    return null;
  }

  function useBlocker(message, condition = true) {
    const {
      history
    } = useRouter();
    React__namespace.useEffect(() => {
      if (!condition) return;
      let unblock = history.block((retry, cancel) => {
        if (window.confirm(message)) {
          unblock();
          retry();
        }
      });
      return unblock;
    });
  }
  function Block({
    message,
    condition,
    children
  }) {
    useBlocker(message, condition);
    return children ?? null;
  }

  function useNavigate(defaultOpts) {
    const {
      navigate
    } = useRouter();
    const match = useMatch({
      strict: false
    });
    return React__namespace.useCallback(opts => {
      return navigate({
        from: opts?.to ? match.pathname : undefined,
        ...defaultOpts,
        ...opts
      });
    }, []);
  }
  function typedNavigate(navigate) {
    return navigate;
  } //

  function Navigate(props) {
    const {
      navigate
    } = useRouter();
    const match = useMatch({
      strict: false
    });
    useLayoutEffect$1(() => {
      navigate({
        from: props.to ? match.pathname : undefined,
        ...props
      });
    }, []);
    return null;
  }

  exports.Block = Block;
  exports.CatchBoundary = CatchBoundary;
  exports.CatchBoundaryImpl = CatchBoundaryImpl;
  exports.ErrorComponent = ErrorComponent;
  exports.FileRoute = FileRoute;
  exports.Link = Link;
  exports.Match = Match;
  exports.MatchRoute = MatchRoute;
  exports.Matches = Matches;
  exports.Navigate = Navigate;
  exports.Outlet = Outlet;
  exports.PathParamError = PathParamError;
  exports.RootRoute = RootRoute;
  exports.Route = Route;
  exports.Router = Router;
  exports.RouterProvider = RouterProvider;
  exports.ScrollRestoration = ScrollRestoration;
  exports.SearchParamError = SearchParamError;
  exports.cleanPath = cleanPath;
  exports.componentTypes = componentTypes;
  exports.createBrowserHistory = createBrowserHistory;
  exports.createHashHistory = createHashHistory;
  exports.createMemoryHistory = createMemoryHistory;
  exports.createRouteMask = createRouteMask;
  exports.decode = decode;
  exports.defaultParseSearch = defaultParseSearch;
  exports.defaultStringifySearch = defaultStringifySearch;
  exports.encode = encode;
  exports.functionalUpdate = functionalUpdate;
  exports.getInitialRouterState = getInitialRouterState;
  exports.getRouteMatch = getRouteMatch;
  exports.interpolatePath = interpolatePath;
  exports.invariant = invariant;
  exports.isPlainObject = isPlainObject;
  exports.isRedirect = isRedirect;
  exports.isServer = isServer;
  exports.joinPaths = joinPaths;
  exports.last = last;
  exports.lazyFn = lazyFn;
  exports.lazyRouteComponent = lazyRouteComponent;
  exports.matchByPath = matchByPath;
  exports.matchPathname = matchPathname;
  exports.matchesContext = matchesContext;
  exports.parsePathname = parsePathname;
  exports.parseSearchWith = parseSearchWith;
  exports.partialDeepEqual = partialDeepEqual;
  exports.pick = pick;
  exports.redirect = redirect;
  exports.replaceEqualDeep = replaceEqualDeep;
  exports.resolvePath = resolvePath;
  exports.rootRouteId = rootRouteId;
  exports.rootRouteWithContext = rootRouteWithContext;
  exports.routerContext = routerContext;
  exports.shallow = shallow;
  exports.stringifySearchWith = stringifySearchWith;
  exports.trimPath = trimPath;
  exports.trimPathLeft = trimPathLeft;
  exports.trimPathRight = trimPathRight;
  exports.typedNavigate = typedNavigate;
  exports.useBlocker = useBlocker;
  exports.useLayoutEffect = useLayoutEffect$1;
  exports.useLinkProps = useLinkProps;
  exports.useMatch = useMatch;
  exports.useMatchRoute = useMatchRoute;
  exports.useMatches = useMatches;
  exports.useNavigate = useNavigate;
  exports.useParams = useParams;
  exports.useRouteContext = useRouteContext;
  exports.useRouter = useRouter;
  exports.useRouterState = useRouterState;
  exports.useScrollRestoration = useScrollRestoration;
  exports.useSearch = useSearch;
  exports.useStableCallback = useStableCallback;
  exports.warning = warning;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=index.development.js.map
