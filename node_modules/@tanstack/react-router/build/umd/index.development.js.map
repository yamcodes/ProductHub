{"version":3,"file":"index.development.js","sources":["../../../history/build/esm/index.js","../../../../node_modules/.pnpm/tiny-invariant@1.3.1/node_modules/tiny-invariant/dist/esm/tiny-invariant.js","../../../../node_modules/.pnpm/tiny-warning@1.0.3/node_modules/tiny-warning/dist/tiny-warning.esm.js","../../src/CatchBoundary.tsx","../../src/utils.ts","../../src/path.ts","../../src/redirects.ts","../../src/qss.ts","../../src/searchParams.ts","../../src/router.ts","../../src/RouterProvider.tsx","../../src/Matches.tsx","../../src/useParams.tsx","../../src/useSearch.tsx","../../src/route.ts","../../src/fileRoute.ts","../../src/lazyRouteComponent.tsx","../../src/link.tsx","../../src/scroll-restoration.tsx","../../src/useBlocker.tsx","../../src/useNavigate.tsx"],"sourcesContent":["/**\n * @tanstack/history/src/index.ts\n *\n * Copyright (c) TanStack\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n// While the public API was clearly inspired by the \"history\" npm package,\n// This implementation attempts to be more lightweight by\n// making assumptions about the way TanStack Router works\n\nconst pushStateEvent = 'pushstate';\nconst popStateEvent = 'popstate';\nconst beforeUnloadEvent = 'beforeunload';\nconst beforeUnloadListener = event => {\n  event.preventDefault();\n  // @ts-ignore\n  return event.returnValue = '';\n};\nconst stopBlocking = () => {\n  removeEventListener(beforeUnloadEvent, beforeUnloadListener, {\n    capture: true\n  });\n};\nfunction createHistory(opts) {\n  let location = opts.getLocation();\n  let subscribers = new Set();\n  let blockers = [];\n  let queue = [];\n  const onUpdate = () => {\n    location = opts.getLocation();\n    subscribers.forEach(subscriber => subscriber());\n  };\n  const tryUnblock = () => {\n    if (blockers.length) {\n      blockers[0]?.(tryUnblock, () => {\n        blockers = [];\n        stopBlocking();\n      });\n      return;\n    }\n    while (queue.length) {\n      queue.shift()?.();\n    }\n  };\n  const queueTask = task => {\n    queue.push(task);\n    tryUnblock();\n  };\n  return {\n    get location() {\n      return location;\n    },\n    subscribe: cb => {\n      subscribers.add(cb);\n      return () => {\n        subscribers.delete(cb);\n      };\n    },\n    push: (path, state) => {\n      state = assignKey(state);\n      queueTask(() => {\n        opts.pushState(path, state, onUpdate);\n      });\n    },\n    replace: (path, state) => {\n      state = assignKey(state);\n      queueTask(() => {\n        opts.replaceState(path, state, onUpdate);\n      });\n    },\n    go: index => {\n      queueTask(() => {\n        opts.go(index);\n      });\n    },\n    back: () => {\n      queueTask(() => {\n        opts.back();\n      });\n    },\n    forward: () => {\n      queueTask(() => {\n        opts.forward();\n      });\n    },\n    createHref: str => opts.createHref(str),\n    block: cb => {\n      blockers.push(cb);\n      if (blockers.length === 1) {\n        addEventListener(beforeUnloadEvent, beforeUnloadListener, {\n          capture: true\n        });\n      }\n      return () => {\n        blockers = blockers.filter(b => b !== cb);\n        if (!blockers.length) {\n          stopBlocking();\n        }\n      };\n    },\n    flush: () => opts.flush?.(),\n    destroy: () => opts.destroy?.(),\n    notify: onUpdate\n  };\n}\nfunction assignKey(state) {\n  if (!state) {\n    state = {};\n  }\n  return {\n    ...state,\n    key: createRandomKey()\n  };\n}\n\n/**\n * Creates a history object that can be used to interact with the browser's\n * navigation. This is a lightweight API wrapping the browser's native methods.\n * It is designed to work with TanStack Router, but could be used as a standalone API as well.\n * IMPORTANT: This API implements history throttling via a microtask to prevent\n * excessive calls to the history API. In some browsers, calling history.pushState or\n * history.replaceState in quick succession can cause the browser to ignore subsequent\n * calls. This API smooths out those differences and ensures that your application\n * state will *eventually* match the browser state. In most cases, this is not a problem,\n * but if you need to ensure that the browser state is up to date, you can use the\n * `history.flush` method to immediately flush all pending state changes to the browser URL.\n * @param opts\n * @param opts.getHref A function that returns the current href (path + search + hash)\n * @param opts.createHref A function that takes a path and returns a href (path + search + hash)\n * @returns A history instance\n */\nfunction createBrowserHistory(opts) {\n  const getHref = opts?.getHref ?? (() => `${window.location.pathname}${window.location.search}${window.location.hash}`);\n  const createHref = opts?.createHref ?? (path => path);\n  let currentLocation = parseLocation(getHref(), window.history.state);\n  const getLocation = () => currentLocation;\n  let next;\n\n  // Because we are proactively updating the location\n  // in memory before actually updating the browser history,\n  // we need to track when we are doing this so we don't\n  // notify subscribers twice on the last update.\n  let tracking = true;\n\n  // We need to track the current scheduled update to prevent\n  // multiple updates from being scheduled at the same time.\n  let scheduled;\n\n  // This function is a wrapper to prevent any of the callback's\n  // side effects from causing a subscriber notification\n  const untrack = fn => {\n    tracking = false;\n    fn();\n    tracking = true;\n  };\n\n  // This function flushes the next update to the browser history\n  const flush = () => {\n    // Do not notify subscribers about this push/replace call\n    untrack(() => {\n      if (!next) return;\n      window.history[next.isPush ? 'pushState' : 'replaceState'](next.state, '', next.href);\n      // Reset the nextIsPush flag and clear the scheduled update\n      next = undefined;\n      scheduled = undefined;\n    });\n  };\n\n  // This function queues up a call to update the browser history\n  const queueHistoryAction = (type, path, state, onUpdate) => {\n    const href = createHref(path);\n\n    // Update the location in memory\n    currentLocation = parseLocation(href, state);\n\n    // Keep track of the next location we need to flush to the URL\n    next = {\n      href,\n      state,\n      isPush: next?.isPush || type === 'push'\n    };\n    // Notify subscribers\n    onUpdate();\n    if (!scheduled) {\n      // Schedule an update to the browser history\n      scheduled = Promise.resolve().then(() => flush());\n    }\n  };\n  const onPushPop = () => {\n    currentLocation = parseLocation(getHref(), window.history.state);\n    history.notify();\n  };\n  var originalPushState = window.history.pushState;\n  var originalReplaceState = window.history.replaceState;\n  const history = createHistory({\n    getLocation,\n    pushState: (path, state, onUpdate) => queueHistoryAction('push', path, state, onUpdate),\n    replaceState: (path, state, onUpdate) => queueHistoryAction('replace', path, state, onUpdate),\n    back: () => window.history.back(),\n    forward: () => window.history.forward(),\n    go: n => window.history.go(n),\n    createHref: path => createHref(path),\n    flush,\n    destroy: () => {\n      window.history.pushState = originalPushState;\n      window.history.replaceState = originalReplaceState;\n      window.removeEventListener(pushStateEvent, onPushPop);\n      window.removeEventListener(popStateEvent, onPushPop);\n    }\n  });\n  window.addEventListener(pushStateEvent, onPushPop);\n  window.addEventListener(popStateEvent, onPushPop);\n  window.history.pushState = function () {\n    let res = originalPushState.apply(window.history, arguments);\n    if (tracking) history.notify();\n    return res;\n  };\n  window.history.replaceState = function () {\n    let res = originalReplaceState.apply(window.history, arguments);\n    if (tracking) history.notify();\n    return res;\n  };\n  return history;\n}\nfunction createHashHistory() {\n  return createBrowserHistory({\n    getHref: () => window.location.hash.substring(1),\n    createHref: path => `#${path}`\n  });\n}\nfunction createMemoryHistory(opts = {\n  initialEntries: ['/']\n}) {\n  const entries = opts.initialEntries;\n  let index = opts.initialIndex ?? entries.length - 1;\n  let currentState = {\n    key: createRandomKey()\n  };\n  const getLocation = () => parseLocation(entries[index], currentState);\n  return createHistory({\n    getLocation,\n    pushState: (path, state) => {\n      currentState = state;\n      entries.push(path);\n      index++;\n    },\n    replaceState: (path, state) => {\n      currentState = state;\n      entries[index] = path;\n    },\n    back: () => {\n      index--;\n    },\n    forward: () => {\n      index = Math.min(index + 1, entries.length - 1);\n    },\n    go: n => window.history.go(n),\n    createHref: path => path\n  });\n}\nfunction parseLocation(href, state) {\n  let hashIndex = href.indexOf('#');\n  let searchIndex = href.indexOf('?');\n  return {\n    href,\n    pathname: href.substring(0, hashIndex > 0 ? searchIndex > 0 ? Math.min(hashIndex, searchIndex) : hashIndex : searchIndex > 0 ? searchIndex : href.length),\n    hash: hashIndex > -1 ? href.substring(hashIndex) : '',\n    search: searchIndex > -1 ? href.slice(searchIndex, hashIndex === -1 ? undefined : hashIndex) : '',\n    state: state || {}\n  };\n}\n\n// Thanks co-pilot!\nfunction createRandomKey() {\n  return (Math.random() + 1).toString(36).substring(7);\n}\n\nexport { createBrowserHistory, createHashHistory, createMemoryHistory };\n//# sourceMappingURL=index.js.map\n","var isProduction = process.env.NODE_ENV === 'production';\nvar prefix = 'Invariant failed';\nfunction invariant(condition, message) {\n    if (condition) {\n        return;\n    }\n    if (isProduction) {\n        throw new Error(prefix);\n    }\n    var provided = typeof message === 'function' ? message() : message;\n    var value = provided ? \"\".concat(prefix, \": \").concat(provided) : prefix;\n    throw new Error(value);\n}\n\nexport { invariant as default };\n","var isProduction = process.env.NODE_ENV === 'production';\nfunction warning(condition, message) {\n  if (!isProduction) {\n    if (condition) {\n      return;\n    }\n\n    var text = \"Warning: \" + message;\n\n    if (typeof console !== 'undefined') {\n      console.warn(text);\n    }\n\n    try {\n      throw Error(text);\n    } catch (x) {}\n  }\n}\n\nexport default warning;\n","import * as React from 'react'\n\nexport function CatchBoundary(props: {\n  resetKey: string\n  children: any\n  errorComponent?: any\n  onCatch: (error: any) => void\n}) {\n  const errorComponent = props.errorComponent ?? ErrorComponent\n\n  return (\n    <CatchBoundaryImpl\n      resetKey={props.resetKey}\n      onCatch={props.onCatch}\n      children={({ error }) => {\n        if (error) {\n          return React.createElement(errorComponent, {\n            error,\n          })\n        }\n\n        return props.children\n      }}\n    />\n  )\n}\n\nexport class CatchBoundaryImpl extends React.Component<{\n  resetKey: string\n  children: (props: { error: any; reset: () => void }) => any\n  onCatch?: (error: any) => void\n}> {\n  state = { error: null } as any\n  static getDerivedStateFromError(error: any) {\n    return { error }\n  }\n  componentDidUpdate(\n    prevProps: Readonly<{\n      resetKey: string\n      children: (props: { error: any; reset: () => void }) => any\n      onCatch?: ((error: any, info: any) => void) | undefined\n    }>,\n    prevState: any,\n  ): void {\n    if (prevState.error && prevProps.resetKey !== this.props.resetKey) {\n      this.setState({ error: null })\n    }\n  }\n  componentDidCatch(error: any) {\n    console.error(error)\n    this.props.onCatch?.(error)\n  }\n  render() {\n    return this.props.children(this.state)\n  }\n}\n\nexport function ErrorComponent({ error }: { error: any }) {\n  const [show, setShow] = React.useState(process.env.NODE_ENV !== 'production')\n\n  return (\n    <div style={{ padding: '.5rem', maxWidth: '100%' }}>\n      <div style={{ display: 'flex', alignItems: 'center', gap: '.5rem' }}>\n        <strong style={{ fontSize: '1rem' }}>Something went wrong!</strong>\n        <button\n          style={{\n            appearance: 'none',\n            fontSize: '.6em',\n            border: '1px solid currentColor',\n            padding: '.1rem .2rem',\n            fontWeight: 'bold',\n            borderRadius: '.25rem',\n          }}\n          onClick={() => setShow((d) => !d)}\n        >\n          {show ? 'Hide Error' : 'Show Error'}\n        </button>\n      </div>\n      <div style={{ height: '.25rem' }} />\n      {show ? (\n        <div>\n          <pre\n            style={{\n              fontSize: '.7em',\n              border: '1px solid red',\n              borderRadius: '.25rem',\n              padding: '.3rem',\n              color: 'red',\n              overflow: 'auto',\n            }}\n          >\n            {error.message ? <code>{error.message}</code> : null}\n          </pre>\n        </div>\n      ) : null}\n    </div>\n  )\n}\n","import * as React from 'react'\nimport { useMatch } from './Matches'\nimport { RouteMatch } from './RouterProvider'\nimport { AnyRoute } from './route'\nimport { ParseRoute, RouteIds, RoutesById, RouteById } from './routeInfo'\nimport { RegisteredRouter } from './router'\n\nexport type NoInfer<T> = [T][T extends any ? 0 : never]\nexport type IsAny<T, Y, N = T> = 1 extends 0 & T ? Y : N\nexport type IsAnyBoolean<T> = 1 extends 0 & T ? true : false\nexport type IsKnown<T, Y, N> = unknown extends T ? N : Y\nexport type PickAsRequired<T, K extends keyof T> = Omit<T, K> &\n  Required<Pick<T, K>>\nexport type PickAsPartial<T, K extends keyof T> = Omit<T, K> &\n  Partial<Pick<T, K>>\nexport type PickUnsafe<T, K> = K extends keyof T ? Pick<T, K> : never\nexport type PickExtra<T, K> = {\n  [TKey in keyof K as string extends TKey\n    ? never\n    : TKey extends keyof T\n    ? never\n    : TKey]: K[TKey]\n}\n\nexport type PickRequired<T> = {\n  [K in keyof T as undefined extends T[K] ? never : K]: T[K]\n}\n\n// export type Expand<T> = T\nexport type Expand<T> = T extends object\n  ? T extends infer O\n    ? { [K in keyof O]: O[K] }\n    : never\n  : T\n\nexport type UnionToIntersection<U> = (\n  U extends any ? (k: U) => void : never\n) extends (k: infer I) => any\n  ? I\n  : never\n\n// type Compute<T> = { [K in keyof T]: T[K] } | never\n\n// type AllKeys<T> = T extends any ? keyof T : never\n\n// export type MergeUnion<T, Keys extends keyof T = keyof T> = Compute<\n//   {\n//     [K in Keys]: T[Keys]\n//   } & {\n//     [K in AllKeys<T>]?: T extends any\n//       ? K extends keyof T\n//         ? T[K]\n//         : never\n//       : never\n//   }\n// >\n\nexport type Assign<Left, Right> = Omit<Left, keyof Right> & Right\n\nexport type AssignAll<T extends any[]> = T extends [infer Left, ...infer Right]\n  ? Right extends any[]\n    ? Assign<Left, AssignAll<Right>>\n    : Left\n  : {}\n\n// // Sample types to merge\n// type TypeA = {\n//   shared: string\n//   onlyInA: string\n//   nested: {\n//     shared: string\n//     aProp: string\n//   }\n//   array: string[]\n// }\n\n// type TypeB = {\n//   shared: number\n//   onlyInB: number\n//   nested: {\n//     shared: number\n//     bProp: number\n//   }\n//   array: number[]\n// }\n\n// type TypeC = {\n//   shared: boolean\n//   onlyInC: boolean\n//   nested: {\n//     shared: boolean\n//     cProp: boolean\n//   }\n//   array: boolean[]\n// }\n\n// type Test = Expand<Assign<TypeA, TypeB>>\n\n// // Using DeepMerge to merge TypeA and TypeB\n// type MergedType = Expand<AssignAll<[TypeA, TypeB, TypeC]>>\n\nexport type Values<O> = O[ValueKeys<O>]\nexport type ValueKeys<O> = Extract<keyof O, PropertyKey>\n\nexport type DeepAwaited<T> = T extends Promise<infer A>\n  ? DeepAwaited<A>\n  : T extends Record<infer A, Promise<infer B>>\n  ? { [K in A]: DeepAwaited<B> }\n  : T\n\nexport type PathParamMask<TRoutePath extends string> =\n  TRoutePath extends `${infer L}/$${infer C}/${infer R}`\n    ? PathParamMask<`${L}/${string}/${R}`>\n    : TRoutePath extends `${infer L}/$${infer C}`\n    ? PathParamMask<`${L}/${string}`>\n    : TRoutePath\n\nexport type Timeout = ReturnType<typeof setTimeout>\n\nexport type Updater<TPrevious, TResult = TPrevious> =\n  | TResult\n  | ((prev?: TPrevious) => TResult)\n\nexport type NonNullableUpdater<TPrevious, TResult = TPrevious> =\n  | TResult\n  | ((prev: TPrevious) => TResult)\n\nexport type PickExtract<T, U> = {\n  [K in keyof T as T[K] extends U ? K : never]: T[K]\n}\n\nexport type PickExclude<T, U> = {\n  [K in keyof T as T[K] extends U ? never : K]: T[K]\n}\n\n//\n\nexport const isServer = typeof document === 'undefined'\n\nexport function last<T>(arr: T[]) {\n  return arr[arr.length - 1]\n}\n\nfunction isFunction(d: any): d is Function {\n  return typeof d === 'function'\n}\n\nexport function functionalUpdate<TResult>(\n  updater: Updater<TResult> | NonNullableUpdater<TResult>,\n  previous: TResult,\n): TResult {\n  if (isFunction(updater)) {\n    return updater(previous as TResult)\n  }\n\n  return updater\n}\n\nexport function pick<T, K extends keyof T>(parent: T, keys: K[]): Pick<T, K> {\n  return keys.reduce((obj: any, key: K) => {\n    obj[key] = parent[key]\n    return obj\n  }, {} as any)\n}\n\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between immutable JSON values for example.\n * Do not use this with signals\n */\nexport function replaceEqualDeep<T>(prev: any, _next: T): T {\n  if (prev === _next) {\n    return prev\n  }\n\n  const next = _next as any\n\n  const array = Array.isArray(prev) && Array.isArray(next)\n\n  if (array || (isPlainObject(prev) && isPlainObject(next))) {\n    const prevSize = array ? prev.length : Object.keys(prev).length\n    const nextItems = array ? next : Object.keys(next)\n    const nextSize = nextItems.length\n    const copy: any = array ? [] : {}\n\n    let equalItems = 0\n\n    for (let i = 0; i < nextSize; i++) {\n      const key = array ? i : nextItems[i]\n      copy[key] = replaceEqualDeep(prev[key], next[key])\n      if (copy[key] === prev[key]) {\n        equalItems++\n      }\n    }\n\n    return prevSize === nextSize && equalItems === prevSize ? prev : copy\n  }\n\n  return next\n}\n\n// Copied from: https://github.com/jonschlinkert/is-plain-object\nexport function isPlainObject(o: any) {\n  if (!hasObjectPrototype(o)) {\n    return false\n  }\n\n  // If has modified constructor\n  const ctor = o.constructor\n  if (typeof ctor === 'undefined') {\n    return true\n  }\n\n  // If has modified prototype\n  const prot = ctor.prototype\n  if (!hasObjectPrototype(prot)) {\n    return false\n  }\n\n  // If constructor does not have an Object-specific method\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false\n  }\n\n  // Most likely a plain Object\n  return true\n}\n\nfunction hasObjectPrototype(o: any) {\n  return Object.prototype.toString.call(o) === '[object Object]'\n}\n\nexport function partialDeepEqual(a: any, b: any): boolean {\n  if (a === b) {\n    return true\n  }\n\n  if (typeof a !== typeof b) {\n    return false\n  }\n\n  if (isPlainObject(a) && isPlainObject(b)) {\n    return !Object.keys(b).some((key) => !partialDeepEqual(a[key], b[key]))\n  }\n\n  if (Array.isArray(a) && Array.isArray(b)) {\n    return !(\n      a.length !== b.length ||\n      a.some((item, index) => !partialDeepEqual(item, b[index]))\n    )\n  }\n\n  return false\n}\n\nexport function useStableCallback<T extends (...args: any[]) => any>(fn: T): T {\n  const fnRef = React.useRef(fn)\n  fnRef.current = fn\n\n  const ref = React.useRef((...args: any[]) => fnRef.current(...args))\n  return ref.current as T\n}\n\nexport function shallow<T>(objA: T, objB: T) {\n  if (Object.is(objA, objB)) {\n    return true\n  }\n\n  if (\n    typeof objA !== 'object' ||\n    objA === null ||\n    typeof objB !== 'object' ||\n    objB === null\n  ) {\n    return false\n  }\n\n  const keysA = Object.keys(objA)\n  if (keysA.length !== Object.keys(objB).length) {\n    return false\n  }\n\n  for (let i = 0; i < keysA.length; i++) {\n    if (\n      !Object.prototype.hasOwnProperty.call(objB, keysA[i] as string) ||\n      !Object.is(objA[keysA[i] as keyof T], objB[keysA[i] as keyof T])\n    ) {\n      return false\n    }\n  }\n  return true\n}\n\nexport type StrictOrFrom<TFrom> =\n  | {\n      from: TFrom\n      strict?: true\n    }\n  | {\n      from?: never\n      strict: false\n    }\n\nexport type RouteFromIdOrRoute<\n  T,\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n> = T extends ParseRoute<TRouteTree>\n  ? T\n  : T extends RouteIds<TRouteTree>\n  ? RoutesById<TRouteTree>[T]\n  : T extends string\n  ? RouteIds<TRouteTree>\n  : never\n\nexport function useRouteContext<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RouteIds<TRouteTree> = RouteIds<TRouteTree>,\n  TStrict extends boolean = true,\n  TRouteContext = RouteById<TRouteTree, TFrom>['types']['allContext'],\n  TSelected = TRouteContext,\n>(\n  opts: StrictOrFrom<TFrom> & {\n    select?: (search: TRouteContext) => TSelected\n  },\n): TStrict extends true ? TSelected : TSelected | undefined {\n  return useMatch({\n    ...(opts as any),\n    select: (match: RouteMatch) =>\n      opts?.select\n        ? opts.select(match.context as TRouteContext)\n        : match.context,\n  })\n}\n\nexport const useLayoutEffect =\n  typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect\n","import { MatchLocation } from './RouterProvider'\nimport { AnyPathParams } from './route'\nimport { last } from './utils'\n\nexport interface Segment {\n  type: 'pathname' | 'param' | 'wildcard'\n  value: string\n}\n\nexport function joinPaths(paths: (string | undefined)[]) {\n  return cleanPath(paths.filter(Boolean).join('/'))\n}\n\nexport function cleanPath(path: string) {\n  // remove double slashes\n  return path.replace(/\\/{2,}/g, '/')\n}\n\nexport function trimPathLeft(path: string) {\n  return path === '/' ? path : path.replace(/^\\/{1,}/, '')\n}\n\nexport function trimPathRight(path: string) {\n  return path === '/' ? path : path.replace(/\\/{1,}$/, '')\n}\n\nexport function trimPath(path: string) {\n  return trimPathRight(trimPathLeft(path))\n}\n\nexport function resolvePath(basepath: string, base: string, to: string) {\n  base = base.replace(new RegExp(`^${basepath}`), '/')\n  to = to.replace(new RegExp(`^${basepath}`), '/')\n\n  let baseSegments = parsePathname(base)\n  const toSegments = parsePathname(to)\n\n  toSegments.forEach((toSegment, index) => {\n    if (toSegment.value === '/') {\n      if (!index) {\n        // Leading slash\n        baseSegments = [toSegment]\n      } else if (index === toSegments.length - 1) {\n        // Trailing Slash\n        baseSegments.push(toSegment)\n      } else {\n        // ignore inter-slashes\n      }\n    } else if (toSegment.value === '..') {\n      // Extra trailing slash? pop it off\n      if (baseSegments.length > 1 && last(baseSegments)?.value === '/') {\n        baseSegments.pop()\n      }\n      baseSegments.pop()\n    } else if (toSegment.value === '.') {\n      return\n    } else {\n      baseSegments.push(toSegment)\n    }\n  })\n\n  const joined = joinPaths([basepath, ...baseSegments.map((d) => d.value)])\n\n  return cleanPath(joined)\n}\n\nexport function parsePathname(pathname?: string): Segment[] {\n  if (!pathname) {\n    return []\n  }\n\n  pathname = cleanPath(pathname)\n\n  const segments: Segment[] = []\n\n  if (pathname.slice(0, 1) === '/') {\n    pathname = pathname.substring(1)\n    segments.push({\n      type: 'pathname',\n      value: '/',\n    })\n  }\n\n  if (!pathname) {\n    return segments\n  }\n\n  // Remove empty segments and '.' segments\n  const split = pathname.split('/').filter(Boolean)\n\n  segments.push(\n    ...split.map((part): Segment => {\n      if (part === '$' || part === '*') {\n        return {\n          type: 'wildcard',\n          value: part,\n        }\n      }\n\n      if (part.charAt(0) === '$') {\n        return {\n          type: 'param',\n          value: part,\n        }\n      }\n\n      return {\n        type: 'pathname',\n        value: part,\n      }\n    }),\n  )\n\n  if (pathname.slice(-1) === '/') {\n    pathname = pathname.substring(1)\n    segments.push({\n      type: 'pathname',\n      value: '/',\n    })\n  }\n\n  return segments\n}\n\nexport function interpolatePath(\n  path: string | undefined,\n  params: any,\n  leaveWildcards: boolean = false,\n) {\n  const interpolatedPathSegments = parsePathname(path)\n\n  return joinPaths(\n    interpolatedPathSegments.map((segment) => {\n      if (segment.type === 'wildcard') {\n        const value = params[segment.value]\n        if (leaveWildcards) return `${segment.value}${value ?? ''}`\n        return value\n      }\n\n      if (segment.type === 'param') {\n        return params![segment.value.substring(1)] ?? ''\n      }\n\n      return segment.value\n    }),\n  )\n}\n\nexport function matchPathname(\n  basepath: string,\n  currentPathname: string,\n  matchLocation: Pick<MatchLocation, 'to' | 'fuzzy' | 'caseSensitive'>,\n): AnyPathParams | undefined {\n  const pathParams = matchByPath(basepath, currentPathname, matchLocation)\n  // const searchMatched = matchBySearch(location.search, matchLocation)\n\n  if (matchLocation.to && !pathParams) {\n    return\n  }\n\n  return pathParams ?? {}\n}\n\nexport function matchByPath(\n  basepath: string,\n  from: string,\n  matchLocation: Pick<MatchLocation, 'to' | 'caseSensitive' | 'fuzzy'>,\n): Record<string, string> | undefined {\n  // Remove the base path from the pathname\n  from = basepath != '/' ? from.substring(basepath.length) : from\n  // Default to to $ (wildcard)\n  const to = `${matchLocation.to ?? '$'}`\n  // Parse the from and to\n  const baseSegments = parsePathname(from)\n  const routeSegments = parsePathname(to)\n\n  if (!from.startsWith('/')) {\n    baseSegments.unshift({\n      type: 'pathname',\n      value: '/',\n    })\n  }\n\n  if (!to.startsWith('/')) {\n    routeSegments.unshift({\n      type: 'pathname',\n      value: '/',\n    })\n  }\n\n  const params: Record<string, string> = {}\n\n  let isMatch = (() => {\n    for (\n      let i = 0;\n      i < Math.max(baseSegments.length, routeSegments.length);\n      i++\n    ) {\n      const baseSegment = baseSegments[i]\n      const routeSegment = routeSegments[i]\n\n      const isLastBaseSegment = i >= baseSegments.length - 1\n      const isLastRouteSegment = i >= routeSegments.length - 1\n\n      if (routeSegment) {\n        if (routeSegment.type === 'wildcard') {\n          if (baseSegment?.value) {\n            params['*'] = joinPaths(baseSegments.slice(i).map((d) => d.value))\n            return true\n          }\n          return false\n        }\n\n        if (routeSegment.type === 'pathname') {\n          if (routeSegment.value === '/' && !baseSegment?.value) {\n            return true\n          }\n\n          if (baseSegment) {\n            if (matchLocation.caseSensitive) {\n              if (routeSegment.value !== baseSegment.value) {\n                return false\n              }\n            } else if (\n              routeSegment.value.toLowerCase() !==\n              baseSegment.value.toLowerCase()\n            ) {\n              return false\n            }\n          }\n        }\n\n        if (!baseSegment) {\n          return false\n        }\n\n        if (routeSegment.type === 'param') {\n          if (baseSegment?.value === '/') {\n            return false\n          }\n          if (baseSegment.value.charAt(0) !== '$') {\n            params[routeSegment.value.substring(1)] = baseSegment.value\n          }\n        }\n      }\n\n      if (!isLastBaseSegment && isLastRouteSegment) {\n        return !!matchLocation.fuzzy\n      }\n    }\n\n    return true\n  })()\n\n  return isMatch ? (params as Record<string, string>) : undefined\n}\n","import { NavigateOptions } from './link'\nimport { AnyRoute } from './route'\nimport { RoutePaths } from './routeInfo'\nimport { RegisteredRouter } from './router'\n\n// Detect if we're in the DOM\n\nexport type AnyRedirect = Redirect<any, any, any>\n\nexport type Redirect<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = TFrom,\n  TMaskTo extends string = '',\n> = NavigateOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> & {\n  code?: number\n}\n\nexport function redirect<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n>(opts: Redirect<TRouteTree, TFrom, TTo>): Redirect<TRouteTree, TFrom, TTo> {\n  ;(opts as any).isRedirect = true\n  return opts\n}\n\nexport function isRedirect(obj: any): obj is AnyRedirect {\n  return !!obj?.isRedirect\n}\n","// @ts-nocheck\n\n// qss has been slightly modified and inlined here for our use cases (and compression's sake). We've included it as a hard dependency for MIT license attribution.\n\nexport function encode(obj, pfx?: string) {\n  var k,\n    i,\n    tmp,\n    str = ''\n\n  for (k in obj) {\n    if ((tmp = obj[k]) !== void 0) {\n      if (Array.isArray(tmp)) {\n        for (i = 0; i < tmp.length; i++) {\n          str && (str += '&')\n          str += encodeURIComponent(k) + '=' + encodeURIComponent(tmp[i])\n        }\n      } else {\n        str && (str += '&')\n        str += encodeURIComponent(k) + '=' + encodeURIComponent(tmp)\n      }\n    }\n  }\n\n  return (pfx || '') + str\n}\n\nfunction toValue(mix) {\n  if (!mix) return ''\n  var str = decodeURIComponent(mix)\n  if (str === 'false') return false\n  if (str === 'true') return true\n  return +str * 0 === 0 && +str + '' === str ? +str : str\n}\n\nexport function decode(str) {\n  var tmp,\n    k,\n    out = {},\n    arr = str.split('&')\n\n  while ((tmp = arr.shift())) {\n    tmp = tmp.split('=')\n    k = tmp.shift()\n    if (out[k] !== void 0) {\n      out[k] = [].concat(out[k], toValue(tmp.shift()))\n    } else {\n      out[k] = toValue(tmp.shift())\n    }\n  }\n\n  return out\n}\n","import { decode, encode } from './qss'\nimport { AnySearchSchema } from './route'\n\nexport const defaultParseSearch = parseSearchWith(JSON.parse)\nexport const defaultStringifySearch = stringifySearchWith(\n  JSON.stringify,\n  JSON.parse,\n)\n\nexport function parseSearchWith(parser: (str: string) => any) {\n  return (searchStr: string): AnySearchSchema => {\n    if (searchStr.substring(0, 1) === '?') {\n      searchStr = searchStr.substring(1)\n    }\n\n    let query: Record<string, unknown> = decode(searchStr)\n\n    // Try to parse any query params that might be json\n    for (let key in query) {\n      const value = query[key]\n      if (typeof value === 'string') {\n        try {\n          query[key] = parser(value)\n        } catch (err) {\n          //\n        }\n      }\n    }\n\n    return query\n  }\n}\n\nexport function stringifySearchWith(\n  stringify: (search: any) => string,\n  parser?: (str: string) => any,\n) {\n  function stringifyValue(val: any) {\n    if (typeof val === 'object' && val !== null) {\n      try {\n        return stringify(val)\n      } catch (err) {\n        // silent\n      }\n    } else if (typeof val === 'string' && typeof parser === 'function') {\n      try {\n        // Check if it's a valid parseable string.\n        // If it is, then stringify it again.\n        parser(val)\n        return stringify(val)\n      } catch (err) {\n        // silent\n      }\n    }\n    return val\n  }\n\n  return (search: Record<string, any>) => {\n    search = { ...search }\n\n    if (search) {\n      Object.keys(search).forEach((key) => {\n        const val = search[key]\n        if (typeof val === 'undefined' || val === undefined) {\n          delete search[key]\n        } else {\n          search[key] = stringifyValue(val)\n        }\n      })\n    }\n\n    const searchStr = encode(search as Record<string, string>).toString()\n\n    return searchStr ? `?${searchStr}` : ''\n  }\n}\n\nexport type SearchSerializer = (searchObj: Record<string, any>) => string\nexport type SearchParser = (searchStr: string) => Record<string, any>\n","import { RouterHistory } from '@tanstack/history'\n\n//\n\nimport {\n  AnySearchSchema,\n  AnyRoute,\n  AnyContext,\n  AnyPathParams,\n  RouteMask,\n} from './route'\nimport { FullSearchSchema } from './routeInfo'\nimport { defaultParseSearch, defaultStringifySearch } from './searchParams'\nimport { PickAsRequired, Updater, NonNullableUpdater } from './utils'\nimport {\n  ErrorRouteComponent,\n  PendingRouteComponent,\n  RouteComponent,\n} from './route'\nimport { RouteMatch } from './RouterProvider'\nimport { ParsedLocation } from './location'\nimport { LocationState } from './location'\nimport { SearchSerializer, SearchParser } from './searchParams'\nimport { RouterContext } from './RouterProvider'\n\n//\n\ndeclare global {\n  interface Window {\n    __TSR_DEHYDRATED__?: HydrationCtx\n    __TSR_ROUTER_CONTEXT__?: React.Context<RouterContext<any>>\n  }\n}\n\nexport interface Register {\n  // router: Router\n}\n\nexport type AnyRouter = Router<any, any>\n\nexport type RegisteredRouter = Register extends {\n  router: infer TRouter extends AnyRouter\n}\n  ? TRouter\n  : AnyRouter\n\nexport type HydrationCtx = {\n  router: DehydratedRouter\n  payload: Record<string, any>\n}\n\nexport type RouterContextOptions<TRouteTree extends AnyRoute> =\n  AnyContext extends TRouteTree['types']['routerContext']\n    ? {\n        context?: TRouteTree['types']['routerContext']\n      }\n    : {\n        context: TRouteTree['types']['routerContext']\n      }\n\nexport interface RouterOptions<\n  TRouteTree extends AnyRoute,\n  TDehydrated extends Record<string, any> = Record<string, any>,\n> {\n  history?: RouterHistory\n  stringifySearch?: SearchSerializer\n  parseSearch?: SearchParser\n  defaultPreload?: false | 'intent'\n  defaultPreloadDelay?: number\n  defaultComponent?: RouteComponent<AnySearchSchema, AnyPathParams, AnyContext>\n  defaultErrorComponent?: ErrorRouteComponent<\n    AnySearchSchema,\n    AnyPathParams,\n    AnyContext\n  >\n  defaultPendingComponent?: PendingRouteComponent<\n    AnySearchSchema,\n    AnyPathParams,\n    AnyContext\n  >\n  defaultMaxAge?: number\n  defaultGcMaxAge?: number\n  defaultPreloadMaxAge?: number\n  caseSensitive?: boolean\n  routeTree?: TRouteTree\n  basepath?: string\n  createRoute?: (opts: { route: AnyRoute; router: AnyRouter }) => void\n  context?: TRouteTree['types']['routerContext']\n  // dehydrate?: () => TDehydrated\n  // hydrate?: (dehydrated: TDehydrated) => void\n  routeMasks?: RouteMask<TRouteTree>[]\n  unmaskOnReload?: boolean\n}\n\nexport interface RouterState<TRouteTree extends AnyRoute = AnyRoute> {\n  status: 'pending' | 'idle'\n  matches: RouteMatch<TRouteTree>[]\n  pendingMatches: RouteMatch<TRouteTree>[]\n  location: ParsedLocation<FullSearchSchema<TRouteTree>>\n  resolvedLocation: ParsedLocation<FullSearchSchema<TRouteTree>>\n  lastUpdated: number\n}\n\nexport type ListenerFn<TEvent extends RouterEvent> = (event: TEvent) => void\n\nexport interface BuildNextOptions {\n  to?: string | number | null\n  params?: true | Updater<unknown>\n  search?: true | Updater<unknown>\n  hash?: true | Updater<string>\n  state?: true | NonNullableUpdater<LocationState>\n  mask?: {\n    to?: string | number | null\n    params?: true | Updater<unknown>\n    search?: true | Updater<unknown>\n    hash?: true | Updater<string>\n    state?: true | NonNullableUpdater<LocationState>\n    unmaskOnReload?: boolean\n  }\n  from?: string\n}\n\nexport interface DehydratedRouterState {\n  dehydratedMatches: DehydratedRouteMatch[]\n}\n\nexport type DehydratedRouteMatch = Pick<\n  RouteMatch,\n  'fetchedAt' | 'invalid' | 'id' | 'status' | 'updatedAt'\n>\n\nexport interface DehydratedRouter {\n  state: DehydratedRouterState\n}\n\nexport type RouterConstructorOptions<\n  TRouteTree extends AnyRoute,\n  TDehydrated extends Record<string, any>,\n> = Omit<RouterOptions<TRouteTree, TDehydrated>, 'context'> &\n  RouterContextOptions<TRouteTree>\n\nexport const componentTypes = [\n  'component',\n  'errorComponent',\n  'pendingComponent',\n] as const\n\nexport type RouterEvents = {\n  onBeforeLoad: {\n    type: 'onBeforeLoad'\n    fromLocation: ParsedLocation\n    toLocation: ParsedLocation\n    pathChanged: boolean\n  }\n  onLoad: {\n    type: 'onLoad'\n    fromLocation: ParsedLocation\n    toLocation: ParsedLocation\n    pathChanged: boolean\n  }\n  onResolved: {\n    type: 'onResolved'\n    fromLocation: ParsedLocation\n    toLocation: ParsedLocation\n    pathChanged: boolean\n  }\n}\n\nexport type RouterEvent = RouterEvents[keyof RouterEvents]\n\nexport type RouterListener<TRouterEvent extends RouterEvent> = {\n  eventType: TRouterEvent['type']\n  fn: ListenerFn<TRouterEvent>\n}\n\nexport class Router<\n  TRouteTree extends AnyRoute = AnyRoute,\n  TDehydrated extends Record<string, any> = Record<string, any>,\n> {\n  options: PickAsRequired<\n    RouterOptions<TRouteTree, TDehydrated>,\n    'stringifySearch' | 'parseSearch' | 'context'\n  >\n  routeTree: TRouteTree\n  // dehydratedData?: TDehydrated\n  // resetNextScroll = false\n  // tempLocationKey = `${Math.round(Math.random() * 10000000)}`\n\n  constructor(options: RouterConstructorOptions<TRouteTree, TDehydrated>) {\n    this.options = {\n      defaultPreloadDelay: 50,\n      context: undefined!,\n      ...options,\n      stringifySearch: options?.stringifySearch ?? defaultStringifySearch,\n      parseSearch: options?.parseSearch ?? defaultParseSearch,\n    }\n\n    this.routeTree = this.options.routeTree as TRouteTree\n  }\n\n  subscribers = new Set<RouterListener<RouterEvent>>()\n\n  subscribe = <TType extends keyof RouterEvents>(\n    eventType: TType,\n    fn: ListenerFn<RouterEvents[TType]>,\n  ) => {\n    const listener: RouterListener<any> = {\n      eventType,\n      fn,\n    }\n\n    this.subscribers.add(listener)\n\n    return () => {\n      this.subscribers.delete(listener)\n    }\n  }\n\n  emit = (routerEvent: RouterEvent) => {\n    this.subscribers.forEach((listener) => {\n      if (listener.eventType === routerEvent.type) {\n        listener.fn(routerEvent)\n      }\n    })\n  }\n\n  // dehydrate = (): DehydratedRouter => {\n  //   return {\n  //     state: {\n  //       dehydratedMatches: state.matches.map((d) =>\n  //         pick(d, ['fetchedAt', 'invalid', 'id', 'status', 'updatedAt']),\n  //       ),\n  //     },\n  //   }\n  // }\n\n  // hydrate = async (__do_not_use_server_ctx?: HydrationCtx) => {\n  //   let _ctx = __do_not_use_server_ctx\n  //   // Client hydrates from window\n  //   if (typeof document !== 'undefined') {\n  //     _ctx = window.__TSR_DEHYDRATED__\n  //   }\n\n  //   invariant(\n  //     _ctx,\n  //     'Expected to find a __TSR_DEHYDRATED__ property on window... but we did not. Did you forget to render <DehydrateRouter /> in your app?',\n  //   )\n\n  //   const ctx = _ctx\n  //   this.dehydratedData = ctx.payload as any\n  //   this.options.hydrate?.(ctx.payload as any)\n  //   const dehydratedState = ctx.router.state\n\n  //   let matches = this.matchRoutes(\n  //     state.location.pathname,\n  //     state.location.search,\n  //   ).map((match) => {\n  //     const dehydratedMatch = dehydratedState.dehydratedMatches.find(\n  //       (d) => d.id === match.id,\n  //     )\n\n  //     invariant(\n  //       dehydratedMatch,\n  //       `Could not find a client-side match for dehydrated match with id: ${match.id}!`,\n  //     )\n\n  //     if (dehydratedMatch) {\n  //       return {\n  //         ...match,\n  //         ...dehydratedMatch,\n  //       }\n  //     }\n  //     return match\n  //   })\n\n  //   this.setState((s) => {\n  //     return {\n  //       ...s,\n  //       matches: dehydratedState.dehydratedMatches as any,\n  //     }\n  //   })\n  // }\n\n  // TODO:\n  // injectedHtml: (string | (() => Promise<string> | string))[] = []\n\n  // TODO:\n  // injectHtml = async (html: string | (() => Promise<string> | string)) => {\n  //   this.injectedHtml.push(html)\n  // }\n\n  // TODO:\n  // dehydrateData = <T>(key: any, getData: T | (() => Promise<T> | T)) => {\n  //   if (typeof document === 'undefined') {\n  //     const strKey = typeof key === 'string' ? key : JSON.stringify(key)\n\n  //     this.injectHtml(async () => {\n  //       const id = `__TSR_DEHYDRATED__${strKey}`\n  //       const data =\n  //         typeof getData === 'function' ? await (getData as any)() : getData\n  //       return `<script id='${id}' suppressHydrationWarning>window[\"__TSR_DEHYDRATED__${escapeJSON(\n  //         strKey,\n  //       )}\"] = ${JSON.stringify(data)}\n  //       ;(() => {\n  //         var el = document.getElementById('${id}')\n  //         el.parentElement.removeChild(el)\n  //       })()\n  //       </script>`\n  //     })\n\n  //     return () => this.hydrateData<T>(key)\n  //   }\n\n  //   return () => undefined\n  // }\n\n  // hydrateData = <T = unknown>(key: any) => {\n  //   if (typeof document !== 'undefined') {\n  //     const strKey = typeof key === 'string' ? key : JSON.stringify(key)\n\n  //     return window[`__TSR_DEHYDRATED__${strKey}` as any] as T\n  //   }\n\n  //   return undefined\n  // }\n\n  // resolveMatchPromise = (matchId: string, key: string, value: any) => {\n  //   state.matches\n  //     .find((d) => d.id === matchId)\n  //     ?.__promisesByKey[key]?.resolve(value)\n  // }\n\n  // setRouteMatch = (\n  //   id: string,\n  //   pending: boolean,\n  //   updater: NonNullableUpdater<RouteMatch<TRouteTree>>,\n  // ) => {\n  //   const key = pending ? 'pendingMatches' : 'matches'\n\n  //   this.setState((prev) => {\n  //     return {\n  //       ...prev,\n  //       [key]: prev[key].map((d) => {\n  //         if (d.id === id) {\n  //           return functionalUpdate(updater, d)\n  //         }\n\n  //         return d\n  //       }),\n  //     }\n  //   })\n  // }\n\n  // setPendingRouteMatch = (\n  //   id: string,\n  //   updater: NonNullableUpdater<RouteMatch<TRouteTree>>,\n  // ) => {\n  //   this.setRouteMatch(id, true, updater)\n  // }\n}\n\nfunction escapeJSON(jsonString: string) {\n  return jsonString\n    .replace(/\\\\/g, '\\\\\\\\') // Escape backslashes\n    .replace(/'/g, \"\\\\'\") // Escape single quotes\n    .replace(/\"/g, '\\\\\"') // Escape double quotes\n}\n\n// A function that takes an import() argument which is a function and returns a new function that will\n// proxy arguments from the caller to the imported function, retaining all type\n// information along the way\nexport function lazyFn<\n  T extends Record<string, (...args: any[]) => any>,\n  TKey extends keyof T = 'default',\n>(fn: () => Promise<T>, key?: TKey) {\n  return async (...args: Parameters<T[TKey]>): Promise<ReturnType<T[TKey]>> => {\n    const imported = await fn()\n    return imported[key || 'default'](...args)\n  }\n}\n","import {\n  HistoryLocation,\n  HistoryState,\n  RouterHistory,\n  createBrowserHistory,\n} from '@tanstack/history'\nimport * as React from 'react'\nimport invariant from 'tiny-invariant'\nimport warning from 'tiny-warning'\nimport { Matches } from './Matches'\nimport {\n  LinkInfo,\n  LinkOptions,\n  NavigateOptions,\n  ResolveRelativePath,\n  ToOptions,\n} from './link'\nimport { ParsedLocation } from './location'\nimport {\n  cleanPath,\n  interpolatePath,\n  joinPaths,\n  matchPathname,\n  parsePathname,\n  resolvePath,\n  trimPath,\n  trimPathRight,\n} from './path'\nimport { isRedirect } from './redirects'\nimport { AnyPathParams, AnyRoute, AnySearchSchema, Route } from './route'\nimport {\n  FullSearchSchema,\n  ParseRoute,\n  RouteById,\n  RouteIds,\n  RoutePaths,\n  RoutesById,\n  RoutesByPath,\n} from './routeInfo'\nimport {\n  BuildNextOptions,\n  DehydratedRouteMatch,\n  RegisteredRouter,\n  Router,\n  RouterOptions,\n  RouterState,\n  componentTypes,\n} from './router'\nimport {\n  NoInfer,\n  PickAsRequired,\n  functionalUpdate,\n  last,\n  partialDeepEqual,\n  pick,\n  replaceEqualDeep,\n  useStableCallback,\n} from './utils'\nimport { MatchRouteOptions } from './Matches'\n\nexport interface CommitLocationOptions {\n  replace?: boolean\n  resetScroll?: boolean\n  startTransition?: boolean\n}\n\nexport interface MatchLocation {\n  to?: string | number | null\n  fuzzy?: boolean\n  caseSensitive?: boolean\n  from?: string\n}\n\ntype LinkCurrentTargetElement = {\n  preloadTimeout?: null | ReturnType<typeof setTimeout>\n}\n\nexport type BuildLinkFn<TRouteTree extends AnyRoute> = <\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n>(\n  dest: LinkOptions<TRouteTree, TFrom, TTo>,\n) => LinkInfo\n\nexport type NavigateFn<TRouteTree extends AnyRoute> = <\n  TRouteTree extends AnyRoute,\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = TFrom,\n  TMaskTo extends string = '',\n>({\n  from,\n  to = '' as any,\n  ...rest\n}: NavigateOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>) => Promise<void>\n\nexport type MatchRouteFn<TRouteTree extends AnyRoute> = <\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TResolved = ResolveRelativePath<TFrom, NoInfer<TTo>>,\n>(\n  location: ToOptions<TRouteTree, TFrom, TTo>,\n  opts?: MatchRouteOptions,\n) => false | RouteById<TRouteTree, TResolved>['types']['allParams']\n\nexport type LoadFn = (opts?: {\n  next?: ParsedLocation\n  throwOnError?: boolean\n  __dehydratedMatches?: DehydratedRouteMatch[]\n}) => Promise<void>\n\nexport type BuildLocationFn<TRouteTree extends AnyRoute> = (\n  opts: BuildNextOptions,\n) => ParsedLocation\n\nexport type RouterContext<\n  TRouteTree extends AnyRoute,\n  // TDehydrated extends Record<string, any>,\n> = {\n  buildLink: BuildLinkFn<TRouteTree>\n  state: RouterState<TRouteTree>\n  navigate: NavigateFn<TRouteTree>\n  matchRoute: MatchRouteFn<TRouteTree>\n  routeTree: TRouteTree\n  routesById: RoutesById<TRouteTree>\n  options: RouterOptions<TRouteTree>\n  history: RouterHistory\n  load: LoadFn\n  buildLocation: BuildLocationFn<TRouteTree>\n  subscribe: Router<TRouteTree>['subscribe']\n  resetNextScrollRef: React.MutableRefObject<boolean>\n}\n\nexport const routerContext = React.createContext<RouterContext<any>>(null!)\n\nif (typeof document !== 'undefined') {\n  window.__TSR_ROUTER_CONTEXT__ = routerContext as any\n}\n\nconst preloadWarning = 'Error preloading route! ☝️'\n\nfunction isCtrlEvent(e: MouseEvent) {\n  return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)\n}\n\nexport class SearchParamError extends Error {}\n\nexport class PathParamError extends Error {}\n\nexport function getInitialRouterState(\n  location: ParsedLocation,\n): RouterState<any> {\n  return {\n    status: 'idle',\n    resolvedLocation: location,\n    location,\n    matches: [],\n    pendingMatches: [],\n    lastUpdated: Date.now(),\n  }\n}\n\nexport function RouterProvider<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TDehydrated extends Record<string, any> = Record<string, any>,\n>({ router, ...rest }: RouterProps<TRouteTree, TDehydrated>) {\n  const options = {\n    ...router.options,\n    ...rest,\n    context: {\n      ...router.options.context,\n      ...rest?.context,\n    },\n  } as PickAsRequired<\n    RouterOptions<TRouteTree, TDehydrated>,\n    'stringifySearch' | 'parseSearch' | 'context'\n  >\n\n  const history = React.useState(\n    () => options.history ?? createBrowserHistory(),\n  )[0]\n\n  const tempLocationKeyRef = React.useRef<string | undefined>(\n    `${Math.round(Math.random() * 10000000)}`,\n  )\n  const resetNextScrollRef = React.useRef<boolean>(true)\n  const navigateTimeoutRef = React.useRef<NodeJS.Timeout | null>(null)\n  const latestLoadPromiseRef = React.useRef<Promise<void>>(Promise.resolve())\n\n  const checkLatest = (promise: Promise<void>): undefined | Promise<void> => {\n    return latestLoadPromiseRef.current !== promise\n      ? latestLoadPromiseRef.current\n      : undefined\n  }\n\n  const parseLocation = useStableCallback(\n    (\n      previousLocation?: ParsedLocation,\n    ): ParsedLocation<FullSearchSchema<TRouteTree>> => {\n      const parse = ({\n        pathname,\n        search,\n        hash,\n        state,\n      }: HistoryLocation): ParsedLocation<FullSearchSchema<TRouteTree>> => {\n        const parsedSearch = options.parseSearch(search)\n\n        return {\n          pathname: pathname,\n          searchStr: search,\n          search: replaceEqualDeep(\n            previousLocation?.search,\n            parsedSearch,\n          ) as any,\n          hash: hash.split('#').reverse()[0] ?? '',\n          href: `${pathname}${search}${hash}`,\n          state: replaceEqualDeep(\n            previousLocation?.state,\n            state,\n          ) as HistoryState,\n        }\n      }\n\n      const location = parse(history.location)\n\n      let { __tempLocation, __tempKey } = location.state\n\n      if (\n        __tempLocation &&\n        (!__tempKey || __tempKey === tempLocationKeyRef.current)\n      ) {\n        // Sync up the location keys\n        const parsedTempLocation = parse(__tempLocation) as any\n        parsedTempLocation.state.key = location.state.key\n\n        delete parsedTempLocation.state.__tempLocation\n\n        return {\n          ...parsedTempLocation,\n          maskedLocation: location,\n        }\n      }\n\n      return location\n    },\n  )\n\n  const latestLocationRef = React.useRef<ParsedLocation>(parseLocation())\n  const [preState, setState] = React.useState<RouterState<TRouteTree>>(() =>\n    getInitialRouterState(latestLocationRef.current),\n  )\n  const [isTransitioning, startReactTransition] = React.useTransition()\n\n  const state = React.useMemo<RouterState<TRouteTree>>(\n    () => ({\n      ...preState,\n      status: isTransitioning ? 'pending' : 'idle',\n      location: isTransitioning ? latestLocationRef.current : preState.location,\n    }),\n    [preState, isTransitioning],\n  )\n\n  React.useLayoutEffect(() => {\n    if (!isTransitioning && state.resolvedLocation !== state.location) {\n      router.emit({\n        type: 'onResolved',\n        fromLocation: state.resolvedLocation,\n        toLocation: state.location,\n        pathChanged: state.location!.href !== state.resolvedLocation?.href,\n      })\n      setState((s) => ({\n        ...s,\n        resolvedLocation: s.location,\n      }))\n    }\n  })\n\n  const basepath = `/${trimPath(options.basepath ?? '') ?? ''}`\n\n  const resolvePathWithBase = useStableCallback(\n    (from: string, path: string) => {\n      return resolvePath(basepath!, from, cleanPath(path))\n    },\n  )\n\n  const [routesById, routesByPath] = React.useMemo(() => {\n    const routesById = {} as RoutesById<TRouteTree>\n    const routesByPath = {} as RoutesByPath<TRouteTree>\n\n    const recurseRoutes = (routes: AnyRoute[]) => {\n      routes.forEach((route, i) => {\n        route.init({ originalIndex: i })\n\n        const existingRoute = (routesById as any)[route.id]\n\n        invariant(\n          !existingRoute,\n          `Duplicate routes found with id: ${String(route.id)}`,\n        )\n        ;(routesById as any)[route.id] = route\n\n        if (!route.isRoot && route.path) {\n          const trimmedFullPath = trimPathRight(route.fullPath)\n          if (\n            !(routesByPath as any)[trimmedFullPath] ||\n            route.fullPath.endsWith('/')\n          ) {\n            ;(routesByPath as any)[trimmedFullPath] = route\n          }\n        }\n\n        const children = route.children as Route[]\n\n        if (children?.length) {\n          recurseRoutes(children)\n        }\n      })\n    }\n\n    recurseRoutes([router.routeTree])\n\n    return [routesById, routesByPath] as const\n  }, [])\n\n  const looseRoutesById = routesById as Record<string, AnyRoute>\n\n  const flatRoutes = React.useMemo(\n    () =>\n      (Object.values(routesByPath) as AnyRoute[])\n        .map((d, i) => {\n          const trimmed = trimPath(d.fullPath)\n          const parsed = parsePathname(trimmed)\n\n          while (parsed.length > 1 && parsed[0]?.value === '/') {\n            parsed.shift()\n          }\n\n          const score = parsed.map((d) => {\n            if (d.type === 'param') {\n              return 0.5\n            }\n\n            if (d.type === 'wildcard') {\n              return 0.25\n            }\n\n            return 1\n          })\n\n          return { child: d, trimmed, parsed, index: i, score }\n        })\n        .sort((a, b) => {\n          let isIndex = a.trimmed === '/' ? 1 : b.trimmed === '/' ? -1 : 0\n\n          if (isIndex !== 0) return isIndex\n\n          const length = Math.min(a.score.length, b.score.length)\n\n          // Sort by length of score\n          if (a.score.length !== b.score.length) {\n            return b.score.length - a.score.length\n          }\n\n          // Sort by min available score\n          for (let i = 0; i < length; i++) {\n            if (a.score[i] !== b.score[i]) {\n              return b.score[i]! - a.score[i]!\n            }\n          }\n\n          // Sort by min available parsed value\n          for (let i = 0; i < length; i++) {\n            if (a.parsed[i]!.value !== b.parsed[i]!.value) {\n              return a.parsed[i]!.value! > b.parsed[i]!.value! ? 1 : -1\n            }\n          }\n\n          // Sort by length of trimmed full path\n          if (a.trimmed !== b.trimmed) {\n            return a.trimmed > b.trimmed ? 1 : -1\n          }\n\n          // Sort by original index\n          return a.index - b.index\n        })\n        .map((d, i) => {\n          d.child.rank = i\n          return d.child\n        }),\n    [routesByPath],\n  )\n\n  const matchRoutes = useStableCallback(\n    <TRouteTree extends AnyRoute>(\n      pathname: string,\n      locationSearch: AnySearchSchema,\n      opts?: { throwOnError?: boolean; debug?: boolean },\n    ): RouteMatch<TRouteTree>[] => {\n      let routeParams: AnyPathParams = {}\n\n      let foundRoute = flatRoutes.find((route) => {\n        const matchedParams = matchPathname(basepath, trimPathRight(pathname), {\n          to: route.fullPath,\n          caseSensitive: route.options.caseSensitive ?? options.caseSensitive,\n          fuzzy: false,\n        })\n\n        if (matchedParams) {\n          routeParams = matchedParams\n          return true\n        }\n\n        return false\n      })\n\n      let routeCursor: AnyRoute = foundRoute || (routesById as any)['__root__']\n\n      let matchedRoutes: AnyRoute[] = [routeCursor]\n      // let includingLayouts = true\n      while (routeCursor?.parentRoute) {\n        routeCursor = routeCursor.parentRoute\n        if (routeCursor) matchedRoutes.unshift(routeCursor)\n      }\n\n      // Existing matches are matches that are already loaded along with\n      // pending matches that are still loading\n\n      const parseErrors = matchedRoutes.map((route) => {\n        let parsedParamsError\n\n        if (route.options.parseParams) {\n          try {\n            const parsedParams = route.options.parseParams(routeParams)\n            // Add the parsed params to the accumulated params bag\n            Object.assign(routeParams, parsedParams)\n          } catch (err: any) {\n            parsedParamsError = new PathParamError(err.message, {\n              cause: err,\n            })\n\n            if (opts?.throwOnError) {\n              throw parsedParamsError\n            }\n\n            return parsedParamsError\n          }\n        }\n\n        return\n      })\n\n      const matches = matchedRoutes.map((route, index) => {\n        const interpolatedPath = interpolatePath(route.path, routeParams)\n        const matchId = interpolatePath(route.id, routeParams, true)\n\n        // Waste not, want not. If we already have a match for this route,\n        // reuse it. This is important for layout routes, which might stick\n        // around between navigation actions that only change leaf routes.\n        const existingMatch = getRouteMatch(state, matchId)\n\n        if (existingMatch) {\n          return { ...existingMatch }\n        }\n\n        // Create a fresh route match\n        const hasLoaders = !!(\n          route.options.load ||\n          componentTypes.some((d) => (route.options[d] as any)?.preload)\n        )\n\n        const routeMatch: AnyRouteMatch = {\n          id: matchId,\n          routeId: route.id,\n          params: routeParams,\n          pathname: joinPaths([basepath, interpolatedPath]),\n          updatedAt: Date.now(),\n          routeSearch: {},\n          search: {} as any,\n          status: hasLoaders ? 'pending' : 'success',\n          isFetching: false,\n          invalid: false,\n          error: undefined,\n          paramsError: parseErrors[index],\n          searchError: undefined,\n          loadPromise: Promise.resolve(),\n          context: undefined!,\n          abortController: new AbortController(),\n          fetchedAt: 0,\n        }\n\n        return routeMatch\n      })\n\n      // Take each match and resolve its search params and context\n      // This has to happen after the matches are created or found\n      // so that we can use the parent match's search params and context\n      matches.forEach((match, i): any => {\n        const parentMatch = matches[i - 1]\n        const route = looseRoutesById[match.routeId]!\n\n        const searchInfo = (() => {\n          // Validate the search params and stabilize them\n          const parentSearchInfo = {\n            search: parentMatch?.search ?? locationSearch,\n            routeSearch: parentMatch?.routeSearch ?? locationSearch,\n          }\n\n          try {\n            const validator =\n              typeof route.options.validateSearch === 'object'\n                ? route.options.validateSearch.parse\n                : route.options.validateSearch\n\n            let routeSearch = validator?.(parentSearchInfo.search) ?? {}\n\n            let search = {\n              ...parentSearchInfo.search,\n              ...routeSearch,\n            }\n\n            routeSearch = replaceEqualDeep(match.routeSearch, routeSearch)\n            search = replaceEqualDeep(match.search, search)\n\n            return {\n              routeSearch,\n              search,\n              searchDidChange: match.routeSearch !== routeSearch,\n            }\n          } catch (err: any) {\n            match.searchError = new SearchParamError(err.message, {\n              cause: err,\n            })\n\n            if (opts?.throwOnError) {\n              throw match.searchError\n            }\n\n            return parentSearchInfo\n          }\n        })()\n\n        Object.assign(match, searchInfo)\n      })\n\n      return matches as any\n    },\n  )\n\n  const cancelMatch = useStableCallback(\n    <TRouteTree extends AnyRoute>(id: string) => {\n      getRouteMatch(state, id)?.abortController?.abort()\n    },\n  )\n\n  const cancelMatches = useStableCallback(\n    <TRouteTree extends AnyRoute>(state: RouterState<TRouteTree>) => {\n      state.matches.forEach((match) => {\n        cancelMatch(match.id)\n      })\n    },\n  )\n\n  const buildLocation = useStableCallback<BuildLocationFn<TRouteTree>>(\n    (opts) => {\n      const build = (\n        dest: BuildNextOptions & {\n          unmaskOnReload?: boolean\n        } = {},\n        matches?: AnyRouteMatch[],\n      ): ParsedLocation => {\n        const from = latestLocationRef.current\n        const fromPathname = dest.from ?? from.pathname\n\n        let pathname = resolvePathWithBase(fromPathname, `${dest.to ?? ''}`)\n\n        const fromMatches = matchRoutes(fromPathname, from.search)\n        const stayingMatches = matches?.filter((d) =>\n          fromMatches?.find((e) => e.routeId === d.routeId),\n        )\n\n        const prevParams = { ...last(fromMatches)?.params }\n\n        let nextParams =\n          (dest.params ?? true) === true\n            ? prevParams\n            : functionalUpdate(dest.params!, prevParams)\n\n        if (nextParams) {\n          matches\n            ?.map((d) => looseRoutesById[d.routeId]!.options.stringifyParams)\n            .filter(Boolean)\n            .forEach((fn) => {\n              nextParams = { ...nextParams!, ...fn!(nextParams!) }\n            })\n        }\n\n        pathname = interpolatePath(pathname, nextParams ?? {})\n\n        const preSearchFilters =\n          stayingMatches\n            ?.map(\n              (match) =>\n                looseRoutesById[match.routeId]!.options.preSearchFilters ?? [],\n            )\n            .flat()\n            .filter(Boolean) ?? []\n\n        const postSearchFilters =\n          stayingMatches\n            ?.map(\n              (match) =>\n                looseRoutesById[match.routeId]!.options.postSearchFilters ?? [],\n            )\n            .flat()\n            .filter(Boolean) ?? []\n\n        // Pre filters first\n        const preFilteredSearch = preSearchFilters?.length\n          ? preSearchFilters?.reduce(\n              (prev, next) => next(prev) as any,\n              from.search,\n            )\n          : from.search\n\n        // Then the link/navigate function\n        const destSearch =\n          dest.search === true\n            ? preFilteredSearch // Preserve resolvedFrom true\n            : dest.search\n            ? functionalUpdate(dest.search, preFilteredSearch) ?? {} // Updater\n            : preSearchFilters?.length\n            ? preFilteredSearch // Preserve resolvedFrom filters\n            : {}\n\n        // Then post filters\n        const postFilteredSearch = postSearchFilters?.length\n          ? postSearchFilters.reduce((prev, next) => next(prev), destSearch)\n          : destSearch\n\n        const search = replaceEqualDeep(from.search, postFilteredSearch)\n\n        const searchStr = options.stringifySearch(search)\n\n        const hash =\n          dest.hash === true\n            ? from.hash\n            : dest.hash\n            ? functionalUpdate(dest.hash!, from.hash)\n            : from.hash\n\n        const hashStr = hash ? `#${hash}` : ''\n\n        let nextState =\n          dest.state === true\n            ? from.state\n            : dest.state\n            ? functionalUpdate(dest.state, from.state)\n            : from.state\n\n        nextState = replaceEqualDeep(from.state, nextState)\n\n        return {\n          pathname,\n          search,\n          searchStr,\n          state: nextState as any,\n          hash,\n          href: history.createHref(`${pathname}${searchStr}${hashStr}`),\n          unmaskOnReload: dest.unmaskOnReload,\n        }\n      }\n\n      const buildWithMatches = (\n        dest: BuildNextOptions = {},\n        maskedDest?: BuildNextOptions,\n      ) => {\n        let next = build(dest)\n        let maskedNext = maskedDest ? build(maskedDest) : undefined\n\n        if (!maskedNext) {\n          let params = {}\n\n          let foundMask = options.routeMasks?.find((d) => {\n            const match = matchPathname(basepath, next.pathname, {\n              to: d.from,\n              caseSensitive: false,\n              fuzzy: false,\n            })\n\n            if (match) {\n              params = match\n              return true\n            }\n\n            return false\n          })\n\n          if (foundMask) {\n            foundMask = {\n              ...foundMask,\n              from: interpolatePath(foundMask.from, params) as any,\n            }\n            maskedDest = foundMask\n            maskedNext = build(maskedDest)\n          }\n        }\n\n        const nextMatches = matchRoutes(next.pathname, next.search)\n        const maskedMatches = maskedNext\n          ? matchRoutes(maskedNext.pathname, maskedNext.search)\n          : undefined\n        const maskedFinal = maskedNext\n          ? build(maskedDest, maskedMatches)\n          : undefined\n\n        const final = build(dest, nextMatches)\n\n        if (maskedFinal) {\n          final.maskedLocation = maskedFinal\n        }\n\n        return final\n      }\n\n      if (opts.mask) {\n        return buildWithMatches(opts, {\n          ...pick(opts, ['from']),\n          ...opts.mask,\n        })\n      }\n\n      return buildWithMatches(opts)\n    },\n  )\n\n  const commitLocation = useStableCallback(\n    async ({\n      startTransition,\n      ...next\n    }: ParsedLocation & CommitLocationOptions) => {\n      if (navigateTimeoutRef.current) clearTimeout(navigateTimeoutRef.current)\n\n      const isSameUrl = latestLocationRef.current.href === next.href\n\n      // If the next urls are the same and we're not replacing,\n      // do nothing\n      if (!isSameUrl || !next.replace) {\n        let { maskedLocation, ...nextHistory } = next\n\n        if (maskedLocation) {\n          nextHistory = {\n            ...maskedLocation,\n            state: {\n              ...maskedLocation.state,\n              __tempKey: undefined,\n              __tempLocation: {\n                ...nextHistory,\n                search: nextHistory.searchStr,\n                state: {\n                  ...nextHistory.state,\n                  __tempKey: undefined!,\n                  __tempLocation: undefined!,\n                  key: undefined!,\n                },\n              },\n            },\n          }\n\n          if (nextHistory.unmaskOnReload ?? options.unmaskOnReload ?? false) {\n            nextHistory.state.__tempKey = tempLocationKeyRef.current\n          }\n        }\n\n        const apply = () => {\n          history[next.replace ? 'replace' : 'push'](\n            nextHistory.href,\n            nextHistory.state,\n          )\n        }\n\n        if (startTransition ?? true) {\n          startReactTransition(apply)\n        } else {\n          apply()\n        }\n      }\n\n      resetNextScrollRef.current = next.resetScroll ?? true\n\n      return latestLoadPromiseRef.current\n    },\n  )\n\n  const buildAndCommitLocation = useStableCallback(\n    ({\n      replace,\n      resetScroll,\n      startTransition,\n      ...rest\n    }: BuildNextOptions & CommitLocationOptions = {}) => {\n      const location = buildLocation(rest)\n      return commitLocation({\n        ...location,\n        startTransition,\n        replace,\n        resetScroll,\n      })\n    },\n  )\n\n  const navigate = useStableCallback<NavigateFn<TRouteTree>>(\n    ({ from, to = '', ...rest }) => {\n      // If this link simply reloads the current route,\n      // make sure it has a new key so it will trigger a data refresh\n\n      // If this `to` is a valid external URL, return\n      // null for LinkUtils\n      const toString = String(to)\n      const fromString = typeof from === 'undefined' ? from : String(from)\n      let isExternal\n\n      try {\n        new URL(`${toString}`)\n        isExternal = true\n      } catch (e) {}\n\n      invariant(\n        !isExternal,\n        'Attempting to navigate to external url with this.navigate!',\n      )\n\n      return buildAndCommitLocation({\n        ...rest,\n        from: fromString,\n        to: toString,\n      })\n    },\n  )\n\n  const loadMatches = useStableCallback(\n    async ({\n      checkLatest,\n      matches,\n      preload,\n    }: {\n      checkLatest: () => Promise<void> | undefined\n      matches: AnyRouteMatch[]\n      preload?: boolean\n    }): Promise<RouteMatch[]> => {\n      let latestPromise\n      let firstBadMatchIndex: number | undefined\n\n      // Check each match middleware to see if the route can be accessed\n      try {\n        for (let [index, match] of matches.entries()) {\n          const parentMatch = matches[index - 1]\n          const route = looseRoutesById[match.routeId]!\n\n          const handleError = (err: any, code: string) => {\n            err.routerCode = code\n            firstBadMatchIndex = firstBadMatchIndex ?? index\n\n            if (isRedirect(err)) {\n              throw err\n            }\n\n            try {\n              route.options.onError?.(err)\n            } catch (errorHandlerErr) {\n              err = errorHandlerErr\n\n              if (isRedirect(errorHandlerErr)) {\n                throw errorHandlerErr\n              }\n            }\n\n            matches[index] = match = {\n              ...match,\n              error: err,\n              status: 'error',\n              updatedAt: Date.now(),\n            }\n          }\n\n          try {\n            if (match.paramsError) {\n              handleError(match.paramsError, 'PARSE_PARAMS')\n            }\n\n            if (match.searchError) {\n              handleError(match.searchError, 'VALIDATE_SEARCH')\n            }\n\n            const parentContext = parentMatch?.context ?? options.context ?? {}\n\n            const beforeLoadContext =\n              (await route.options.beforeLoad?.({\n                search: match.search,\n                abortController: match.abortController,\n                params: match.params,\n                preload: !!preload,\n                context: parentContext,\n                location: state.location,\n                navigate: (opts) =>\n                  navigate({ ...opts, from: match.pathname } as any),\n                buildLocation,\n              })) ?? ({} as any)\n\n            const context = {\n              ...parentContext,\n              ...beforeLoadContext,\n            }\n\n            matches[index] = match = {\n              ...match,\n              context: replaceEqualDeep(match.context, context),\n            }\n          } catch (err) {\n            handleError(err, 'BEFORE_LOAD')\n            break\n          }\n        }\n      } catch (err) {\n        if (isRedirect(err)) {\n          if (!preload) navigate(err as any)\n          return matches\n        }\n\n        throw err\n      }\n\n      const validResolvedMatches = matches.slice(0, firstBadMatchIndex)\n      const matchPromises: Promise<any>[] = []\n\n      validResolvedMatches.forEach((match, index) => {\n        matchPromises.push(\n          (async () => {\n            const parentMatchPromise = matchPromises[index - 1]\n            const route = looseRoutesById[match.routeId]!\n\n            if (match.isFetching) {\n              return getRouteMatch(state, match.id)?.loadPromise\n            }\n\n            const handleIfRedirect = (err: any) => {\n              if (isRedirect(err)) {\n                if (!preload) {\n                  navigate(err as any)\n                }\n                return true\n              }\n              return false\n            }\n\n            const load = async () => {\n              try {\n                const componentsPromise = Promise.all(\n                  componentTypes.map(async (type) => {\n                    const component = route.options[type]\n\n                    if ((component as any)?.preload) {\n                      await (component as any).preload()\n                    }\n                  }),\n                )\n\n                const loaderPromise = route.options.load?.({\n                  params: match.params,\n                  search: match.search,\n                  preload: !!preload,\n                  parentMatchPromise,\n                  abortController: match.abortController,\n                  context: match.context,\n                  location: state.location,\n                  navigate: (opts) =>\n                    navigate({ ...opts, from: match.pathname }),\n                })\n\n                const [_, loaderContext] = await Promise.all([\n                  componentsPromise,\n                  loaderPromise,\n                ])\n                if ((latestPromise = checkLatest())) return await latestPromise\n\n                matches[index] = match = {\n                  ...match,\n                  error: undefined,\n                  status: 'success',\n                  isFetching: false,\n                  updatedAt: Date.now(),\n                }\n              } catch (error) {\n                if ((latestPromise = checkLatest())) return await latestPromise\n                if (handleIfRedirect(error)) return\n\n                try {\n                  route.options.onError?.(error)\n                } catch (onErrorError) {\n                  error = onErrorError\n                  if (handleIfRedirect(onErrorError)) return\n                }\n\n                matches[index] = match = {\n                  ...match,\n                  error,\n                  status: 'error',\n                  isFetching: false,\n                  updatedAt: Date.now(),\n                }\n              }\n\n              if (!preload) {\n                setState((s) => ({\n                  ...s,\n                  matches: s.matches.map((d) =>\n                    d.id === match.id ? match : d,\n                  ),\n                }))\n              }\n            }\n\n            let loadPromise: Promise<void> | undefined\n\n            matches[index] = match = {\n              ...match,\n              isFetching: true,\n              fetchedAt: Date.now(),\n              invalid: false,\n            }\n\n            loadPromise = load()\n\n            matches[index] = match = {\n              ...match,\n              loadPromise,\n            }\n\n            await loadPromise\n          })(),\n        )\n      })\n\n      await Promise.all(matchPromises)\n      return matches\n    },\n  )\n\n  const load = useStableCallback<LoadFn>(async () => {\n    const promise = new Promise<void>(async (resolve, reject) => {\n      const next = latestLocationRef.current\n      const prevLocation = state.resolvedLocation\n      const pathDidChange = prevLocation!.href !== next.href\n      let latestPromise: Promise<void> | undefined | null\n\n      // Cancel any pending matches\n      cancelMatches(state)\n\n      router.emit({\n        type: 'onBeforeLoad',\n        fromLocation: prevLocation,\n        toLocation: next,\n        pathChanged: pathDidChange,\n      })\n\n      // Match the routes\n      let matches: RouteMatch<any, any>[] = matchRoutes(\n        next.pathname,\n        next.search,\n        {\n          debug: true,\n        },\n      )\n\n      const previousMatches = state.matches\n\n      // Ingest the new matches\n      setState((s) => ({\n        ...s,\n        status: 'pending',\n        location: next,\n        matches,\n      }))\n\n      try {\n        try {\n          // Load the matches\n          await loadMatches({\n            matches,\n            checkLatest: () => checkLatest(promise),\n          })\n        } catch (err) {\n          // swallow this error, since we'll display the\n          // errors on the route components\n        }\n\n        // Only apply the latest transition\n        if ((latestPromise = checkLatest(promise))) {\n          return latestPromise\n        }\n\n        const exitingMatchIds = previousMatches.filter(\n          (id) => !state.pendingMatches.includes(id),\n        )\n        const enteringMatchIds = state.pendingMatches.filter(\n          (id) => !previousMatches.includes(id),\n        )\n        const stayingMatchIds = previousMatches.filter((id) =>\n          state.pendingMatches.includes(id),\n        )\n\n        // setState((s) => ({\n        //   ...s,\n        //   status: 'idle',\n        //   resolvedLocation: s.location,\n        // }))\n\n        //\n        ;(\n          [\n            [exitingMatchIds, 'onLeave'],\n            [enteringMatchIds, 'onEnter'],\n            [stayingMatchIds, 'onTransition'],\n          ] as const\n        ).forEach(([matches, hook]) => {\n          matches.forEach((match) => {\n            looseRoutesById[match.routeId]!.options[hook]?.(match)\n          })\n        })\n\n        router.emit({\n          type: 'onLoad',\n          fromLocation: prevLocation,\n          toLocation: next,\n          pathChanged: pathDidChange,\n        })\n\n        resolve()\n      } catch (err) {\n        // Only apply the latest transition\n        if ((latestPromise = checkLatest(promise))) {\n          return latestPromise\n        }\n\n        reject(err)\n      }\n    })\n\n    latestLoadPromiseRef.current = promise\n\n    return latestLoadPromiseRef.current\n  })\n\n  const preloadRoute = useStableCallback(\n    async (navigateOpts: BuildNextOptions = state.location) => {\n      let next = buildLocation(navigateOpts)\n\n      let matches = matchRoutes(next.pathname, next.search, {\n        throwOnError: true,\n      })\n\n      await loadMatches({\n        matches,\n        preload: true,\n        checkLatest: () => undefined,\n      })\n\n      return [last(matches)!, matches] as const\n    },\n  )\n\n  const buildLink = useStableCallback<BuildLinkFn<TRouteTree>>((dest) => {\n    // If this link simply reloads the current route,\n    // make sure it has a new key so it will trigger a data refresh\n\n    // If this `to` is a valid external URL, return\n    // null for LinkUtils\n\n    const {\n      to,\n      preload: userPreload,\n      preloadDelay: userPreloadDelay,\n      activeOptions,\n      disabled,\n      target,\n      replace,\n      resetScroll,\n      startTransition,\n    } = dest\n\n    try {\n      new URL(`${to}`)\n      return {\n        type: 'external',\n        href: to as any,\n      }\n    } catch (e) {}\n\n    const nextOpts = dest\n    const next = buildLocation(nextOpts as any)\n\n    const preload = userPreload ?? options.defaultPreload\n    const preloadDelay = userPreloadDelay ?? options.defaultPreloadDelay ?? 0\n\n    // Compare path/hash for matches\n    const currentPathSplit = latestLocationRef.current.pathname.split('/')\n    const nextPathSplit = next.pathname.split('/')\n    const pathIsFuzzyEqual = nextPathSplit.every(\n      (d, i) => d === currentPathSplit[i],\n    )\n    // Combine the matches based on user options\n    const pathTest = activeOptions?.exact\n      ? latestLocationRef.current.pathname === next.pathname\n      : pathIsFuzzyEqual\n    const hashTest = activeOptions?.includeHash\n      ? latestLocationRef.current.hash === next.hash\n      : true\n    const searchTest =\n      activeOptions?.includeSearch ?? true\n        ? partialDeepEqual(latestLocationRef.current.search, next.search)\n        : true\n\n    // The final \"active\" test\n    const isActive = pathTest && hashTest && searchTest\n\n    // The click handler\n    const handleClick = (e: MouseEvent) => {\n      if (\n        !disabled &&\n        !isCtrlEvent(e) &&\n        !e.defaultPrevented &&\n        (!target || target === '_self') &&\n        e.button === 0\n      ) {\n        e.preventDefault()\n\n        // All is well? Navigate!\n        commitLocation({ ...next, replace, resetScroll, startTransition })\n      }\n    }\n\n    // The click handler\n    const handleFocus = (e: MouseEvent) => {\n      if (preload) {\n        preloadRoute(nextOpts as any).catch((err) => {\n          console.warn(err)\n          console.warn(preloadWarning)\n        })\n      }\n    }\n\n    const handleTouchStart = (e: TouchEvent) => {\n      preloadRoute(nextOpts as any).catch((err) => {\n        console.warn(err)\n        console.warn(preloadWarning)\n      })\n    }\n\n    const handleEnter = (e: MouseEvent) => {\n      const target = (e.target || {}) as LinkCurrentTargetElement\n\n      if (preload) {\n        if (target.preloadTimeout) {\n          return\n        }\n\n        target.preloadTimeout = setTimeout(() => {\n          target.preloadTimeout = null\n          preloadRoute(nextOpts as any).catch((err) => {\n            console.warn(err)\n            console.warn(preloadWarning)\n          })\n        }, preloadDelay)\n      }\n    }\n\n    const handleLeave = (e: MouseEvent) => {\n      const target = (e.target || {}) as LinkCurrentTargetElement\n\n      if (target.preloadTimeout) {\n        clearTimeout(target.preloadTimeout)\n        target.preloadTimeout = null\n      }\n    }\n\n    return {\n      type: 'internal',\n      next,\n      handleFocus,\n      handleClick,\n      handleEnter,\n      handleLeave,\n      handleTouchStart,\n      isActive,\n      disabled,\n    }\n  })\n\n  React.useLayoutEffect(() => {\n    const unsub = history.subscribe(() => {\n      latestLocationRef.current = parseLocation(latestLocationRef.current)\n\n      if (state.location !== latestLocationRef.current) {\n        startReactTransition(() => {\n          try {\n            load()\n          } catch (err) {\n            console.error(err)\n          }\n        })\n      }\n    })\n\n    const nextLocation = buildLocation({\n      search: true,\n      params: true,\n      hash: true,\n      state: true,\n    })\n\n    if (state.location.href !== nextLocation.href) {\n      commitLocation({ ...nextLocation, replace: true })\n    }\n\n    return () => {\n      unsub()\n    }\n  }, [history])\n\n  const initialLoad = React.useRef(true)\n\n  if (initialLoad.current) {\n    initialLoad.current = false\n    startReactTransition(() => {\n      try {\n        load()\n      } catch (err) {\n        console.error(err)\n      }\n    })\n  }\n\n  const matchRoute = useStableCallback<MatchRouteFn<TRouteTree>>(\n    (location, opts) => {\n      location = {\n        ...location,\n        to: location.to\n          ? resolvePathWithBase((location.from || '') as string, location.to)\n          : undefined,\n      } as any\n\n      const next = buildLocation(location as any)\n\n      if (opts?.pending && state.status !== 'pending') {\n        return false\n      }\n\n      const baseLocation = opts?.pending\n        ? latestLocationRef.current\n        : state.resolvedLocation\n\n      // const baseLocation = state.resolvedLocation\n\n      if (!baseLocation) {\n        return false\n      }\n\n      const match = matchPathname(basepath, baseLocation.pathname, {\n        ...opts,\n        to: next.pathname,\n      }) as any\n\n      if (!match) {\n        return false\n      }\n\n      if (match && (opts?.includeSearch ?? true)) {\n        return partialDeepEqual(baseLocation.search, next.search)\n          ? match\n          : false\n      }\n\n      return match\n    },\n  )\n\n  const routerContextValue: RouterContext<TRouteTree> = {\n    routeTree: router.routeTree,\n    navigate,\n    buildLink,\n    state,\n    matchRoute,\n    routesById,\n    options,\n    history,\n    load,\n    buildLocation,\n    subscribe: router.subscribe,\n    resetNextScrollRef,\n  }\n\n  return (\n    <routerContext.Provider value={routerContextValue}>\n      <Matches />\n    </routerContext.Provider>\n  )\n}\n\nexport function getRouteMatch<TRouteTree extends AnyRoute>(\n  state: RouterState<TRouteTree>,\n  id: string,\n): undefined | RouteMatch<TRouteTree> {\n  return [...state.pendingMatches, ...state.matches].find((d) => d.id === id)\n}\n\nexport function useRouterState<\n  TSelected = RouterState<RegisteredRouter['routeTree']>,\n>(opts?: {\n  select: (state: RouterState<RegisteredRouter['routeTree']>) => TSelected\n}): TSelected {\n  const { state } = useRouter()\n  // return useStore(router.__store, opts?.select as any)\n  return opts?.select ? opts.select(state) : (state as any)\n}\n\nexport type RouterProps<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TDehydrated extends Record<string, any> = Record<string, any>,\n> = Omit<RouterOptions<TRouteTree, TDehydrated>, 'context'> & {\n  router: Router<TRouteTree>\n  context?: Partial<RouterOptions<TRouteTree, TDehydrated>['context']>\n}\n\nexport function useRouter<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n>(): RouterContext<TRouteTree> {\n  const resolvedContext = window.__TSR_ROUTER_CONTEXT__ || routerContext\n  const value = React.useContext(resolvedContext)\n  warning(value, 'useRouter must be used inside a <RouterProvider> component!')\n  return value as any\n}\nexport interface RouteMatch<\n  TRouteTree extends AnyRoute = AnyRoute,\n  TRouteId extends RouteIds<TRouteTree> = ParseRoute<TRouteTree>['id'],\n> {\n  id: string\n  routeId: TRouteId\n  pathname: string\n  params: RouteById<TRouteTree, TRouteId>['types']['allParams']\n  status: 'pending' | 'success' | 'error'\n  isFetching: boolean\n  invalid: boolean\n  error: unknown\n  paramsError: unknown\n  searchError: unknown\n  updatedAt: number\n  loadPromise?: Promise<void>\n  __resolveLoadPromise?: () => void\n  context: RouteById<TRouteTree, TRouteId>['types']['allContext']\n  routeSearch: RouteById<TRouteTree, TRouteId>['types']['searchSchema']\n  search: FullSearchSchema<TRouteTree> &\n    RouteById<TRouteTree, TRouteId>['types']['fullSearchSchema']\n  fetchedAt: number\n  abortController: AbortController\n}\n\nexport type AnyRouteMatch = RouteMatch<any>\n","import * as React from 'react'\nimport invariant from 'tiny-invariant'\nimport warning from 'tiny-warning'\nimport { CatchBoundary, ErrorComponent } from './CatchBoundary'\nimport { RouteMatch } from './RouterProvider'\nimport { useRouter, useRouterState } from './RouterProvider'\nimport { ResolveRelativePath, ToOptions } from './link'\nimport { AnyRoute, ReactNode, rootRouteId } from './route'\nimport { RouteById, RouteByPath, RouteIds, RoutePaths } from './routeInfo'\nimport { RegisteredRouter } from './router'\nimport { NoInfer, StrictOrFrom } from './utils'\n\nexport function Matches() {\n  const { routesById, state } = useRouter()\n  const { matches } = state\n\n  const locationKey = useRouterState().location.state.key\n\n  const route = routesById[rootRouteId]\n\n  const errorComponent = React.useCallback(\n    (props: any) => {\n      return React.createElement(ErrorComponent, {\n        ...props,\n        useMatch: route.useMatch,\n        useRouteContext: route.useRouteContext,\n        useSearch: route.useSearch,\n        useParams: route.useParams,\n      })\n    },\n    [route],\n  )\n\n  return (\n    <matchesContext.Provider value={matches}>\n      <CatchBoundary\n        resetKey={locationKey}\n        errorComponent={errorComponent}\n        onCatch={() => {\n          warning(\n            false,\n            `Error in router! Consider setting an 'errorComponent' in your RootRoute! 👍`,\n          )\n        }}\n      >\n        {matches.length ? <Match matches={matches} /> : null}\n      </CatchBoundary>\n    </matchesContext.Provider>\n  )\n}\n\nconst defaultPending = () => null\nfunction SafeFragment(props: any) {\n  return <>{props.children}</>\n}\n\nexport function Match({ matches }: { matches: RouteMatch[] }) {\n  const { options, routesById } = useRouter()\n  const match = matches[0]!\n  const routeId = match?.routeId\n  const route = routesById[routeId]\n  const locationKey = useRouterState().location.state?.key\n\n  const PendingComponent = (route.options.pendingComponent ??\n    options.defaultPendingComponent ??\n    defaultPending) as any\n\n  const routeErrorComponent =\n    route.options.errorComponent ??\n    options.defaultErrorComponent ??\n    ErrorComponent\n\n  const ResolvedSuspenseBoundary =\n    route.options.wrapInSuspense ?? React.Suspense\n  // const ResolvedSuspenseBoundary = SafeFragment\n\n  const errorComponent = React.useCallback(\n    (props: any) => {\n      return React.createElement(routeErrorComponent, {\n        ...props,\n        useMatch: route.useMatch,\n        useRouteContext: route.useRouteContext,\n        useSearch: route.useSearch,\n        useParams: route.useParams,\n      })\n    },\n    [route],\n  )\n\n  return (\n    <matchesContext.Provider value={matches}>\n      <ResolvedSuspenseBoundary\n        fallback={React.createElement(PendingComponent, {\n          useMatch: route.useMatch,\n          useRouteContext: route.useRouteContext,\n          useSearch: route.useSearch,\n          useParams: route.useParams,\n        })}\n      >\n        <CatchBoundary\n          resetKey={locationKey}\n          errorComponent={errorComponent}\n          onCatch={() => {\n            warning(false, `Error in route match: ${match.id}`)\n          }}\n        >\n          <MatchInner match={match} />\n        </CatchBoundary>\n      </ResolvedSuspenseBoundary>\n    </matchesContext.Provider>\n  )\n}\nfunction MatchInner({ match }: { match: RouteMatch }): any {\n  const { options, routesById } = useRouter()\n  const route = routesById[match.routeId]\n\n  if (match.status === 'error') {\n    throw match.error\n  }\n\n  if (match.status === 'pending') {\n    throw match.loadPromise\n  }\n\n  if (match.status === 'success') {\n    let comp = route.options.component ?? options.defaultComponent\n\n    if (comp) {\n      return React.createElement(comp, {\n        useMatch: route.useMatch,\n        useRouteContext: route.useRouteContext as any,\n        useSearch: route.useSearch,\n        useParams: route.useParams as any,\n      } as any)\n    }\n\n    return <Outlet />\n  }\n\n  invariant(\n    false,\n    'Idle routeMatch status encountered during rendering! You should never see this. File an issue!',\n  )\n}\n\nexport function Outlet() {\n  const matches = React.useContext(matchesContext).slice(1)\n\n  if (!matches[0]) {\n    return null\n  }\n\n  return <Match matches={matches} />\n}\n\nexport interface MatchRouteOptions {\n  pending?: boolean\n  caseSensitive?: boolean\n  includeSearch?: boolean\n  fuzzy?: boolean\n}\n\nexport type MakeUseMatchRouteOptions<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = '/',\n  TMaskTo extends string = '',\n> = ToOptions<AnyRoute, TFrom, TTo, TMaskFrom, TMaskTo> & MatchRouteOptions\n\nexport function useMatchRoute<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n>() {\n  const { matchRoute } = useRouter()\n\n  return React.useCallback(\n    <\n      TFrom extends RoutePaths<TRouteTree> = '/',\n      TTo extends string = '',\n      TMaskFrom extends RoutePaths<TRouteTree> = '/',\n      TMaskTo extends string = '',\n      TResolved extends string = ResolveRelativePath<TFrom, NoInfer<TTo>>,\n    >(\n      opts: MakeUseMatchRouteOptions<\n        TRouteTree,\n        TFrom,\n        TTo,\n        TMaskFrom,\n        TMaskTo\n      >,\n    ): false | RouteById<TRouteTree, TResolved>['types']['allParams'] => {\n      const { pending, caseSensitive, ...rest } = opts\n\n      return matchRoute(rest as any, {\n        pending,\n        caseSensitive,\n      })\n    },\n    [],\n  )\n}\n\nexport type MakeMatchRouteOptions<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = '/',\n  TMaskTo extends string = '',\n> = ToOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> &\n  MatchRouteOptions & {\n    // If a function is passed as a child, it will be given the `isActive` boolean to aid in further styling on the element it returns\n    children?:\n      | ((\n          params?: RouteByPath<\n            TRouteTree,\n            ResolveRelativePath<TFrom, NoInfer<TTo>>\n          >['types']['allParams'],\n        ) => ReactNode)\n      | React.ReactNode\n  }\n\nexport function MatchRoute<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = '/',\n  TMaskTo extends string = '',\n>(\n  props: MakeMatchRouteOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>,\n): any {\n  const matchRoute = useMatchRoute()\n  const params = matchRoute(props as any)\n\n  if (typeof props.children === 'function') {\n    return (props.children as any)(params)\n  }\n\n  return !!params ? props.children : null\n}\n\nexport function useMatch<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RouteIds<TRouteTree> = RouteIds<TRouteTree>,\n  TStrict extends boolean = true,\n  TRouteMatchState = RouteMatch<TRouteTree, TFrom>,\n  TSelected = TRouteMatchState,\n>(\n  opts: StrictOrFrom<TFrom> & {\n    select?: (match: TRouteMatchState) => TSelected\n  },\n): TStrict extends true ? TRouteMatchState : TRouteMatchState | undefined {\n  const nearestMatch = React.useContext(matchesContext)[0]!\n  const nearestMatchRouteId = nearestMatch?.routeId\n\n  const matchRouteId = useRouterState({\n    select: (state) => {\n      const match = opts?.from\n        ? state.matches.find((d) => d.routeId === opts?.from)\n        : state.matches.find((d) => d.id === nearestMatch.id)\n\n      return match!.routeId\n    },\n  })\n\n  if (opts?.strict ?? true) {\n    invariant(\n      nearestMatchRouteId == matchRouteId,\n      `useMatch(\"${\n        matchRouteId as string\n      }\") is being called in a component that is meant to render the '${nearestMatchRouteId}' route. Did you mean to 'useMatch(\"${\n        matchRouteId as string\n      }\", { strict: false })' or 'useRoute(\"${\n        matchRouteId as string\n      }\")' instead?`,\n    )\n  }\n\n  const matchSelection = useRouterState({\n    select: (state) => {\n      const match = opts?.from\n        ? state.matches.find((d) => d.routeId === opts?.from)\n        : state.matches.find((d) => d.id === nearestMatch.id)\n\n      invariant(\n        match,\n        `Could not find ${\n          opts?.from\n            ? `an active match from \"${opts.from}\"`\n            : 'a nearest match!'\n        }`,\n      )\n\n      return opts?.select ? opts.select(match as any) : match\n    },\n  })\n\n  return matchSelection as any\n}\n\nexport const matchesContext = React.createContext<RouteMatch[]>(null!)\n\nexport function useMatches<T = RouteMatch[]>(opts?: {\n  select?: (matches: RouteMatch[]) => T\n}): T {\n  const contextMatches = React.useContext(matchesContext)\n\n  return useRouterState({\n    select: (state) => {\n      const matches = state.matches.slice(\n        state.matches.findIndex((d) => d.id === contextMatches[0]?.id),\n      )\n      return opts?.select ? opts.select(matches) : (matches as T)\n    },\n  })\n}\n","import { AnyRoute } from './route'\nimport { RouteIds, RouteById, AllParams } from './routeInfo'\nimport { RegisteredRouter } from './router'\nimport { last } from './utils'\nimport { useRouterState } from './RouterProvider'\nimport { StrictOrFrom } from './utils'\n\nexport function useParams<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RouteIds<TRouteTree> = RouteIds<TRouteTree>,\n  TDefaultSelected = AllParams<TRouteTree> &\n    RouteById<TRouteTree, TFrom>['types']['allParams'],\n  TSelected = TDefaultSelected,\n>(\n  opts: StrictOrFrom<TFrom> & {\n    select?: (search: TDefaultSelected) => TSelected\n  },\n): TSelected {\n  return useRouterState({\n    select: (state: any) => {\n      const params = (last(state.matches) as any)?.params\n      return opts?.select ? opts.select(params) : params\n    },\n  })\n}\n","import { AnyRoute } from './route'\nimport { RouteIds, RouteById } from './routeInfo'\nimport { RegisteredRouter } from './router'\nimport { RouteMatch } from './RouterProvider'\nimport { useMatch } from './Matches'\nimport { StrictOrFrom } from './utils'\n\nexport function useSearch<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RouteIds<TRouteTree> = RouteIds<TRouteTree>,\n  TStrict extends boolean = true,\n  TSearch = RouteById<TRouteTree, TFrom>['types']['fullSearchSchema'],\n  TSelected = TSearch,\n>(\n  opts: StrictOrFrom<TFrom> & {\n    select?: (search: TSearch) => TSelected\n  },\n): TStrict extends true ? TSelected : TSelected | undefined {\n  return useMatch({\n    ...(opts as any),\n    select: (match: RouteMatch) => {\n      return opts?.select ? opts.select(match.search as TSearch) : match.search\n    },\n  })\n}\n","import { HistoryLocation } from '@tanstack/history'\nimport * as React from 'react'\nimport invariant from 'tiny-invariant'\nimport { useMatch } from './Matches'\nimport { AnyRouteMatch } from './RouterProvider'\nimport { NavigateOptions, ParsePathParams, ToSubOptions } from './link'\nimport { ParsedLocation } from './location'\nimport { joinPaths, trimPath } from './path'\nimport { RoutePaths } from './routeInfo'\nimport { AnyRouter } from './router'\nimport { useParams } from './useParams'\nimport { useSearch } from './useSearch'\nimport {\n  Assign,\n  Expand,\n  IsAny,\n  NoInfer,\n  PickRequired,\n  UnionToIntersection,\n} from './utils'\nimport { BuildLocationFn, NavigateFn } from './RouterProvider'\n\nexport const rootRouteId = '__root__' as const\nexport type RootRouteId = typeof rootRouteId\nexport type AnyPathParams = {}\n\nexport type AnySearchSchema = {}\n\nexport type AnyContext = {}\n\nexport interface RouteContext {}\n\nexport interface RouteMeta {}\n\nexport type PreloadableObj = { preload?: () => Promise<void> }\n\nexport type RoutePathOptions<TCustomId, TPath> =\n  | {\n      path: TPath\n    }\n  | {\n      id: TCustomId\n    }\n\nexport type RoutePathOptionsIntersection<TCustomId, TPath> =\n  UnionToIntersection<RoutePathOptions<TCustomId, TPath>>\n\nexport type MetaOptions = keyof PickRequired<RouteMeta> extends never\n  ? {\n      meta?: RouteMeta\n    }\n  : {\n      meta: RouteMeta\n    }\n\nexport type RouteOptions<\n  TParentRoute extends AnyRoute = AnyRoute,\n  TCustomId extends string = string,\n  TPath extends string = string,\n  TSearchSchema extends Record<string, any> = {},\n  TFullSearchSchema extends Record<string, any> = TSearchSchema,\n  TParams extends AnyPathParams = AnyPathParams,\n  TAllParams extends AnyPathParams = TParams,\n  TRouteContext extends RouteContext = RouteContext,\n  TAllContext extends Record<string, any> = AnyContext,\n> = BaseRouteOptions<\n  TParentRoute,\n  TCustomId,\n  TPath,\n  TSearchSchema,\n  TFullSearchSchema,\n  TParams,\n  TAllParams,\n  TRouteContext,\n  TAllContext\n> &\n  NoInfer<UpdatableRouteOptions<TFullSearchSchema, TAllParams, TAllContext>>\n\nexport type ParamsFallback<\n  TPath extends string,\n  TParams,\n> = unknown extends TParams ? Record<ParsePathParams<TPath>, string> : TParams\n\ntype Prefix<T extends string, U extends string> = U extends `${T}${infer _}`\n  ? U\n  : never\n\nexport type BaseRouteOptions<\n  TParentRoute extends AnyRoute = AnyRoute,\n  TCustomId extends string = string,\n  TPath extends string = string,\n  TSearchSchema extends Record<string, any> = {},\n  TFullSearchSchema extends Record<string, any> = TSearchSchema,\n  TParams extends AnyPathParams = {},\n  TAllParams = ParamsFallback<TPath, TParams>,\n  TRouteContext extends RouteContext = RouteContext,\n  TAllContext extends Record<string, any> = AnyContext,\n> = RoutePathOptions<TCustomId, TPath> & {\n  getParentRoute: () => TParentRoute\n  validateSearch?: SearchSchemaValidator<TSearchSchema>\n} & (keyof PickRequired<RouteContext> extends never\n    ? // This async function is called before a route is loaded.\n      // If an error is thrown here, the route's loader will not be called.\n      // If thrown during a navigation, the navigation will be cancelled and the error will be passed to the `onError` function.\n      // If thrown during a preload event, the error will be logged to the console.\n      {\n        beforeLoad?: BeforeLoadFn<\n          TFullSearchSchema,\n          TParentRoute,\n          TAllParams,\n          TRouteContext\n        >\n      }\n    : {\n        beforeLoad: BeforeLoadFn<\n          TFullSearchSchema,\n          TParentRoute,\n          TAllParams,\n          TRouteContext\n        >\n      }) & {\n    load?: RouteLoadFn<\n      TAllParams,\n      TFullSearchSchema,\n      NoInfer<TAllContext>,\n      NoInfer<TRouteContext>\n    >\n  } & (\n    | {\n        // Both or none\n        parseParams?: (\n          rawParams: IsAny<TPath, any, Record<ParsePathParams<TPath>, string>>,\n        ) => TParams extends Record<ParsePathParams<TPath>, any>\n          ? TParams\n          : 'parseParams must return an object'\n        stringifyParams?: (\n          params: NoInfer<ParamsFallback<TPath, TParams>>,\n        ) => Record<ParsePathParams<TPath>, string>\n      }\n    | {\n        stringifyParams?: never\n        parseParams?: never\n      }\n  )\n\ntype BeforeLoadFn<\n  TFullSearchSchema extends Record<string, any>,\n  TParentRoute extends AnyRoute,\n  TAllParams,\n  TRouteContext,\n> = (opts: {\n  search: TFullSearchSchema\n  abortController: AbortController\n  preload: boolean\n  params: TAllParams\n  context: TParentRoute['types']['allContext']\n  location: ParsedLocation\n  navigate: NavigateFn<AnyRoute>\n  buildLocation: BuildLocationFn<AnyRoute>\n}) => Promise<TRouteContext> | TRouteContext | void\n\nexport type UpdatableRouteOptions<\n  TFullSearchSchema extends Record<string, any>,\n  TAllParams extends AnyPathParams,\n  TAllContext extends AnyContext,\n> = MetaOptions & {\n  // test?: (args: TAllContext) => void\n  // If true, this route will be matched as case-sensitive\n  caseSensitive?: boolean\n  // If true, this route will be forcefully wrapped in a suspense boundary\n  wrapInSuspense?: boolean\n  // The content to be rendered when the route is matched. If no component is provided, defaults to `<Outlet />`\n  component?: RouteComponent<TFullSearchSchema, TAllParams, TAllContext>\n  // The content to be rendered when the route encounters an error\n  errorComponent?: ErrorRouteComponent<\n    TFullSearchSchema,\n    TAllParams,\n    {}\n    // TAllContext // TODO: I have no idea why this breaks the universe,\n    // so we'll come back to it later.\n  > //\n  // If supported by your framework, the content to be rendered as the fallback content until the route is ready to render\n  pendingComponent?: PendingRouteComponent<\n    TFullSearchSchema,\n    TAllParams,\n    TAllContext\n  >\n  // Filter functions that can manipulate search params *before* they are passed to links and navigate\n  // calls that match this route.\n  preSearchFilters?: SearchFilter<TFullSearchSchema>[]\n  // Filter functions that can manipulate search params *after* they are passed to links and navigate\n  // calls that match this route.\n  postSearchFilters?: SearchFilter<TFullSearchSchema>[]\n  onError?: (err: any) => void\n  // These functions are called as route matches are loaded, stick around and leave the active\n  // matches\n  onEnter?: (match: AnyRouteMatch) => void\n  onTransition?: (match: AnyRouteMatch) => void\n  onLeave?: (match: AnyRouteMatch) => void\n  // Set this to true or false to specifically set whether or not this route should be preloaded. If unset, will\n  // default to router.options.reloadOnWindowFocus\n  reloadOnWindowFocus?: boolean\n}\n\nexport type ParseParamsOption<TPath extends string, TParams> = ParseParamsFn<\n  TPath,\n  TParams\n>\n\nexport type ParseParamsFn<TPath extends string, TParams> = (\n  rawParams: IsAny<TPath, any, Record<ParsePathParams<TPath>, string>>,\n) => TParams extends Record<ParsePathParams<TPath>, any>\n  ? TParams\n  : 'parseParams must return an object'\n\nexport type ParseParamsObj<TPath extends string, TParams> = {\n  parse?: ParseParamsFn<TPath, TParams>\n}\n\n// The parse type here allows a zod schema to be passed directly to the validator\nexport type SearchSchemaValidator<TReturn> =\n  | SearchSchemaValidatorObj<TReturn>\n  | SearchSchemaValidatorFn<TReturn>\n\nexport type SearchSchemaValidatorObj<TReturn> = {\n  parse?: SearchSchemaValidatorFn<TReturn>\n}\n\nexport type SearchSchemaValidatorFn<TReturn> = (\n  searchObj: Record<string, unknown>,\n) => TReturn\n\nexport type DefinedPathParamWarning =\n  'Path params cannot be redefined by child routes!'\n\nexport type ParentParams<TParentParams> = AnyPathParams extends TParentParams\n  ? {}\n  : {\n      [Key in keyof TParentParams]?: DefinedPathParamWarning\n    }\n\nexport type RouteLoadFn<\n  TAllParams = {},\n  TFullSearchSchema extends Record<string, any> = {},\n  TAllContext extends Record<string, any> = AnyContext,\n  TRouteContext extends Record<string, any> = AnyContext,\n> = (\n  match: LoadFnContext<\n    TAllParams,\n    TFullSearchSchema,\n    TAllContext,\n    TRouteContext\n  > & {\n    parentMatchPromise?: Promise<void>\n  },\n) => any\n\nexport interface LoadFnContext<\n  TAllParams = {},\n  TFullSearchSchema extends Record<string, any> = {},\n  TAllContext extends Record<string, any> = AnyContext,\n  TRouteContext extends Record<string, any> = AnyContext,\n> {\n  abortController: AbortController\n  preload: boolean\n  params: TAllParams\n  search: TFullSearchSchema\n  context: Expand<Assign<TAllContext, TRouteContext>>\n  location: ParsedLocation<TFullSearchSchema>\n  navigate: (opts: NavigateOptions<AnyRoute>) => Promise<void>\n}\n\nexport type SearchFilter<T, U = T> = (prev: T) => U\n\nexport type ResolveId<\n  TParentRoute,\n  TCustomId extends string,\n  TPath extends string,\n> = TParentRoute extends { id: infer TParentId extends string }\n  ? RoutePrefix<TParentId, string extends TCustomId ? TPath : TCustomId>\n  : RootRouteId\n\nexport type InferFullSearchSchema<TRoute> = TRoute extends {\n  types: {\n    fullSearchSchema: infer TFullSearchSchema\n  }\n}\n  ? TFullSearchSchema\n  : {}\n\nexport type ResolveFullSearchSchema<TParentRoute, TSearchSchema> = Expand<\n  Assign<InferFullSearchSchema<TParentRoute>, TSearchSchema>\n>\n\nexport interface AnyRoute\n  extends Route<\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any\n  > {}\n\nexport type MergeFromFromParent<T, U> = IsAny<T, U, T & U>\n\nexport type StreamedPromise<T> = {\n  promise: Promise<T>\n  status: 'resolved' | 'pending'\n  data: T\n  resolve: (value: T) => void\n}\n\nexport type ResolveAllParams<\n  TParentRoute extends AnyRoute,\n  TParams extends AnyPathParams,\n> = Record<never, string> extends TParentRoute['types']['allParams']\n  ? TParams\n  : Expand<\n      UnionToIntersection<TParentRoute['types']['allParams'] & TParams> & {}\n    >\n\nexport type RouteConstraints = {\n  TParentRoute: AnyRoute\n  TPath: string\n  TFullPath: string\n  TCustomId: string\n  TId: string\n  TSearchSchema: AnySearchSchema\n  TFullSearchSchema: AnySearchSchema\n  TParams: Record<string, any>\n  TAllParams: Record<string, any>\n  TParentContext: AnyContext\n  TRouteContext: RouteContext\n  TAllContext: AnyContext\n  TRouterContext: AnyContext\n  TChildren: unknown\n  TRouteTree: AnyRoute\n}\n\nexport class Route<\n  TParentRoute extends RouteConstraints['TParentRoute'] = AnyRoute,\n  TPath extends RouteConstraints['TPath'] = '/',\n  TFullPath extends RouteConstraints['TFullPath'] = ResolveFullPath<\n    TParentRoute,\n    TPath\n  >,\n  TCustomId extends RouteConstraints['TCustomId'] = string,\n  TId extends RouteConstraints['TId'] = ResolveId<\n    TParentRoute,\n    TCustomId,\n    TPath\n  >,\n  TSearchSchema extends RouteConstraints['TSearchSchema'] = {},\n  TFullSearchSchema extends RouteConstraints['TFullSearchSchema'] = ResolveFullSearchSchema<\n    TParentRoute,\n    TSearchSchema\n  >,\n  TParams extends RouteConstraints['TParams'] = Expand<\n    Record<ParsePathParams<TPath>, string>\n  >,\n  TAllParams extends RouteConstraints['TAllParams'] = ResolveAllParams<\n    TParentRoute,\n    TParams\n  >,\n  TRouteContext extends RouteConstraints['TRouteContext'] = RouteContext,\n  TAllContext extends Expand<\n    Assign<IsAny<TParentRoute['types']['allContext'], {}>, TRouteContext>\n  > = Expand<\n    Assign<IsAny<TParentRoute['types']['allContext'], {}>, TRouteContext>\n  >,\n  TRouterContext extends RouteConstraints['TRouterContext'] = AnyContext,\n  TChildren extends RouteConstraints['TChildren'] = unknown,\n  TRouteTree extends RouteConstraints['TRouteTree'] = AnyRoute,\n> {\n  isRoot: TParentRoute extends Route<any> ? true : false\n  options: RouteOptions<\n    TParentRoute,\n    TCustomId,\n    TPath,\n    TSearchSchema,\n    TFullSearchSchema,\n    TParams,\n    TAllParams,\n    TRouteContext,\n    TAllContext\n  >\n\n  test!: Expand<\n    Assign<IsAny<TParentRoute['types']['allContext'], {}>, TRouteContext>\n  >\n\n  // Set up in this.init()\n  parentRoute!: TParentRoute\n  id!: TId\n  // customId!: TCustomId\n  path!: TPath\n  fullPath!: TFullPath\n  to!: TrimPathRight<TFullPath>\n\n  // Optional\n  children?: TChildren\n  originalIndex?: number\n  router?: AnyRouter\n  rank!: number\n\n  constructor(\n    options: RouteOptions<\n      TParentRoute,\n      TCustomId,\n      TPath,\n      TSearchSchema,\n      TFullSearchSchema,\n      TParams,\n      TAllParams,\n      TRouteContext,\n      TAllContext\n    >,\n  ) {\n    this.options = (options as any) || {}\n    this.isRoot = !options?.getParentRoute as any\n    Route.__onInit(this)\n  }\n\n  types!: {\n    parentRoute: TParentRoute\n    path: TPath\n    to: TrimPathRight<TFullPath>\n    fullPath: TFullPath\n    customId: TCustomId\n    id: TId\n    searchSchema: TSearchSchema\n    fullSearchSchema: TFullSearchSchema\n    params: TParams\n    allParams: TAllParams\n    routeContext: TRouteContext\n    allContext: TAllContext\n    children: TChildren\n    routeTree: TRouteTree\n    routerContext: TRouterContext\n  }\n\n  init = (opts: { originalIndex: number }) => {\n    this.originalIndex = opts.originalIndex\n\n    const options = this.options as RouteOptions<\n      TParentRoute,\n      TCustomId,\n      TPath,\n      TSearchSchema,\n      TFullSearchSchema,\n      TParams,\n      TAllParams,\n      TRouteContext,\n      TAllContext\n    > &\n      RoutePathOptionsIntersection<TCustomId, TPath>\n\n    const isRoot = !options?.path && !options?.id\n\n    this.parentRoute = this.options?.getParentRoute?.()\n\n    if (isRoot) {\n      this.path = rootRouteId as TPath\n    } else {\n      invariant(\n        this.parentRoute,\n        `Child Route instances must pass a 'getParentRoute: () => ParentRoute' option that returns a Route instance.`,\n      )\n    }\n\n    let path: undefined | string = isRoot ? rootRouteId : options.path\n\n    // If the path is anything other than an index path, trim it up\n    if (path && path !== '/') {\n      path = trimPath(path)\n    }\n\n    const customId = options?.id || path\n\n    // Strip the parentId prefix from the first level of children\n    let id = isRoot\n      ? rootRouteId\n      : joinPaths([\n          (this.parentRoute.id as any) === rootRouteId\n            ? ''\n            : this.parentRoute.id,\n          customId,\n        ])\n\n    if (path === rootRouteId) {\n      path = '/'\n    }\n\n    if (id !== rootRouteId) {\n      id = joinPaths(['/', id])\n    }\n\n    const fullPath =\n      id === rootRouteId ? '/' : joinPaths([this.parentRoute.fullPath, path])\n\n    this.path = path as TPath\n    this.id = id as TId\n    // this.customId = customId as TCustomId\n    this.fullPath = fullPath as TFullPath\n    this.to = fullPath as TrimPathRight<TFullPath>\n  }\n\n  addChildren = <TNewChildren extends AnyRoute[]>(\n    children: TNewChildren,\n  ): Route<\n    TParentRoute,\n    TPath,\n    TFullPath,\n    TCustomId,\n    TId,\n    TSearchSchema,\n    TFullSearchSchema,\n    TParams,\n    TAllParams,\n    TRouteContext,\n    TAllContext,\n    TRouterContext,\n    TNewChildren,\n    TRouteTree\n  > => {\n    this.children = children as any\n    return this as any\n  }\n\n  update = (\n    options: UpdatableRouteOptions<\n      TFullSearchSchema,\n      TAllParams,\n      Expand<\n        Assign<IsAny<TParentRoute['types']['allContext'], {}>, TRouteContext>\n      >\n    >,\n  ) => {\n    Object.assign(this.options, options)\n    return this\n  }\n\n  static __onInit = (route: any) => {\n    // This is a dummy static method that should get\n    // replaced by a framework specific implementation if necessary\n  }\n\n  useMatch = <TSelected = TAllContext>(opts?: {\n    select?: (search: TAllContext) => TSelected\n  }): TSelected => {\n    return useMatch({ ...opts, from: this.id }) as any\n  }\n  useRouteContext = <TSelected = TAllContext>(opts?: {\n    select?: (search: TAllContext) => TSelected\n  }): TSelected => {\n    return useMatch({\n      ...opts,\n      from: this.id,\n      select: (d: any) => (opts?.select ? opts.select(d.context) : d.context),\n    } as any)\n  }\n  useSearch = <TSelected = TFullSearchSchema>(opts?: {\n    select?: (search: TFullSearchSchema) => TSelected\n  }): TSelected => {\n    return useSearch({ ...opts, from: this.id } as any)\n  }\n  useParams = <TSelected = TAllParams>(opts?: {\n    select?: (search: TAllParams) => TSelected\n  }): TSelected => {\n    return useParams({ ...opts, from: this.id } as any)\n  }\n}\n\nexport type AnyRootRoute = RootRoute<any, any, any>\n\nexport function rootRouteWithContext<TRouterContext extends {}>() {\n  return <\n    TSearchSchema extends Record<string, any> = {},\n    TRouteContext extends RouteContext = RouteContext,\n  >(\n    options?: Omit<\n      RouteOptions<\n        AnyRoute, // TParentRoute\n        RootRouteId, // TCustomId\n        '', // TPath\n        TSearchSchema, // TSearchSchema\n        TSearchSchema, // TFullSearchSchema\n        {}, // TParams\n        {}, // TAllParams\n        TRouteContext, // TRouteContext\n        Assign<TRouterContext, TRouteContext> // TAllContext\n      >,\n      | 'path'\n      | 'id'\n      | 'getParentRoute'\n      | 'caseSensitive'\n      | 'parseParams'\n      | 'stringifyParams'\n    >,\n  ): RootRoute<TSearchSchema, TRouteContext, TRouterContext> => {\n    return new RootRoute(options) as any\n  }\n}\n\nexport class RootRoute<\n  TSearchSchema extends Record<string, any> = {},\n  TRouteContext extends RouteContext = RouteContext,\n  TRouterContext extends {} = {},\n> extends Route<\n  any, // TParentRoute\n  '/', // TPath\n  '/', // TFullPath\n  string, // TCustomId\n  RootRouteId, // TId\n  TSearchSchema, // TSearchSchema\n  TSearchSchema, // TFullSearchSchema\n  {}, // TParams\n  {}, // TAllParams\n  TRouteContext, // TRouteContext\n  Expand<Assign<TRouterContext, TRouteContext>>, // TAllContext\n  TRouterContext, // TRouterContext\n  any, // TChildren\n  any // TRouteTree\n> {\n  constructor(\n    options?: Omit<\n      RouteOptions<\n        AnyRoute, // TParentRoute\n        RootRouteId, // TCustomId\n        '', // TPath\n        TSearchSchema, // TSearchSchema\n        TSearchSchema, // TFullSearchSchema\n        {}, // TParams\n        {}, // TAllParams\n        TRouteContext, // TRouteContext\n        Assign<TRouterContext, TRouteContext> // TAllContext\n      >,\n      | 'path'\n      | 'id'\n      | 'getParentRoute'\n      | 'caseSensitive'\n      | 'parseParams'\n      | 'stringifyParams'\n    >,\n  ) {\n    super(options as any)\n  }\n}\n\nexport type ResolveFullPath<\n  TParentRoute extends AnyRoute,\n  TPath extends string,\n  TPrefixed = RoutePrefix<TParentRoute['fullPath'], TPath>,\n> = TPrefixed extends RootRouteId ? '/' : TPrefixed\n\ntype RoutePrefix<\n  TPrefix extends string,\n  TPath extends string,\n> = string extends TPath\n  ? RootRouteId\n  : TPath extends string\n  ? TPrefix extends RootRouteId\n    ? TPath extends '/'\n      ? '/'\n      : `/${TrimPath<TPath>}`\n    : `${TPrefix}/${TPath}` extends '/'\n    ? '/'\n    : `/${TrimPathLeft<`${TrimPathRight<TPrefix>}/${TrimPath<TPath>}`>}`\n  : never\n\nexport type TrimPath<T extends string> = '' extends T\n  ? ''\n  : TrimPathRight<TrimPathLeft<T>>\n\nexport type TrimPathLeft<T extends string> =\n  T extends `${RootRouteId}/${infer U}`\n    ? TrimPathLeft<U>\n    : T extends `/${infer U}`\n    ? TrimPathLeft<U>\n    : T\nexport type TrimPathRight<T extends string> = T extends '/'\n  ? '/'\n  : T extends `${infer U}/`\n  ? TrimPathRight<U>\n  : T\n\nexport type RouteMask<TRouteTree extends AnyRoute> = {\n  routeTree: TRouteTree\n  from: RoutePaths<TRouteTree>\n  to?: any\n  params?: any\n  search?: any\n  hash?: any\n  state?: any\n  unmaskOnReload?: boolean\n}\n\nexport function createRouteMask<\n  TRouteTree extends AnyRoute,\n  TFrom extends RoutePaths<TRouteTree>,\n  TTo extends string,\n>(\n  opts: {\n    routeTree: TRouteTree\n  } & ToSubOptions<TRouteTree, TFrom, TTo>,\n): RouteMask<TRouteTree> {\n  return opts as any\n}\n\nexport type RouteProps<\n  TFullSearchSchema extends Record<string, any> = AnySearchSchema,\n  TAllParams extends AnyPathParams = AnyPathParams,\n  TAllContext extends Record<string, any> = AnyContext,\n> = {\n  useMatch: <TSelected = TAllContext>(opts?: {\n    select?: (search: TAllContext) => TSelected\n  }) => TSelected\n  useRouteContext: <TSelected = TAllContext>(opts?: {\n    select?: (search: TAllContext) => TSelected\n  }) => TSelected\n  useSearch: <TSelected = TFullSearchSchema>(opts?: {\n    select?: (search: TFullSearchSchema) => TSelected\n  }) => TSelected\n  useParams: <TSelected = TAllParams>(opts?: {\n    select?: (search: TAllParams) => TSelected\n  }) => TSelected\n}\n\nexport type ErrorRouteProps<\n  TFullSearchSchema extends Record<string, any> = AnySearchSchema,\n  TAllParams extends AnyPathParams = AnyPathParams,\n  TAllContext extends Record<string, any> = AnyContext,\n> = {\n  error: unknown\n  info: { componentStack: string }\n} & RouteProps<TFullSearchSchema, TAllParams, TAllContext>\n\nexport type PendingRouteProps<\n  TFullSearchSchema extends Record<string, any> = AnySearchSchema,\n  TAllParams extends AnyPathParams = AnyPathParams,\n  TAllContext extends Record<string, any> = AnyContext,\n> = RouteProps<TFullSearchSchema, TAllParams, TAllContext>\n//\n\nexport type ReactNode = any\n\nexport type SyncRouteComponent<TProps> =\n  | ((props: TProps) => ReactNode)\n  | React.LazyExoticComponent<(props: TProps) => ReactNode>\n\nexport type AsyncRouteComponent<TProps> = SyncRouteComponent<TProps> & {\n  preload?: () => Promise<void>\n}\n\nexport type RouteComponent<\n  TFullSearchSchema extends Record<string, any>,\n  TAllParams extends AnyPathParams,\n  TAllContext extends Record<string, any>,\n> = AsyncRouteComponent<RouteProps<TFullSearchSchema, TAllParams, TAllContext>>\n\nexport type ErrorRouteComponent<\n  TFullSearchSchema extends Record<string, any>,\n  TAllParams extends AnyPathParams,\n  TAllContext extends Record<string, any>,\n> = AsyncRouteComponent<\n  ErrorRouteProps<TFullSearchSchema, TAllParams, TAllContext>\n>\n\nexport type PendingRouteComponent<\n  TFullSearchSchema extends Record<string, any>,\n  TAllParams extends AnyPathParams,\n  TAllContext extends Record<string, any>,\n> = AsyncRouteComponent<\n  PendingRouteProps<TFullSearchSchema, TAllParams, TAllContext>\n>\n\nexport type AnyRouteComponent = RouteComponent<any, any, any>\n","import { ParsePathParams } from './link'\nimport {\n  AnyRoute,\n  ResolveFullPath,\n  ResolveFullSearchSchema,\n  MergeFromFromParent,\n  RouteContext,\n  AnyContext,\n  RouteOptions,\n  UpdatableRouteOptions,\n  Route,\n  AnyPathParams,\n  RootRouteId,\n  TrimPathLeft,\n  RouteConstraints,\n} from './route'\nimport { Assign, AssignAll, Expand, IsAny } from './utils'\n\nexport interface FileRoutesByPath {\n  // '/': {\n  //   parentRoute: typeof rootRoute\n  // }\n}\n\ntype Replace<\n  S extends string,\n  From extends string,\n  To extends string,\n> = S extends `${infer Start}${From}${infer Rest}`\n  ? `${Start}${To}${Replace<Rest, From, To>}`\n  : S\n\nexport type TrimLeft<\n  T extends string,\n  S extends string,\n> = T extends `${S}${infer U}` ? U : T\n\nexport type TrimRight<\n  T extends string,\n  S extends string,\n> = T extends `${infer U}${S}` ? U : T\n\nexport type Trim<T extends string, S extends string> = TrimLeft<\n  TrimRight<T, S>,\n  S\n>\n\nexport type RemoveUnderScores<T extends string> = Replace<\n  Replace<TrimRight<TrimLeft<T, '/_'>, '_'>, '_/', '/'>,\n  '/_',\n  '/'\n>\n\nexport type ResolveFilePath<\n  TParentRoute extends AnyRoute,\n  TFilePath extends string,\n> = TParentRoute['id'] extends RootRouteId\n  ? TrimPathLeft<TFilePath>\n  : Replace<\n      TrimPathLeft<TFilePath>,\n      TrimPathLeft<TParentRoute['types']['customId']>,\n      ''\n    >\n\nexport type FileRoutePath<\n  TParentRoute extends AnyRoute,\n  TFilePath extends string,\n> = ResolveFilePath<TParentRoute, TFilePath> extends `_${infer _}`\n  ? string\n  : ResolveFilePath<TParentRoute, TFilePath>\n\nexport class FileRoute<\n  TFilePath extends keyof FileRoutesByPath,\n  TParentRoute extends AnyRoute = FileRoutesByPath[TFilePath]['parentRoute'],\n  TId extends RouteConstraints['TId'] = TFilePath,\n  TPath extends RouteConstraints['TPath'] = FileRoutePath<\n    TParentRoute,\n    TFilePath\n  >,\n  TFullPath extends RouteConstraints['TFullPath'] = ResolveFullPath<\n    TParentRoute,\n    RemoveUnderScores<TPath>\n  >,\n> {\n  constructor(public path: TFilePath) {}\n\n  createRoute = <\n    TSearchSchema extends RouteConstraints['TSearchSchema'] = {},\n    TFullSearchSchema extends RouteConstraints['TFullSearchSchema'] = ResolveFullSearchSchema<\n      TParentRoute,\n      TSearchSchema\n    >,\n    TParams extends RouteConstraints['TParams'] = ParsePathParams<TPath> extends never\n      ? AnyPathParams\n      : Record<ParsePathParams<TPath>, RouteConstraints['TPath']>,\n    TAllParams extends RouteConstraints['TAllParams'] = MergeFromFromParent<\n      TParentRoute['types']['allParams'],\n      TParams\n    >,\n    TRouteContext extends RouteConstraints['TRouteContext'] = RouteContext,\n    TContext extends Expand<\n      Assign<IsAny<TParentRoute['types']['allContext'], {}>, TRouteContext>\n    > = Expand<\n      Assign<IsAny<TParentRoute['types']['allContext'], {}>, TRouteContext>\n    >,\n    TRouterContext extends RouteConstraints['TRouterContext'] = AnyContext,\n    TChildren extends RouteConstraints['TChildren'] = unknown,\n    TRouteTree extends RouteConstraints['TRouteTree'] = AnyRoute,\n  >(\n    options: Omit<\n      RouteOptions<\n        TParentRoute,\n        string,\n        string,\n        TSearchSchema,\n        TFullSearchSchema,\n        TParams,\n        TAllParams,\n        TRouteContext,\n        TContext\n      >,\n      'getParentRoute' | 'path' | 'id'\n    > &\n      UpdatableRouteOptions<TFullSearchSchema, TAllParams, TContext>,\n  ): Route<\n    TParentRoute,\n    TPath,\n    TFullPath,\n    TFilePath,\n    TId,\n    TSearchSchema,\n    TFullSearchSchema,\n    TParams,\n    TAllParams,\n    TRouteContext,\n    TContext,\n    TRouterContext,\n    TChildren,\n    TRouteTree\n  > => {\n    const route = new Route(options as any)\n    ;(route as any).isRoot = false\n    return route as any\n  }\n}\n","import * as React from 'react'\nimport { AsyncRouteComponent } from './route'\n\nexport function lazyRouteComponent<\n  T extends Record<string, any>,\n  TKey extends keyof T = 'default',\n>(\n  importer: () => Promise<T>,\n  exportName?: TKey,\n): T[TKey] extends (props: infer TProps) => any\n  ? AsyncRouteComponent<TProps>\n  : never {\n  let loadPromise: Promise<any>\n\n  const load = () => {\n    if (!loadPromise) {\n      loadPromise = importer()\n    }\n\n    return loadPromise\n  }\n\n  const lazyComp = React.lazy(async () => {\n    const moduleExports = await load()\n    const comp = moduleExports[exportName ?? 'default']\n    return {\n      default: comp,\n    }\n  })\n  ;(lazyComp as any).preload = load\n\n  return lazyComp as any\n}\n","import * as React from 'react'\nimport { useMatch } from './Matches'\nimport { useRouter } from './RouterProvider'\nimport { Trim } from './fileRoute'\nimport { LocationState, ParsedLocation } from './location'\nimport { AnyRoute, ReactNode } from './route'\nimport {\n  AllParams,\n  FullSearchSchema,\n  RouteByPath,\n  RouteIds,\n  RoutePaths,\n} from './routeInfo'\nimport { RegisteredRouter } from './router'\nimport { MakeLinkOptions, MakeLinkPropsOptions } from './useNavigate'\nimport {\n  Expand,\n  NoInfer,\n  NonNullableUpdater,\n  PickRequired,\n  UnionToIntersection,\n  Updater,\n  functionalUpdate,\n} from './utils'\n\nexport type LinkInfo =\n  | {\n      type: 'external'\n      href: string\n    }\n  | {\n      type: 'internal'\n      next: ParsedLocation\n      handleFocus: (e: any) => void\n      handleClick: (e: any) => void\n      handleEnter: (e: any) => void\n      handleLeave: (e: any) => void\n      handleTouchStart: (e: any) => void\n      isActive: boolean\n      disabled?: boolean\n    }\n\nexport type CleanPath<T extends string> = T extends `${infer L}//${infer R}`\n  ? CleanPath<`${CleanPath<L>}/${CleanPath<R>}`>\n  : T extends `${infer L}//`\n  ? `${CleanPath<L>}/`\n  : T extends `//${infer L}`\n  ? `/${CleanPath<L>}`\n  : T\n\nexport type Split<S, TIncludeTrailingSlash = true> = S extends unknown\n  ? string extends S\n    ? string[]\n    : S extends string\n    ? CleanPath<S> extends ''\n      ? []\n      : TIncludeTrailingSlash extends true\n      ? CleanPath<S> extends `${infer T}/`\n        ? [...Split<T>, '/']\n        : CleanPath<S> extends `/${infer U}`\n        ? Split<U>\n        : CleanPath<S> extends `${infer T}/${infer U}`\n        ? [...Split<T>, ...Split<U>]\n        : [S]\n      : CleanPath<S> extends `${infer T}/${infer U}`\n      ? [...Split<T>, ...Split<U>]\n      : S extends string\n      ? [S]\n      : never\n    : never\n  : never\n\nexport type ParsePathParams<T extends string> = keyof {\n  [K in Trim<Split<T>[number], '_'> as K extends `$${infer L}` ? L : never]: K\n}\n\nexport type Join<T, Delimiter extends string = '/'> = T extends []\n  ? ''\n  : T extends [infer L extends string]\n  ? L\n  : T extends [infer L extends string, ...infer Tail extends [...string[]]]\n  ? CleanPath<`${L}${Delimiter}${Join<Tail>}`>\n  : never\n\nexport type Last<T extends any[]> = T extends [...infer _, infer L] ? L : never\n\nexport type RelativeToPathAutoComplete<\n  AllPaths extends string,\n  TFrom extends string,\n  TTo extends string,\n  SplitPaths extends string[] = Split<AllPaths, false>,\n> = TTo extends `..${infer _}`\n  ? SplitPaths extends [\n      ...Split<ResolveRelativePath<TFrom, TTo>, false>,\n      ...infer TToRest,\n    ]\n    ? `${CleanPath<\n        Join<\n          [\n            ...Split<TTo, false>,\n            ...(\n              | TToRest\n              | (Split<\n                  ResolveRelativePath<TFrom, TTo>,\n                  false\n                >['length'] extends 1\n                  ? never\n                  : ['../'])\n            ),\n          ]\n        >\n      >}`\n    : never\n  : TTo extends `./${infer RestTTo}`\n  ? SplitPaths extends [\n      ...Split<TFrom, false>,\n      ...Split<RestTTo, false>,\n      ...infer RestPath,\n    ]\n    ? `${TTo}${Join<RestPath>}`\n    : never\n  :\n      | (TFrom extends `/`\n          ? never\n          : SplitPaths extends [...Split<TFrom, false>, ...infer RestPath]\n          ? Join<RestPath> extends { length: 0 }\n            ? never\n            : './'\n          : never)\n      | (TFrom extends `/` ? never : '../')\n      | AllPaths\n\nexport type NavigateOptions<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = TFrom,\n  TMaskTo extends string = '',\n> = ToOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> & {\n  // `replace` is a boolean that determines whether the navigation should replace the current history entry or push a new one.\n  replace?: boolean\n  resetScroll?: boolean\n  // If set to `true`, the link's underlying navigate() call will be wrapped in a `React.startTransition` call. Defaults to `true`.\n  startTransition?: boolean\n}\n\nexport type ToOptions<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = '/',\n  TMaskTo extends string = '',\n> = ToSubOptions<TRouteTree, TFrom, TTo> & {\n  mask?: ToMaskOptions<TRouteTree, TMaskFrom, TMaskTo>\n}\n\nexport type ToMaskOptions<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TMaskFrom extends RoutePaths<TRouteTree> = '/',\n  TMaskTo extends string = '',\n> = ToSubOptions<TRouteTree, TMaskFrom, TMaskTo> & {\n  unmaskOnReload?: boolean\n}\n\nexport type ToSubOptions<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TResolved = ResolveRelativePath<TFrom, NoInfer<TTo>>,\n> = {\n  to?: ToPathOption<TRouteTree, TFrom, TTo>\n  // The new has string or a function to update it\n  hash?: true | Updater<string>\n  // State to pass to the history stack\n  state?: true | NonNullableUpdater<LocationState>\n  // The source route path. This is automatically set when using route-level APIs, but for type-safe relative routing on the router itself, this is required\n  from?: TFrom\n  // // When using relative route paths, this option forces resolution from the current path, instead of the route API's path or `from` path\n  // fromCurrent?: boolean\n} & CheckPath<TRouteTree, NoInfer<TResolved>, {}> &\n  SearchParamOptions<TRouteTree, TFrom, TTo, TResolved> &\n  PathParamOptions<TRouteTree, TFrom, TResolved>\n\nexport type SearchParamOptions<\n  TRouteTree extends AnyRoute,\n  TFrom,\n  TTo,\n  TResolved = ResolveRelativePath<TFrom, NoInfer<TTo>>,\n  TFromSearchEnsured = '/' extends TFrom\n    ? FullSearchSchema<TRouteTree>\n    : Expand<\n        UnionToIntersection<\n          PickRequired<\n            RouteByPath<TRouteTree, TFrom>['types']['fullSearchSchema']\n          >\n        >\n      >,\n  TFromSearchOptional = Omit<AllParams<TRouteTree>, keyof TFromSearchEnsured>,\n  TFromSearch = Expand<TFromSearchEnsured & TFromSearchOptional>,\n  TToSearch = '' extends TTo\n    ? FullSearchSchema<TRouteTree>\n    : Expand<RouteByPath<TRouteTree, TResolved>['types']['fullSearchSchema']>,\n> = keyof PickRequired<TToSearch> extends never\n  ? {\n      search?: true | SearchReducer<TFromSearch, TToSearch>\n    }\n  : {\n      search: TFromSearchEnsured extends PickRequired<TToSearch>\n        ? true | SearchReducer<TFromSearch, TToSearch>\n        : SearchReducer<TFromSearch, TToSearch>\n    }\n\ntype SearchReducer<TFrom, TTo> = TTo | ((current: TFrom) => TTo)\n\nexport type PathParamOptions<\n  TRouteTree extends AnyRoute,\n  TFrom,\n  TTo,\n  TFromParamsEnsured = Expand<\n    UnionToIntersection<\n      PickRequired<RouteByPath<TRouteTree, TFrom>['types']['allParams']>\n    >\n  >,\n  TFromParamsOptional = Omit<AllParams<TRouteTree>, keyof TFromParamsEnsured>,\n  TFromParams = Expand<TFromParamsOptional & TFromParamsEnsured>,\n  TToParams = Expand<RouteByPath<TRouteTree, TTo>['types']['allParams']>,\n> = keyof PickRequired<TToParams> extends never\n  ? {\n      params?: true | ParamsReducer<TFromParams, TToParams>\n    }\n  : {\n      params: TFromParamsEnsured extends PickRequired<TToParams>\n        ? true | ParamsReducer<TFromParams, TToParams>\n        : ParamsReducer<TFromParams, TToParams>\n    }\n\ntype ParamsReducer<TFrom, TTo> = TTo | ((current: TFrom) => TTo)\n\nexport type ToPathOption<\n  TRouteTree extends AnyRoute = AnyRoute,\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n> =\n  | TTo\n  | RelativeToPathAutoComplete<\n      RoutePaths<TRouteTree>,\n      NoInfer<TFrom> extends string ? NoInfer<TFrom> : '',\n      NoInfer<TTo> & string\n    >\n\nexport type ToIdOption<\n  TRouteTree extends AnyRoute = AnyRoute,\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n> =\n  | TTo\n  | RelativeToPathAutoComplete<\n      RouteIds<TRouteTree>,\n      NoInfer<TFrom> extends string ? NoInfer<TFrom> : '',\n      NoInfer<TTo> & string\n    >\n\nexport interface ActiveOptions {\n  exact?: boolean\n  includeHash?: boolean\n  includeSearch?: boolean\n}\n\nexport type LinkOptions<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = TFrom,\n  TMaskTo extends string = '',\n> = NavigateOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> & {\n  // The standard anchor tag target attribute\n  target?: HTMLAnchorElement['target']\n  // Defaults to `{ exact: false, includeHash: false }`\n  activeOptions?: ActiveOptions\n  // If set, will preload the linked route on hover and cache it for this many milliseconds in hopes that the user will eventually navigate there.\n  preload?: false | 'intent'\n  // Delay intent preloading by this many milliseconds. If the intent exits before this delay, the preload will be cancelled.\n  preloadDelay?: number\n  // If true, will render the link without the href attribute\n  disabled?: boolean\n}\n\nexport type CheckRelativePath<\n  TRouteTree extends AnyRoute,\n  TFrom,\n  TTo,\n> = TTo extends string\n  ? TFrom extends string\n    ? ResolveRelativePath<TFrom, TTo> extends RoutePaths<TRouteTree>\n      ? {}\n      : {\n          Error: `${TFrom} + ${TTo} resolves to ${ResolveRelativePath<\n            TFrom,\n            TTo\n          >}, which is not a valid route path.`\n          'Valid Route Paths': RoutePaths<TRouteTree>\n        }\n    : {}\n  : {}\n\nexport type CheckPath<TRouteTree extends AnyRoute, TPath, TPass> = Exclude<\n  TPath,\n  RoutePaths<TRouteTree>\n> extends never\n  ? TPass\n  : CheckPathError<TRouteTree, Exclude<TPath, RoutePaths<TRouteTree>>>\n\nexport type CheckPathError<TRouteTree extends AnyRoute, TInvalids> = {\n  to: RoutePaths<TRouteTree>\n}\n\nexport type CheckId<TRouteTree extends AnyRoute, TPath, TPass> = Exclude<\n  TPath,\n  RouteIds<TRouteTree>\n> extends never\n  ? TPass\n  : CheckIdError<TRouteTree, Exclude<TPath, RouteIds<TRouteTree>>>\n\nexport type CheckIdError<TRouteTree extends AnyRoute, TInvalids> = {\n  Error: `${TInvalids extends string\n    ? TInvalids\n    : never} is not a valid route ID.`\n  'Valid Route IDs': RouteIds<TRouteTree>\n}\n\nexport type ResolveRelativePath<TFrom, TTo = '.'> = TFrom extends string\n  ? TTo extends string\n    ? TTo extends '.'\n      ? TFrom\n      : TTo extends `./`\n      ? Join<[TFrom, '/']>\n      : TTo extends `./${infer TRest}`\n      ? ResolveRelativePath<TFrom, TRest>\n      : TTo extends `/${infer TRest}`\n      ? TTo\n      : Split<TTo> extends ['..', ...infer ToRest]\n      ? Split<TFrom> extends [...infer FromRest, infer FromTail]\n        ? ToRest extends ['/']\n          ? Join<[...FromRest, '/']>\n          : ResolveRelativePath<Join<FromRest>, Join<ToRest>>\n        : never\n      : Split<TTo> extends ['.', ...infer ToRest]\n      ? ToRest extends ['/']\n        ? Join<[TFrom, '/']>\n        : ResolveRelativePath<TFrom, Join<ToRest>>\n      : CleanPath<Join<['/', ...Split<TFrom>, ...Split<TTo>]>>\n    : never\n  : never\n\nexport function useLinkProps<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = '/',\n  TMaskTo extends string = '',\n>(\n  options: MakeLinkPropsOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>,\n): React.AnchorHTMLAttributes<HTMLAnchorElement> {\n  const { buildLink } = useRouter()\n  const match = useMatch({\n    strict: false,\n  })\n\n  const {\n    // custom props\n    type,\n    children,\n    target,\n    activeProps = () => ({ className: 'active' }),\n    inactiveProps = () => ({}),\n    activeOptions,\n    disabled,\n    hash,\n    search,\n    params,\n    to,\n    state,\n    mask,\n    preload,\n    preloadDelay,\n    replace,\n    startTransition,\n    resetScroll,\n    // element props\n    style,\n    className,\n    onClick,\n    onFocus,\n    onMouseEnter,\n    onMouseLeave,\n    onTouchStart,\n    ...rest\n  } = options\n\n  const linkInfo = buildLink({\n    from: options.to ? match.pathname : undefined,\n    ...options,\n  } as any)\n\n  if (linkInfo.type === 'external') {\n    const { href } = linkInfo\n    return { href }\n  }\n\n  const {\n    handleClick,\n    handleFocus,\n    handleEnter,\n    handleLeave,\n    handleTouchStart,\n    isActive,\n    next,\n  } = linkInfo\n\n  const composeHandlers =\n    (handlers: (undefined | ((e: any) => void))[]) =>\n    (e: React.SyntheticEvent) => {\n      if (e.persist) e.persist()\n      handlers.filter(Boolean).forEach((handler) => {\n        if (e.defaultPrevented) return\n        handler!(e)\n      })\n    }\n\n  // Get the active props\n  const resolvedActiveProps: React.HTMLAttributes<HTMLAnchorElement> = isActive\n    ? functionalUpdate(activeProps as any, {}) ?? {}\n    : {}\n\n  // Get the inactive props\n  const resolvedInactiveProps: React.HTMLAttributes<HTMLAnchorElement> =\n    isActive ? {} : functionalUpdate(inactiveProps, {}) ?? {}\n\n  return {\n    ...resolvedActiveProps,\n    ...resolvedInactiveProps,\n    ...rest,\n    href: disabled\n      ? undefined\n      : next.maskedLocation\n      ? next.maskedLocation.href\n      : next.href,\n    onClick: composeHandlers([onClick, handleClick]),\n    onFocus: composeHandlers([onFocus, handleFocus]),\n    onMouseEnter: composeHandlers([onMouseEnter, handleEnter]),\n    onMouseLeave: composeHandlers([onMouseLeave, handleLeave]),\n    onTouchStart: composeHandlers([onTouchStart, handleTouchStart]),\n    target,\n    style: {\n      ...style,\n      ...resolvedActiveProps.style,\n      ...resolvedInactiveProps.style,\n    },\n    className:\n      [\n        className,\n        resolvedActiveProps.className,\n        resolvedInactiveProps.className,\n      ]\n        .filter(Boolean)\n        .join(' ') || undefined,\n    ...(disabled\n      ? {\n          role: 'link',\n          'aria-disabled': true,\n        }\n      : undefined),\n    ['data-status']: isActive ? 'active' : undefined,\n  }\n}\n\nexport interface LinkComponent<TProps extends Record<string, any> = {}> {\n  <\n    TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n    TFrom extends RoutePaths<TRouteTree> = '/',\n    TTo extends string = '',\n    TMaskFrom extends RoutePaths<TRouteTree> = '/',\n    TMaskTo extends string = '',\n  >(\n    props: MakeLinkOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> &\n      TProps &\n      React.RefAttributes<HTMLAnchorElement>,\n  ): ReactNode\n}\n\nexport const Link: LinkComponent = React.forwardRef((props: any, ref) => {\n  const linkProps = useLinkProps(props)\n\n  return (\n    <a\n      {...{\n        ref: ref as any,\n        ...linkProps,\n        children:\n          typeof props.children === 'function'\n            ? props.children({\n                isActive: (linkProps as any)['data-status'] === 'active',\n              })\n            : props.children,\n      }}\n    />\n  )\n}) as any\n","import * as React from 'react'\n\nconst useLayoutEffect =\n  typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect\n\nimport { ParsedLocation } from './location'\nimport { useRouter } from './RouterProvider'\nimport { NonNullableUpdater, functionalUpdate } from './utils'\n\nconst windowKey = 'window'\nconst delimiter = '___'\n\nlet weakScrolledElements = new WeakSet<any>()\n\ntype CacheValue = Record<string, { scrollX: number; scrollY: number }>\ntype CacheState = {\n  cached: CacheValue\n  next: CacheValue\n}\n\ntype Cache = {\n  state: CacheState\n  set: (updater: NonNullableUpdater<CacheState>) => void\n}\n\nlet cache: Cache\n\nconst sessionsStorage = typeof window !== 'undefined' && window.sessionStorage\n\nexport type ScrollRestorationOptions = {\n  getKey?: (location: ParsedLocation) => string\n}\n\nconst defaultGetKey = (location: ParsedLocation) => location.state.key!\n\nexport function useScrollRestoration(options?: ScrollRestorationOptions) {\n  const { state, subscribe, resetNextScrollRef } = useRouter()\n\n  useLayoutEffect(() => {\n    const getKey = options?.getKey || defaultGetKey\n\n    if (sessionsStorage) {\n      if (!cache) {\n        cache = (() => {\n          const storageKey = 'tsr-scroll-restoration-v2'\n\n          const state: CacheState = JSON.parse(\n            window.sessionStorage.getItem(storageKey) || 'null',\n          ) || { cached: {}, next: {} }\n\n          return {\n            state,\n            set: (updater) => {\n              cache.state = functionalUpdate(updater, cache.state)\n              window.sessionStorage.setItem(\n                storageKey,\n                JSON.stringify(cache.state),\n              )\n            },\n          }\n        })()\n      }\n    }\n\n    const { history } = window\n    if (history.scrollRestoration) {\n      history.scrollRestoration = 'manual'\n    }\n\n    const onScroll = (event: Event) => {\n      if (weakScrolledElements.has(event.target)) return\n      weakScrolledElements.add(event.target)\n\n      const elementSelector =\n        event.target === document || event.target === window\n          ? windowKey\n          : getCssSelector(event.target)\n\n      if (!cache.state.next[elementSelector]) {\n        cache.set((c) => ({\n          ...c,\n          next: {\n            ...c.next,\n            [elementSelector]: {\n              scrollX: NaN,\n              scrollY: NaN,\n            },\n          },\n        }))\n      }\n    }\n\n    const getCssSelector = (el: any): string => {\n      let path = [],\n        parent\n      while ((parent = el.parentNode)) {\n        path.unshift(\n          `${el.tagName}:nth-child(${\n            ([].indexOf as any).call(parent.children, el) + 1\n          })`,\n        )\n        el = parent\n      }\n      return `${path.join(' > ')}`.toLowerCase()\n    }\n\n    if (typeof document !== 'undefined') {\n      document.addEventListener('scroll', onScroll, true)\n    }\n\n    const unsubOnBeforeLoad = subscribe('onBeforeLoad', (event) => {\n      if (event.pathChanged) {\n        const restoreKey = getKey(event.fromLocation)\n        for (const elementSelector in cache.state.next) {\n          const entry = cache.state.next[elementSelector]!\n          if (elementSelector === windowKey) {\n            entry.scrollX = window.scrollX || 0\n            entry.scrollY = window.scrollY || 0\n          } else if (elementSelector) {\n            const element = document.querySelector(elementSelector)\n            entry.scrollX = element?.scrollLeft || 0\n            entry.scrollY = element?.scrollTop || 0\n          }\n\n          cache.set((c) => {\n            const next = { ...c.next }\n            delete next[elementSelector]\n\n            return {\n              ...c,\n              next,\n              cached: {\n                ...c.cached,\n                [[restoreKey, elementSelector].join(delimiter)]: entry,\n              },\n            }\n          })\n        }\n      }\n    })\n\n    const unsubOnResolved = subscribe('onResolved', (event) => {\n      if (event.pathChanged) {\n        if (!resetNextScrollRef.current) {\n          return\n        }\n\n        resetNextScrollRef.current = true\n\n        const getKey = options?.getKey || defaultGetKey\n\n        const restoreKey = getKey(event.toLocation)\n        let windowRestored = false\n\n        for (const cacheKey in cache.state.cached) {\n          const entry = cache.state.cached[cacheKey]!\n          const [key, elementSelector] = cacheKey.split(delimiter)\n          if (key === restoreKey) {\n            if (elementSelector === windowKey) {\n              windowRestored = true\n              window.scrollTo(entry.scrollX, entry.scrollY)\n            } else if (elementSelector) {\n              const element = document.querySelector(elementSelector)\n              if (element) {\n                element.scrollLeft = entry.scrollX\n                element.scrollTop = entry.scrollY\n              }\n            }\n          }\n        }\n\n        if (!windowRestored) {\n          window.scrollTo(0, 0)\n        }\n\n        cache.set((c) => ({ ...c, next: {} }))\n        weakScrolledElements = new WeakSet<any>()\n      }\n    })\n\n    return () => {\n      document.removeEventListener('scroll', onScroll)\n      unsubOnBeforeLoad()\n      unsubOnResolved()\n    }\n  }, [])\n}\n\nexport function ScrollRestoration(props: ScrollRestorationOptions) {\n  useScrollRestoration(props)\n  return null\n}\n","import * as React from 'react'\nimport { ReactNode } from './route'\nimport { useRouter } from './RouterProvider'\n\nexport function useBlocker(\n  message: string,\n  condition: boolean | any = true,\n): void {\n  const { history } = useRouter()\n\n  React.useEffect(() => {\n    if (!condition) return\n\n    let unblock = history.block((retry, cancel) => {\n      if (window.confirm(message)) {\n        unblock()\n        retry()\n      }\n    })\n\n    return unblock\n  })\n}\n\nexport function Block({ message, condition, children }: PromptProps) {\n  useBlocker(message, condition)\n  return (children ?? null) as ReactNode\n}\n\nexport type PromptProps = {\n  message: string\n  condition?: boolean | any\n  children?: ReactNode\n}\n","import * as React from 'react'\nimport { useMatch } from './Matches'\nimport { useRouter } from './RouterProvider'\nimport { LinkOptions, NavigateOptions } from './link'\nimport { AnyRoute } from './route'\nimport { RoutePaths } from './routeInfo'\nimport { RegisteredRouter } from './router'\nimport { useLayoutEffect } from './utils'\n\nexport function useNavigate<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TDefaultFrom extends RoutePaths<TRouteTree> = '/',\n>(defaultOpts?: { from?: TDefaultFrom }) {\n  const { navigate } = useRouter()\n  const match = useMatch({\n    strict: false,\n  })\n  return React.useCallback(\n    <\n      TFrom extends RoutePaths<TRouteTree> = TDefaultFrom,\n      TTo extends string = '',\n      TMaskFrom extends RoutePaths<TRouteTree> = '/',\n      TMaskTo extends string = '',\n    >(\n      opts?: NavigateOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>,\n    ) => {\n      return navigate({\n        from: opts?.to ? match.pathname : undefined,\n        ...defaultOpts,\n        ...(opts as any),\n      })\n    },\n    [],\n  )\n}\n\nexport function typedNavigate<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TDefaultFrom extends RoutePaths<TRouteTree> = '/',\n>(navigate: (opts: NavigateOptions<any>) => Promise<void>) {\n  return navigate as <\n    TFrom extends RoutePaths<TRouteTree> = TDefaultFrom,\n    TTo extends string = '',\n    TMaskFrom extends RoutePaths<TRouteTree> = '/',\n    TMaskTo extends string = '',\n  >(\n    opts?: NavigateOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>,\n  ) => Promise<void>\n} //\n\nexport function Navigate<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = '/',\n  TMaskTo extends string = '',\n>(props: NavigateOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>): null {\n  const { navigate } = useRouter()\n  const match = useMatch({ strict: false })\n\n  useLayoutEffect(() => {\n    navigate({\n      from: props.to ? match.pathname : undefined,\n      ...props,\n    } as any)\n  }, [])\n\n  return null\n}\n\nexport type MakeLinkPropsOptions<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = '/',\n  TMaskTo extends string = '',\n> = LinkPropsOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> &\n  React.AnchorHTMLAttributes<HTMLAnchorElement>\n\nexport type MakeLinkOptions<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = '/',\n  TMaskTo extends string = '',\n> = LinkPropsOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> &\n  Omit<React.AnchorHTMLAttributes<HTMLAnchorElement>, 'children'> & {\n    // If a function is passed as a child, it will be given the `isActive` boolean to aid in further styling on the element it returns\n    children?:\n      | React.ReactNode\n      | ((state: { isActive: boolean }) => React.ReactNode)\n  }\n\nexport type LinkPropsOptions<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = '/',\n  TMaskTo extends string = '',\n> = LinkOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> & {\n  // A function that returns additional props for the `active` state of this link. These props override other props passed to the link (`style`'s are merged, `className`'s are concatenated)\n  activeProps?:\n    | React.AnchorHTMLAttributes<HTMLAnchorElement>\n    | (() => React.AnchorHTMLAttributes<HTMLAnchorElement>)\n  // A function that returns additional props for the `inactive` state of this link. These props override other props passed to the link (`style`'s are merged, `className`'s are concatenated)\n  inactiveProps?:\n    | React.AnchorHTMLAttributes<HTMLAnchorElement>\n    | (() => React.AnchorHTMLAttributes<HTMLAnchorElement>)\n}\n"],"names":["CatchBoundary","props","errorComponent","ErrorComponent","React","createElement","CatchBoundaryImpl","resetKey","onCatch","children","error","Component","state","getDerivedStateFromError","componentDidUpdate","prevProps","prevState","setState","componentDidCatch","console","render","show","setShow","useState","process","style","padding","maxWidth","display","alignItems","gap","fontSize","appearance","border","fontWeight","borderRadius","onClick","d","height","color","overflow","message","isServer","document","last","arr","length","isFunction","functionalUpdate","updater","previous","pick","parent","keys","reduce","obj","key","replaceEqualDeep","prev","_next","next","array","Array","isArray","isPlainObject","prevSize","Object","nextItems","nextSize","copy","equalItems","i","o","hasObjectPrototype","ctor","constructor","prot","prototype","hasOwnProperty","toString","call","partialDeepEqual","a","b","some","item","index","useStableCallback","fn","fnRef","useRef","current","ref","args","shallow","objA","objB","is","keysA","useRouteContext","opts","useMatch","select","match","context","useLayoutEffect","window","useEffect","joinPaths","paths","cleanPath","filter","Boolean","join","path","replace","trimPathLeft","trimPathRight","trimPath","resolvePath","basepath","base","to","RegExp","baseSegments","parsePathname","toSegments","forEach","toSegment","value","push","pop","joined","map","pathname","segments","slice","substring","type","split","part","charAt","interpolatePath","params","leaveWildcards","interpolatedPathSegments","segment","matchPathname","currentPathname","matchLocation","pathParams","matchByPath","from","routeSegments","startsWith","unshift","isMatch","Math","max","baseSegment","routeSegment","isLastBaseSegment","isLastRouteSegment","caseSensitive","toLowerCase","fuzzy","undefined","redirect","isRedirect","encode","pfx","k","tmp","str","encodeURIComponent","toValue","mix","decodeURIComponent","decode","out","shift","concat","defaultParseSearch","parseSearchWith","JSON","parse","defaultStringifySearch","stringifySearchWith","stringify","parser","searchStr","query","err","stringifyValue","val","search","componentTypes","Router","options","defaultPreloadDelay","stringifySearch","parseSearch","routeTree","subscribers","Set","subscribe","eventType","listener","add","delete","emit","routerEvent","lazyFn","imported","routerContext","createContext","__TSR_ROUTER_CONTEXT__","preloadWarning","isCtrlEvent","e","metaKey","altKey","ctrlKey","shiftKey","SearchParamError","Error","PathParamError","getInitialRouterState","location","status","resolvedLocation","matches","pendingMatches","lastUpdated","Date","now","RouterProvider","router","rest","history","createBrowserHistory","tempLocationKeyRef","round","random","resetNextScrollRef","navigateTimeoutRef","latestLoadPromiseRef","Promise","resolve","checkLatest","promise","parseLocation","previousLocation","hash","parsedSearch","reverse","href","__tempLocation","__tempKey","parsedTempLocation","maskedLocation","latestLocationRef","preState","isTransitioning","startReactTransition","useTransition","useMemo","fromLocation","toLocation","pathChanged","s","resolvePathWithBase","routesById","routesByPath","recurseRoutes","routes","route","init","originalIndex","existingRoute","id","invariant","String","isRoot","trimmedFullPath","fullPath","endsWith","looseRoutesById","flatRoutes","values","trimmed","parsed","score","child","sort","isIndex","min","rank","matchRoutes","locationSearch","routeParams","foundRoute","find","matchedParams","routeCursor","matchedRoutes","parentRoute","parseErrors","parsedParamsError","parseParams","parsedParams","assign","cause","throwOnError","interpolatedPath","matchId","existingMatch","getRouteMatch","hasLoaders","load","preload","routeMatch","routeId","updatedAt","routeSearch","isFetching","invalid","paramsError","searchError","loadPromise","abortController","AbortController","fetchedAt","parentMatch","searchInfo","parentSearchInfo","validator","validateSearch","searchDidChange","cancelMatch","abort","cancelMatches","buildLocation","build","dest","fromPathname","fromMatches","stayingMatches","prevParams","nextParams","stringifyParams","preSearchFilters","flat","postSearchFilters","preFilteredSearch","destSearch","postFilteredSearch","hashStr","nextState","createHref","unmaskOnReload","buildWithMatches","maskedDest","maskedNext","foundMask","routeMasks","nextMatches","maskedMatches","maskedFinal","final","mask","commitLocation","startTransition","clearTimeout","isSameUrl","nextHistory","apply","resetScroll","buildAndCommitLocation","navigate","fromString","isExternal","URL","loadMatches","latestPromise","firstBadMatchIndex","entries","handleError","code","routerCode","onError","errorHandlerErr","parentContext","beforeLoadContext","beforeLoad","validResolvedMatches","matchPromises","parentMatchPromise","handleIfRedirect","componentsPromise","all","component","loaderPromise","_","loaderContext","onErrorError","reject","prevLocation","pathDidChange","debug","previousMatches","exitingMatchIds","includes","enteringMatchIds","stayingMatchIds","hook","preloadRoute","navigateOpts","buildLink","userPreload","preloadDelay","userPreloadDelay","activeOptions","disabled","target","nextOpts","defaultPreload","currentPathSplit","nextPathSplit","pathIsFuzzyEqual","every","pathTest","exact","hashTest","includeHash","searchTest","includeSearch","isActive","handleClick","defaultPrevented","button","preventDefault","handleFocus","catch","warn","handleTouchStart","handleEnter","preloadTimeout","setTimeout","handleLeave","unsub","nextLocation","initialLoad","matchRoute","pending","baseLocation","routerContextValue","Provider","Matches","useRouterState","useRouter","resolvedContext","useContext","warning","locationKey","rootRouteId","useCallback","useSearch","useParams","matchesContext","Match","defaultPending","PendingComponent","pendingComponent","defaultPendingComponent","routeErrorComponent","defaultErrorComponent","ResolvedSuspenseBoundary","wrapInSuspense","Suspense","fallback","MatchInner","comp","defaultComponent","Outlet","useMatchRoute","MatchRoute","nearestMatch","nearestMatchRouteId","matchRouteId","strict","matchSelection","useMatches","contextMatches","findIndex","Route","getParentRoute","__onInit","customId","addChildren","update","rootRouteWithContext","RootRoute","createRouteMask","FileRoute","createRoute","lazyRouteComponent","importer","exportName","lazyComp","lazy","moduleExports","default","useLinkProps","activeProps","className","inactiveProps","onFocus","onMouseEnter","onMouseLeave","onTouchStart","linkInfo","composeHandlers","handlers","persist","handler","resolvedActiveProps","resolvedInactiveProps","role","Link","forwardRef","linkProps","_extends","windowKey","delimiter","weakScrolledElements","WeakSet","cache","sessionsStorage","sessionStorage","defaultGetKey","useScrollRestoration","getKey","storageKey","getItem","cached","set","setItem","scrollRestoration","onScroll","event","has","elementSelector","getCssSelector","c","scrollX","NaN","scrollY","el","parentNode","tagName","indexOf","addEventListener","unsubOnBeforeLoad","restoreKey","entry","element","querySelector","scrollLeft","scrollTop","unsubOnResolved","windowRestored","cacheKey","scrollTo","removeEventListener","ScrollRestoration","useBlocker","condition","unblock","block","retry","cancel","confirm","Block","useNavigate","defaultOpts","typedNavigate","Navigate"],"mappings":"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"}