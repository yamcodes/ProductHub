import { RouterHistory } from '@tanstack/history';
import * as React from 'react';
import { LinkInfo, LinkOptions, NavigateOptions, ResolveRelativePath, ToOptions } from './link';
import { ParsedLocation } from './location';
import { AnyRoute } from './route';
import { FullSearchSchema, ParseRoute, RouteById, RouteIds, RoutePaths, RoutesById } from './routeInfo';
import { BuildNextOptions, DehydratedRouteMatch, RegisteredRouter, Router, RouterOptions, RouterState } from './router';
import { NoInfer } from './utils';
import { MatchRouteOptions } from './Matches';
export interface CommitLocationOptions {
    replace?: boolean;
    resetScroll?: boolean;
    startTransition?: boolean;
}
export interface MatchLocation {
    to?: string | number | null;
    fuzzy?: boolean;
    caseSensitive?: boolean;
    from?: string;
}
export type BuildLinkFn<TRouteTree extends AnyRoute> = <TFrom extends RoutePaths<TRouteTree> = '/', TTo extends string = ''>(dest: LinkOptions<TRouteTree, TFrom, TTo>) => LinkInfo;
export type NavigateFn<TRouteTree extends AnyRoute> = <TRouteTree extends AnyRoute, TFrom extends RoutePaths<TRouteTree> = '/', TTo extends string = '', TMaskFrom extends RoutePaths<TRouteTree> = TFrom, TMaskTo extends string = ''>({ from, to, ...rest }: NavigateOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>) => Promise<void>;
export type MatchRouteFn<TRouteTree extends AnyRoute> = <TFrom extends RoutePaths<TRouteTree> = '/', TTo extends string = '', TResolved = ResolveRelativePath<TFrom, NoInfer<TTo>>>(location: ToOptions<TRouteTree, TFrom, TTo>, opts?: MatchRouteOptions) => false | RouteById<TRouteTree, TResolved>['types']['allParams'];
export type LoadFn = (opts?: {
    next?: ParsedLocation;
    throwOnError?: boolean;
    __dehydratedMatches?: DehydratedRouteMatch[];
}) => Promise<void>;
export type BuildLocationFn<TRouteTree extends AnyRoute> = (opts: BuildNextOptions) => ParsedLocation;
export type RouterContext<TRouteTree extends AnyRoute> = {
    buildLink: BuildLinkFn<TRouteTree>;
    state: RouterState<TRouteTree>;
    navigate: NavigateFn<TRouteTree>;
    matchRoute: MatchRouteFn<TRouteTree>;
    routeTree: TRouteTree;
    routesById: RoutesById<TRouteTree>;
    options: RouterOptions<TRouteTree>;
    history: RouterHistory;
    load: LoadFn;
    buildLocation: BuildLocationFn<TRouteTree>;
    subscribe: Router<TRouteTree>['subscribe'];
    resetNextScrollRef: React.MutableRefObject<boolean>;
};
export declare const routerContext: React.Context<RouterContext<any>>;
export declare class SearchParamError extends Error {
}
export declare class PathParamError extends Error {
}
export declare function getInitialRouterState(location: ParsedLocation): RouterState<any>;
export declare function RouterProvider<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TDehydrated extends Record<string, any> = Record<string, any>>({ router, ...rest }: RouterProps<TRouteTree, TDehydrated>): JSX.Element;
export declare function getRouteMatch<TRouteTree extends AnyRoute>(state: RouterState<TRouteTree>, id: string): undefined | RouteMatch<TRouteTree>;
export declare function useRouterState<TSelected = RouterState<RegisteredRouter['routeTree']>>(opts?: {
    select: (state: RouterState<RegisteredRouter['routeTree']>) => TSelected;
}): TSelected;
export type RouterProps<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TDehydrated extends Record<string, any> = Record<string, any>> = Omit<RouterOptions<TRouteTree, TDehydrated>, 'context'> & {
    router: Router<TRouteTree>;
    context?: Partial<RouterOptions<TRouteTree, TDehydrated>['context']>;
};
export declare function useRouter<TRouteTree extends AnyRoute = RegisteredRouter['routeTree']>(): RouterContext<TRouteTree>;
export interface RouteMatch<TRouteTree extends AnyRoute = AnyRoute, TRouteId extends RouteIds<TRouteTree> = ParseRoute<TRouteTree>['id']> {
    id: string;
    routeId: TRouteId;
    pathname: string;
    params: RouteById<TRouteTree, TRouteId>['types']['allParams'];
    status: 'pending' | 'success' | 'error';
    isFetching: boolean;
    invalid: boolean;
    error: unknown;
    paramsError: unknown;
    searchError: unknown;
    updatedAt: number;
    loadPromise?: Promise<void>;
    __resolveLoadPromise?: () => void;
    context: RouteById<TRouteTree, TRouteId>['types']['allContext'];
    routeSearch: RouteById<TRouteTree, TRouteId>['types']['searchSchema'];
    search: FullSearchSchema<TRouteTree> & RouteById<TRouteTree, TRouteId>['types']['fullSearchSchema'];
    fetchedAt: number;
    abortController: AbortController;
}
export type AnyRouteMatch = RouteMatch<any>;
