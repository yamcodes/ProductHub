import * as React from 'react';
import { AnyRoute } from './route';
import { ParseRoute, RouteIds, RoutesById, RouteById } from './routeInfo';
import { RegisteredRouter } from './router';
export type NoInfer<T> = [T][T extends any ? 0 : never];
export type IsAny<T, Y, N = T> = 1 extends 0 & T ? Y : N;
export type IsAnyBoolean<T> = 1 extends 0 & T ? true : false;
export type IsKnown<T, Y, N> = unknown extends T ? N : Y;
export type PickAsRequired<T, K extends keyof T> = Omit<T, K> & Required<Pick<T, K>>;
export type PickAsPartial<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;
export type PickUnsafe<T, K> = K extends keyof T ? Pick<T, K> : never;
export type PickExtra<T, K> = {
    [TKey in keyof K as string extends TKey ? never : TKey extends keyof T ? never : TKey]: K[TKey];
};
export type PickRequired<T> = {
    [K in keyof T as undefined extends T[K] ? never : K]: T[K];
};
export type Expand<T> = T extends object ? T extends infer O ? {
    [K in keyof O]: O[K];
} : never : T;
export type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => any ? I : never;
export type Assign<Left, Right> = Omit<Left, keyof Right> & Right;
export type AssignAll<T extends any[]> = T extends [infer Left, ...infer Right] ? Right extends any[] ? Assign<Left, AssignAll<Right>> : Left : {};
export type Values<O> = O[ValueKeys<O>];
export type ValueKeys<O> = Extract<keyof O, PropertyKey>;
export type DeepAwaited<T> = T extends Promise<infer A> ? DeepAwaited<A> : T extends Record<infer A, Promise<infer B>> ? {
    [K in A]: DeepAwaited<B>;
} : T;
export type PathParamMask<TRoutePath extends string> = TRoutePath extends `${infer L}/$${infer C}/${infer R}` ? PathParamMask<`${L}/${string}/${R}`> : TRoutePath extends `${infer L}/$${infer C}` ? PathParamMask<`${L}/${string}`> : TRoutePath;
export type Timeout = ReturnType<typeof setTimeout>;
export type Updater<TPrevious, TResult = TPrevious> = TResult | ((prev?: TPrevious) => TResult);
export type NonNullableUpdater<TPrevious, TResult = TPrevious> = TResult | ((prev: TPrevious) => TResult);
export type PickExtract<T, U> = {
    [K in keyof T as T[K] extends U ? K : never]: T[K];
};
export type PickExclude<T, U> = {
    [K in keyof T as T[K] extends U ? never : K]: T[K];
};
export declare const isServer: boolean;
export declare function last<T>(arr: T[]): T | undefined;
export declare function functionalUpdate<TResult>(updater: Updater<TResult> | NonNullableUpdater<TResult>, previous: TResult): TResult;
export declare function pick<T, K extends keyof T>(parent: T, keys: K[]): Pick<T, K>;
/**
 * This function returns `a` if `b` is deeply equal.
 * If not, it will replace any deeply equal children of `b` with those of `a`.
 * This can be used for structural sharing between immutable JSON values for example.
 * Do not use this with signals
 */
export declare function replaceEqualDeep<T>(prev: any, _next: T): T;
export declare function isPlainObject(o: any): boolean;
export declare function partialDeepEqual(a: any, b: any): boolean;
export declare function useStableCallback<T extends (...args: any[]) => any>(fn: T): T;
export declare function shallow<T>(objA: T, objB: T): boolean;
export type StrictOrFrom<TFrom> = {
    from: TFrom;
    strict?: true;
} | {
    from?: never;
    strict: false;
};
export type RouteFromIdOrRoute<T, TRouteTree extends AnyRoute = RegisteredRouter['routeTree']> = T extends ParseRoute<TRouteTree> ? T : T extends RouteIds<TRouteTree> ? RoutesById<TRouteTree>[T] : T extends string ? RouteIds<TRouteTree> : never;
export declare function useRouteContext<TRouteTree extends AnyRoute = RegisteredRouter['routeTree'], TFrom extends RouteIds<TRouteTree> = RouteIds<TRouteTree>, TStrict extends boolean = true, TRouteContext = RouteById<TRouteTree, TFrom>['types']['allContext'], TSelected = TRouteContext>(opts: StrictOrFrom<TFrom> & {
    select?: (search: TRouteContext) => TSelected;
}): TStrict extends true ? TSelected : TSelected | undefined;
export declare const useLayoutEffect: typeof React.useLayoutEffect;
