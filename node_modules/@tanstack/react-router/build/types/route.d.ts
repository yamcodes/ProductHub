import * as React from 'react';
import { AnyRouteMatch } from './RouterProvider';
import { NavigateOptions, ParsePathParams, ToSubOptions } from './link';
import { ParsedLocation } from './location';
import { RoutePaths } from './routeInfo';
import { AnyRouter } from './router';
import { Assign, Expand, IsAny, NoInfer, PickRequired, UnionToIntersection } from './utils';
import { BuildLocationFn, NavigateFn } from './RouterProvider';
export declare const rootRouteId: "__root__";
export type RootRouteId = typeof rootRouteId;
export type AnyPathParams = {};
export type AnySearchSchema = {};
export type AnyContext = {};
export interface RouteContext {
}
export interface RouteMeta {
}
export type PreloadableObj = {
    preload?: () => Promise<void>;
};
export type RoutePathOptions<TCustomId, TPath> = {
    path: TPath;
} | {
    id: TCustomId;
};
export type RoutePathOptionsIntersection<TCustomId, TPath> = UnionToIntersection<RoutePathOptions<TCustomId, TPath>>;
export type MetaOptions = keyof PickRequired<RouteMeta> extends never ? {
    meta?: RouteMeta;
} : {
    meta: RouteMeta;
};
export type RouteOptions<TParentRoute extends AnyRoute = AnyRoute, TCustomId extends string = string, TPath extends string = string, TSearchSchema extends Record<string, any> = {}, TFullSearchSchema extends Record<string, any> = TSearchSchema, TParams extends AnyPathParams = AnyPathParams, TAllParams extends AnyPathParams = TParams, TRouteContext extends RouteContext = RouteContext, TAllContext extends Record<string, any> = AnyContext> = BaseRouteOptions<TParentRoute, TCustomId, TPath, TSearchSchema, TFullSearchSchema, TParams, TAllParams, TRouteContext, TAllContext> & NoInfer<UpdatableRouteOptions<TFullSearchSchema, TAllParams, TAllContext>>;
export type ParamsFallback<TPath extends string, TParams> = unknown extends TParams ? Record<ParsePathParams<TPath>, string> : TParams;
export type BaseRouteOptions<TParentRoute extends AnyRoute = AnyRoute, TCustomId extends string = string, TPath extends string = string, TSearchSchema extends Record<string, any> = {}, TFullSearchSchema extends Record<string, any> = TSearchSchema, TParams extends AnyPathParams = {}, TAllParams = ParamsFallback<TPath, TParams>, TRouteContext extends RouteContext = RouteContext, TAllContext extends Record<string, any> = AnyContext> = RoutePathOptions<TCustomId, TPath> & {
    getParentRoute: () => TParentRoute;
    validateSearch?: SearchSchemaValidator<TSearchSchema>;
} & (keyof PickRequired<RouteContext> extends never ? {
    beforeLoad?: BeforeLoadFn<TFullSearchSchema, TParentRoute, TAllParams, TRouteContext>;
} : {
    beforeLoad: BeforeLoadFn<TFullSearchSchema, TParentRoute, TAllParams, TRouteContext>;
}) & {
    load?: RouteLoadFn<TAllParams, TFullSearchSchema, NoInfer<TAllContext>, NoInfer<TRouteContext>>;
} & ({
    parseParams?: (rawParams: IsAny<TPath, any, Record<ParsePathParams<TPath>, string>>) => TParams extends Record<ParsePathParams<TPath>, any> ? TParams : 'parseParams must return an object';
    stringifyParams?: (params: NoInfer<ParamsFallback<TPath, TParams>>) => Record<ParsePathParams<TPath>, string>;
} | {
    stringifyParams?: never;
    parseParams?: never;
});
type BeforeLoadFn<TFullSearchSchema extends Record<string, any>, TParentRoute extends AnyRoute, TAllParams, TRouteContext> = (opts: {
    search: TFullSearchSchema;
    abortController: AbortController;
    preload: boolean;
    params: TAllParams;
    context: TParentRoute['types']['allContext'];
    location: ParsedLocation;
    navigate: NavigateFn<AnyRoute>;
    buildLocation: BuildLocationFn<AnyRoute>;
}) => Promise<TRouteContext> | TRouteContext | void;
export type UpdatableRouteOptions<TFullSearchSchema extends Record<string, any>, TAllParams extends AnyPathParams, TAllContext extends AnyContext> = MetaOptions & {
    caseSensitive?: boolean;
    wrapInSuspense?: boolean;
    component?: RouteComponent<TFullSearchSchema, TAllParams, TAllContext>;
    errorComponent?: ErrorRouteComponent<TFullSearchSchema, TAllParams, {}>;
    pendingComponent?: PendingRouteComponent<TFullSearchSchema, TAllParams, TAllContext>;
    preSearchFilters?: SearchFilter<TFullSearchSchema>[];
    postSearchFilters?: SearchFilter<TFullSearchSchema>[];
    onError?: (err: any) => void;
    onEnter?: (match: AnyRouteMatch) => void;
    onTransition?: (match: AnyRouteMatch) => void;
    onLeave?: (match: AnyRouteMatch) => void;
    reloadOnWindowFocus?: boolean;
};
export type ParseParamsOption<TPath extends string, TParams> = ParseParamsFn<TPath, TParams>;
export type ParseParamsFn<TPath extends string, TParams> = (rawParams: IsAny<TPath, any, Record<ParsePathParams<TPath>, string>>) => TParams extends Record<ParsePathParams<TPath>, any> ? TParams : 'parseParams must return an object';
export type ParseParamsObj<TPath extends string, TParams> = {
    parse?: ParseParamsFn<TPath, TParams>;
};
export type SearchSchemaValidator<TReturn> = SearchSchemaValidatorObj<TReturn> | SearchSchemaValidatorFn<TReturn>;
export type SearchSchemaValidatorObj<TReturn> = {
    parse?: SearchSchemaValidatorFn<TReturn>;
};
export type SearchSchemaValidatorFn<TReturn> = (searchObj: Record<string, unknown>) => TReturn;
export type DefinedPathParamWarning = 'Path params cannot be redefined by child routes!';
export type ParentParams<TParentParams> = AnyPathParams extends TParentParams ? {} : {
    [Key in keyof TParentParams]?: DefinedPathParamWarning;
};
export type RouteLoadFn<TAllParams = {}, TFullSearchSchema extends Record<string, any> = {}, TAllContext extends Record<string, any> = AnyContext, TRouteContext extends Record<string, any> = AnyContext> = (match: LoadFnContext<TAllParams, TFullSearchSchema, TAllContext, TRouteContext> & {
    parentMatchPromise?: Promise<void>;
}) => any;
export interface LoadFnContext<TAllParams = {}, TFullSearchSchema extends Record<string, any> = {}, TAllContext extends Record<string, any> = AnyContext, TRouteContext extends Record<string, any> = AnyContext> {
    abortController: AbortController;
    preload: boolean;
    params: TAllParams;
    search: TFullSearchSchema;
    context: Expand<Assign<TAllContext, TRouteContext>>;
    location: ParsedLocation<TFullSearchSchema>;
    navigate: (opts: NavigateOptions<AnyRoute>) => Promise<void>;
}
export type SearchFilter<T, U = T> = (prev: T) => U;
export type ResolveId<TParentRoute, TCustomId extends string, TPath extends string> = TParentRoute extends {
    id: infer TParentId extends string;
} ? RoutePrefix<TParentId, string extends TCustomId ? TPath : TCustomId> : RootRouteId;
export type InferFullSearchSchema<TRoute> = TRoute extends {
    types: {
        fullSearchSchema: infer TFullSearchSchema;
    };
} ? TFullSearchSchema : {};
export type ResolveFullSearchSchema<TParentRoute, TSearchSchema> = Expand<Assign<InferFullSearchSchema<TParentRoute>, TSearchSchema>>;
export interface AnyRoute extends Route<any, any, any, any, any, any, any, any, any, any, any, any, any, any> {
}
export type MergeFromFromParent<T, U> = IsAny<T, U, T & U>;
export type StreamedPromise<T> = {
    promise: Promise<T>;
    status: 'resolved' | 'pending';
    data: T;
    resolve: (value: T) => void;
};
export type ResolveAllParams<TParentRoute extends AnyRoute, TParams extends AnyPathParams> = Record<never, string> extends TParentRoute['types']['allParams'] ? TParams : Expand<UnionToIntersection<TParentRoute['types']['allParams'] & TParams> & {}>;
export type RouteConstraints = {
    TParentRoute: AnyRoute;
    TPath: string;
    TFullPath: string;
    TCustomId: string;
    TId: string;
    TSearchSchema: AnySearchSchema;
    TFullSearchSchema: AnySearchSchema;
    TParams: Record<string, any>;
    TAllParams: Record<string, any>;
    TParentContext: AnyContext;
    TRouteContext: RouteContext;
    TAllContext: AnyContext;
    TRouterContext: AnyContext;
    TChildren: unknown;
    TRouteTree: AnyRoute;
};
export declare class Route<TParentRoute extends RouteConstraints['TParentRoute'] = AnyRoute, TPath extends RouteConstraints['TPath'] = '/', TFullPath extends RouteConstraints['TFullPath'] = ResolveFullPath<TParentRoute, TPath>, TCustomId extends RouteConstraints['TCustomId'] = string, TId extends RouteConstraints['TId'] = ResolveId<TParentRoute, TCustomId, TPath>, TSearchSchema extends RouteConstraints['TSearchSchema'] = {}, TFullSearchSchema extends RouteConstraints['TFullSearchSchema'] = ResolveFullSearchSchema<TParentRoute, TSearchSchema>, TParams extends RouteConstraints['TParams'] = Expand<Record<ParsePathParams<TPath>, string>>, TAllParams extends RouteConstraints['TAllParams'] = ResolveAllParams<TParentRoute, TParams>, TRouteContext extends RouteConstraints['TRouteContext'] = RouteContext, TAllContext extends Expand<Assign<IsAny<TParentRoute['types']['allContext'], {}>, TRouteContext>> = Expand<Assign<IsAny<TParentRoute['types']['allContext'], {}>, TRouteContext>>, TRouterContext extends RouteConstraints['TRouterContext'] = AnyContext, TChildren extends RouteConstraints['TChildren'] = unknown, TRouteTree extends RouteConstraints['TRouteTree'] = AnyRoute> {
    isRoot: TParentRoute extends Route<any> ? true : false;
    options: RouteOptions<TParentRoute, TCustomId, TPath, TSearchSchema, TFullSearchSchema, TParams, TAllParams, TRouteContext, TAllContext>;
    test: Expand<Assign<IsAny<TParentRoute['types']['allContext'], {}>, TRouteContext>>;
    parentRoute: TParentRoute;
    id: TId;
    path: TPath;
    fullPath: TFullPath;
    to: TrimPathRight<TFullPath>;
    children?: TChildren;
    originalIndex?: number;
    router?: AnyRouter;
    rank: number;
    constructor(options: RouteOptions<TParentRoute, TCustomId, TPath, TSearchSchema, TFullSearchSchema, TParams, TAllParams, TRouteContext, TAllContext>);
    types: {
        parentRoute: TParentRoute;
        path: TPath;
        to: TrimPathRight<TFullPath>;
        fullPath: TFullPath;
        customId: TCustomId;
        id: TId;
        searchSchema: TSearchSchema;
        fullSearchSchema: TFullSearchSchema;
        params: TParams;
        allParams: TAllParams;
        routeContext: TRouteContext;
        allContext: TAllContext;
        children: TChildren;
        routeTree: TRouteTree;
        routerContext: TRouterContext;
    };
    init: (opts: {
        originalIndex: number;
    }) => void;
    addChildren: <TNewChildren extends AnyRoute[]>(children: TNewChildren) => Route<TParentRoute, TPath, TFullPath, TCustomId, TId, TSearchSchema, TFullSearchSchema, TParams, TAllParams, TRouteContext, TAllContext, TRouterContext, TNewChildren, TRouteTree>;
    update: (options: UpdatableRouteOptions<TFullSearchSchema, TAllParams, Expand<Assign<IsAny<TParentRoute['types']['allContext'], {}>, TRouteContext>>>) => this;
    static __onInit: (route: any) => void;
    useMatch: <TSelected = TAllContext>(opts?: {
        select?: ((search: TAllContext) => TSelected) | undefined;
    } | undefined) => TSelected;
    useRouteContext: <TSelected = TAllContext>(opts?: {
        select?: ((search: TAllContext) => TSelected) | undefined;
    } | undefined) => TSelected;
    useSearch: <TSelected = TFullSearchSchema>(opts?: {
        select?: ((search: TFullSearchSchema) => TSelected) | undefined;
    } | undefined) => TSelected;
    useParams: <TSelected = TAllParams>(opts?: {
        select?: ((search: TAllParams) => TSelected) | undefined;
    } | undefined) => TSelected;
}
export type AnyRootRoute = RootRoute<any, any, any>;
export declare function rootRouteWithContext<TRouterContext extends {}>(): <TSearchSchema extends Record<string, any> = {}, TRouteContext extends RouteContext = RouteContext>(options?: Omit<RouteOptions<AnyRoute, "__root__", "", TSearchSchema, TSearchSchema, {}, {}, TRouteContext, Assign<TRouterContext, TRouteContext>>, "path" | "id" | "getParentRoute" | "stringifyParams" | "parseParams" | "caseSensitive"> | undefined) => RootRoute<TSearchSchema, TRouteContext, TRouterContext>;
export declare class RootRoute<TSearchSchema extends Record<string, any> = {}, TRouteContext extends RouteContext = RouteContext, TRouterContext extends {} = {}> extends Route<any, // TParentRoute
'/', // TPath
'/', // TFullPath
string, // TCustomId
RootRouteId, // TId
TSearchSchema, // TSearchSchema
TSearchSchema, // TFullSearchSchema
{}, // TParams
{}, // TAllParams
TRouteContext, // TRouteContext
Expand<Assign<TRouterContext, TRouteContext>>, // TAllContext
TRouterContext, // TRouterContext
any, // TChildren
any> {
    constructor(options?: Omit<RouteOptions<AnyRoute, // TParentRoute
    RootRouteId, // TCustomId
    '', // TPath
    TSearchSchema, // TSearchSchema
    TSearchSchema, // TFullSearchSchema
    {}, // TParams
    {}, // TAllParams
    TRouteContext, // TRouteContext
    Assign<TRouterContext, TRouteContext>>, 'path' | 'id' | 'getParentRoute' | 'caseSensitive' | 'parseParams' | 'stringifyParams'>);
}
export type ResolveFullPath<TParentRoute extends AnyRoute, TPath extends string, TPrefixed = RoutePrefix<TParentRoute['fullPath'], TPath>> = TPrefixed extends RootRouteId ? '/' : TPrefixed;
type RoutePrefix<TPrefix extends string, TPath extends string> = string extends TPath ? RootRouteId : TPath extends string ? TPrefix extends RootRouteId ? TPath extends '/' ? '/' : `/${TrimPath<TPath>}` : `${TPrefix}/${TPath}` extends '/' ? '/' : `/${TrimPathLeft<`${TrimPathRight<TPrefix>}/${TrimPath<TPath>}`>}` : never;
export type TrimPath<T extends string> = '' extends T ? '' : TrimPathRight<TrimPathLeft<T>>;
export type TrimPathLeft<T extends string> = T extends `${RootRouteId}/${infer U}` ? TrimPathLeft<U> : T extends `/${infer U}` ? TrimPathLeft<U> : T;
export type TrimPathRight<T extends string> = T extends '/' ? '/' : T extends `${infer U}/` ? TrimPathRight<U> : T;
export type RouteMask<TRouteTree extends AnyRoute> = {
    routeTree: TRouteTree;
    from: RoutePaths<TRouteTree>;
    to?: any;
    params?: any;
    search?: any;
    hash?: any;
    state?: any;
    unmaskOnReload?: boolean;
};
export declare function createRouteMask<TRouteTree extends AnyRoute, TFrom extends RoutePaths<TRouteTree>, TTo extends string>(opts: {
    routeTree: TRouteTree;
} & ToSubOptions<TRouteTree, TFrom, TTo>): RouteMask<TRouteTree>;
export type RouteProps<TFullSearchSchema extends Record<string, any> = AnySearchSchema, TAllParams extends AnyPathParams = AnyPathParams, TAllContext extends Record<string, any> = AnyContext> = {
    useMatch: <TSelected = TAllContext>(opts?: {
        select?: (search: TAllContext) => TSelected;
    }) => TSelected;
    useRouteContext: <TSelected = TAllContext>(opts?: {
        select?: (search: TAllContext) => TSelected;
    }) => TSelected;
    useSearch: <TSelected = TFullSearchSchema>(opts?: {
        select?: (search: TFullSearchSchema) => TSelected;
    }) => TSelected;
    useParams: <TSelected = TAllParams>(opts?: {
        select?: (search: TAllParams) => TSelected;
    }) => TSelected;
};
export type ErrorRouteProps<TFullSearchSchema extends Record<string, any> = AnySearchSchema, TAllParams extends AnyPathParams = AnyPathParams, TAllContext extends Record<string, any> = AnyContext> = {
    error: unknown;
    info: {
        componentStack: string;
    };
} & RouteProps<TFullSearchSchema, TAllParams, TAllContext>;
export type PendingRouteProps<TFullSearchSchema extends Record<string, any> = AnySearchSchema, TAllParams extends AnyPathParams = AnyPathParams, TAllContext extends Record<string, any> = AnyContext> = RouteProps<TFullSearchSchema, TAllParams, TAllContext>;
export type ReactNode = any;
export type SyncRouteComponent<TProps> = ((props: TProps) => ReactNode) | React.LazyExoticComponent<(props: TProps) => ReactNode>;
export type AsyncRouteComponent<TProps> = SyncRouteComponent<TProps> & {
    preload?: () => Promise<void>;
};
export type RouteComponent<TFullSearchSchema extends Record<string, any>, TAllParams extends AnyPathParams, TAllContext extends Record<string, any>> = AsyncRouteComponent<RouteProps<TFullSearchSchema, TAllParams, TAllContext>>;
export type ErrorRouteComponent<TFullSearchSchema extends Record<string, any>, TAllParams extends AnyPathParams, TAllContext extends Record<string, any>> = AsyncRouteComponent<ErrorRouteProps<TFullSearchSchema, TAllParams, TAllContext>>;
export type PendingRouteComponent<TFullSearchSchema extends Record<string, any>, TAllParams extends AnyPathParams, TAllContext extends Record<string, any>> = AsyncRouteComponent<PendingRouteProps<TFullSearchSchema, TAllParams, TAllContext>>;
export type AnyRouteComponent = RouteComponent<any, any, any>;
export {};
