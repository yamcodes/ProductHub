/// <reference types="react" />
import { RouterHistory } from '@tanstack/history';
import { AnySearchSchema, AnyRoute, AnyContext, AnyPathParams, RouteMask } from './route';
import { FullSearchSchema } from './routeInfo';
import { PickAsRequired, Updater, NonNullableUpdater } from './utils';
import { ErrorRouteComponent, PendingRouteComponent, RouteComponent } from './route';
import { RouteMatch } from './RouterProvider';
import { ParsedLocation } from './location';
import { LocationState } from './location';
import { SearchSerializer, SearchParser } from './searchParams';
import { RouterContext } from './RouterProvider';
declare global {
    interface Window {
        __TSR_DEHYDRATED__?: HydrationCtx;
        __TSR_ROUTER_CONTEXT__?: React.Context<RouterContext<any>>;
    }
}
export interface Register {
}
export type AnyRouter = Router<any, any>;
export type RegisteredRouter = Register extends {
    router: infer TRouter extends AnyRouter;
} ? TRouter : AnyRouter;
export type HydrationCtx = {
    router: DehydratedRouter;
    payload: Record<string, any>;
};
export type RouterContextOptions<TRouteTree extends AnyRoute> = AnyContext extends TRouteTree['types']['routerContext'] ? {
    context?: TRouteTree['types']['routerContext'];
} : {
    context: TRouteTree['types']['routerContext'];
};
export interface RouterOptions<TRouteTree extends AnyRoute, TDehydrated extends Record<string, any> = Record<string, any>> {
    history?: RouterHistory;
    stringifySearch?: SearchSerializer;
    parseSearch?: SearchParser;
    defaultPreload?: false | 'intent';
    defaultPreloadDelay?: number;
    defaultComponent?: RouteComponent<AnySearchSchema, AnyPathParams, AnyContext>;
    defaultErrorComponent?: ErrorRouteComponent<AnySearchSchema, AnyPathParams, AnyContext>;
    defaultPendingComponent?: PendingRouteComponent<AnySearchSchema, AnyPathParams, AnyContext>;
    defaultMaxAge?: number;
    defaultGcMaxAge?: number;
    defaultPreloadMaxAge?: number;
    caseSensitive?: boolean;
    routeTree?: TRouteTree;
    basepath?: string;
    createRoute?: (opts: {
        route: AnyRoute;
        router: AnyRouter;
    }) => void;
    context?: TRouteTree['types']['routerContext'];
    routeMasks?: RouteMask<TRouteTree>[];
    unmaskOnReload?: boolean;
}
export interface RouterState<TRouteTree extends AnyRoute = AnyRoute> {
    status: 'pending' | 'idle';
    matches: RouteMatch<TRouteTree>[];
    pendingMatches: RouteMatch<TRouteTree>[];
    location: ParsedLocation<FullSearchSchema<TRouteTree>>;
    resolvedLocation: ParsedLocation<FullSearchSchema<TRouteTree>>;
    lastUpdated: number;
}
export type ListenerFn<TEvent extends RouterEvent> = (event: TEvent) => void;
export interface BuildNextOptions {
    to?: string | number | null;
    params?: true | Updater<unknown>;
    search?: true | Updater<unknown>;
    hash?: true | Updater<string>;
    state?: true | NonNullableUpdater<LocationState>;
    mask?: {
        to?: string | number | null;
        params?: true | Updater<unknown>;
        search?: true | Updater<unknown>;
        hash?: true | Updater<string>;
        state?: true | NonNullableUpdater<LocationState>;
        unmaskOnReload?: boolean;
    };
    from?: string;
}
export interface DehydratedRouterState {
    dehydratedMatches: DehydratedRouteMatch[];
}
export type DehydratedRouteMatch = Pick<RouteMatch, 'fetchedAt' | 'invalid' | 'id' | 'status' | 'updatedAt'>;
export interface DehydratedRouter {
    state: DehydratedRouterState;
}
export type RouterConstructorOptions<TRouteTree extends AnyRoute, TDehydrated extends Record<string, any>> = Omit<RouterOptions<TRouteTree, TDehydrated>, 'context'> & RouterContextOptions<TRouteTree>;
export declare const componentTypes: readonly ["component", "errorComponent", "pendingComponent"];
export type RouterEvents = {
    onBeforeLoad: {
        type: 'onBeforeLoad';
        fromLocation: ParsedLocation;
        toLocation: ParsedLocation;
        pathChanged: boolean;
    };
    onLoad: {
        type: 'onLoad';
        fromLocation: ParsedLocation;
        toLocation: ParsedLocation;
        pathChanged: boolean;
    };
    onResolved: {
        type: 'onResolved';
        fromLocation: ParsedLocation;
        toLocation: ParsedLocation;
        pathChanged: boolean;
    };
};
export type RouterEvent = RouterEvents[keyof RouterEvents];
export type RouterListener<TRouterEvent extends RouterEvent> = {
    eventType: TRouterEvent['type'];
    fn: ListenerFn<TRouterEvent>;
};
export declare class Router<TRouteTree extends AnyRoute = AnyRoute, TDehydrated extends Record<string, any> = Record<string, any>> {
    options: PickAsRequired<RouterOptions<TRouteTree, TDehydrated>, 'stringifySearch' | 'parseSearch' | 'context'>;
    routeTree: TRouteTree;
    constructor(options: RouterConstructorOptions<TRouteTree, TDehydrated>);
    subscribers: Set<RouterListener<RouterEvent>>;
    subscribe: <TType extends keyof RouterEvents>(eventType: TType, fn: ListenerFn<RouterEvents[TType]>) => () => void;
    emit: (routerEvent: RouterEvent) => void;
}
export declare function lazyFn<T extends Record<string, (...args: any[]) => any>, TKey extends keyof T = 'default'>(fn: () => Promise<T>, key?: TKey): (...args: Parameters<T[TKey]>) => Promise<ReturnType<T[TKey]>>;
