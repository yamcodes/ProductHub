{"version":3,"file":"router.js","sources":["../../src/router.ts"],"sourcesContent":["import { RouterHistory } from '@tanstack/history'\n\n//\n\nimport {\n  AnySearchSchema,\n  AnyRoute,\n  AnyContext,\n  AnyPathParams,\n  RouteMask,\n} from './route'\nimport { FullSearchSchema } from './routeInfo'\nimport { defaultParseSearch, defaultStringifySearch } from './searchParams'\nimport { PickAsRequired, Updater, NonNullableUpdater } from './utils'\nimport {\n  ErrorRouteComponent,\n  PendingRouteComponent,\n  RouteComponent,\n} from './route'\nimport { RouteMatch } from './RouterProvider'\nimport { ParsedLocation } from './location'\nimport { LocationState } from './location'\nimport { SearchSerializer, SearchParser } from './searchParams'\nimport { RouterContext } from './RouterProvider'\n\n//\n\ndeclare global {\n  interface Window {\n    __TSR_DEHYDRATED__?: HydrationCtx\n    __TSR_ROUTER_CONTEXT__?: React.Context<RouterContext<any>>\n  }\n}\n\nexport interface Register {\n  // router: Router\n}\n\nexport type AnyRouter = Router<any, any>\n\nexport type RegisteredRouter = Register extends {\n  router: infer TRouter extends AnyRouter\n}\n  ? TRouter\n  : AnyRouter\n\nexport type HydrationCtx = {\n  router: DehydratedRouter\n  payload: Record<string, any>\n}\n\nexport type RouterContextOptions<TRouteTree extends AnyRoute> =\n  AnyContext extends TRouteTree['types']['routerContext']\n    ? {\n        context?: TRouteTree['types']['routerContext']\n      }\n    : {\n        context: TRouteTree['types']['routerContext']\n      }\n\nexport interface RouterOptions<\n  TRouteTree extends AnyRoute,\n  TDehydrated extends Record<string, any> = Record<string, any>,\n> {\n  history?: RouterHistory\n  stringifySearch?: SearchSerializer\n  parseSearch?: SearchParser\n  defaultPreload?: false | 'intent'\n  defaultPreloadDelay?: number\n  defaultComponent?: RouteComponent<AnySearchSchema, AnyPathParams, AnyContext>\n  defaultErrorComponent?: ErrorRouteComponent<\n    AnySearchSchema,\n    AnyPathParams,\n    AnyContext\n  >\n  defaultPendingComponent?: PendingRouteComponent<\n    AnySearchSchema,\n    AnyPathParams,\n    AnyContext\n  >\n  defaultMaxAge?: number\n  defaultGcMaxAge?: number\n  defaultPreloadMaxAge?: number\n  caseSensitive?: boolean\n  routeTree?: TRouteTree\n  basepath?: string\n  createRoute?: (opts: { route: AnyRoute; router: AnyRouter }) => void\n  context?: TRouteTree['types']['routerContext']\n  // dehydrate?: () => TDehydrated\n  // hydrate?: (dehydrated: TDehydrated) => void\n  routeMasks?: RouteMask<TRouteTree>[]\n  unmaskOnReload?: boolean\n}\n\nexport interface RouterState<TRouteTree extends AnyRoute = AnyRoute> {\n  status: 'pending' | 'idle'\n  matches: RouteMatch<TRouteTree>[]\n  pendingMatches: RouteMatch<TRouteTree>[]\n  location: ParsedLocation<FullSearchSchema<TRouteTree>>\n  resolvedLocation: ParsedLocation<FullSearchSchema<TRouteTree>>\n  lastUpdated: number\n}\n\nexport type ListenerFn<TEvent extends RouterEvent> = (event: TEvent) => void\n\nexport interface BuildNextOptions {\n  to?: string | number | null\n  params?: true | Updater<unknown>\n  search?: true | Updater<unknown>\n  hash?: true | Updater<string>\n  state?: true | NonNullableUpdater<LocationState>\n  mask?: {\n    to?: string | number | null\n    params?: true | Updater<unknown>\n    search?: true | Updater<unknown>\n    hash?: true | Updater<string>\n    state?: true | NonNullableUpdater<LocationState>\n    unmaskOnReload?: boolean\n  }\n  from?: string\n}\n\nexport interface DehydratedRouterState {\n  dehydratedMatches: DehydratedRouteMatch[]\n}\n\nexport type DehydratedRouteMatch = Pick<\n  RouteMatch,\n  'fetchedAt' | 'invalid' | 'id' | 'status' | 'updatedAt'\n>\n\nexport interface DehydratedRouter {\n  state: DehydratedRouterState\n}\n\nexport type RouterConstructorOptions<\n  TRouteTree extends AnyRoute,\n  TDehydrated extends Record<string, any>,\n> = Omit<RouterOptions<TRouteTree, TDehydrated>, 'context'> &\n  RouterContextOptions<TRouteTree>\n\nexport const componentTypes = [\n  'component',\n  'errorComponent',\n  'pendingComponent',\n] as const\n\nexport type RouterEvents = {\n  onBeforeLoad: {\n    type: 'onBeforeLoad'\n    fromLocation: ParsedLocation\n    toLocation: ParsedLocation\n    pathChanged: boolean\n  }\n  onLoad: {\n    type: 'onLoad'\n    fromLocation: ParsedLocation\n    toLocation: ParsedLocation\n    pathChanged: boolean\n  }\n  onResolved: {\n    type: 'onResolved'\n    fromLocation: ParsedLocation\n    toLocation: ParsedLocation\n    pathChanged: boolean\n  }\n}\n\nexport type RouterEvent = RouterEvents[keyof RouterEvents]\n\nexport type RouterListener<TRouterEvent extends RouterEvent> = {\n  eventType: TRouterEvent['type']\n  fn: ListenerFn<TRouterEvent>\n}\n\nexport class Router<\n  TRouteTree extends AnyRoute = AnyRoute,\n  TDehydrated extends Record<string, any> = Record<string, any>,\n> {\n  options: PickAsRequired<\n    RouterOptions<TRouteTree, TDehydrated>,\n    'stringifySearch' | 'parseSearch' | 'context'\n  >\n  routeTree: TRouteTree\n  // dehydratedData?: TDehydrated\n  // resetNextScroll = false\n  // tempLocationKey = `${Math.round(Math.random() * 10000000)}`\n\n  constructor(options: RouterConstructorOptions<TRouteTree, TDehydrated>) {\n    this.options = {\n      defaultPreloadDelay: 50,\n      context: undefined!,\n      ...options,\n      stringifySearch: options?.stringifySearch ?? defaultStringifySearch,\n      parseSearch: options?.parseSearch ?? defaultParseSearch,\n    }\n\n    this.routeTree = this.options.routeTree as TRouteTree\n  }\n\n  subscribers = new Set<RouterListener<RouterEvent>>()\n\n  subscribe = <TType extends keyof RouterEvents>(\n    eventType: TType,\n    fn: ListenerFn<RouterEvents[TType]>,\n  ) => {\n    const listener: RouterListener<any> = {\n      eventType,\n      fn,\n    }\n\n    this.subscribers.add(listener)\n\n    return () => {\n      this.subscribers.delete(listener)\n    }\n  }\n\n  emit = (routerEvent: RouterEvent) => {\n    this.subscribers.forEach((listener) => {\n      if (listener.eventType === routerEvent.type) {\n        listener.fn(routerEvent)\n      }\n    })\n  }\n\n  // dehydrate = (): DehydratedRouter => {\n  //   return {\n  //     state: {\n  //       dehydratedMatches: state.matches.map((d) =>\n  //         pick(d, ['fetchedAt', 'invalid', 'id', 'status', 'updatedAt']),\n  //       ),\n  //     },\n  //   }\n  // }\n\n  // hydrate = async (__do_not_use_server_ctx?: HydrationCtx) => {\n  //   let _ctx = __do_not_use_server_ctx\n  //   // Client hydrates from window\n  //   if (typeof document !== 'undefined') {\n  //     _ctx = window.__TSR_DEHYDRATED__\n  //   }\n\n  //   invariant(\n  //     _ctx,\n  //     'Expected to find a __TSR_DEHYDRATED__ property on window... but we did not. Did you forget to render <DehydrateRouter /> in your app?',\n  //   )\n\n  //   const ctx = _ctx\n  //   this.dehydratedData = ctx.payload as any\n  //   this.options.hydrate?.(ctx.payload as any)\n  //   const dehydratedState = ctx.router.state\n\n  //   let matches = this.matchRoutes(\n  //     state.location.pathname,\n  //     state.location.search,\n  //   ).map((match) => {\n  //     const dehydratedMatch = dehydratedState.dehydratedMatches.find(\n  //       (d) => d.id === match.id,\n  //     )\n\n  //     invariant(\n  //       dehydratedMatch,\n  //       `Could not find a client-side match for dehydrated match with id: ${match.id}!`,\n  //     )\n\n  //     if (dehydratedMatch) {\n  //       return {\n  //         ...match,\n  //         ...dehydratedMatch,\n  //       }\n  //     }\n  //     return match\n  //   })\n\n  //   this.setState((s) => {\n  //     return {\n  //       ...s,\n  //       matches: dehydratedState.dehydratedMatches as any,\n  //     }\n  //   })\n  // }\n\n  // TODO:\n  // injectedHtml: (string | (() => Promise<string> | string))[] = []\n\n  // TODO:\n  // injectHtml = async (html: string | (() => Promise<string> | string)) => {\n  //   this.injectedHtml.push(html)\n  // }\n\n  // TODO:\n  // dehydrateData = <T>(key: any, getData: T | (() => Promise<T> | T)) => {\n  //   if (typeof document === 'undefined') {\n  //     const strKey = typeof key === 'string' ? key : JSON.stringify(key)\n\n  //     this.injectHtml(async () => {\n  //       const id = `__TSR_DEHYDRATED__${strKey}`\n  //       const data =\n  //         typeof getData === 'function' ? await (getData as any)() : getData\n  //       return `<script id='${id}' suppressHydrationWarning>window[\"__TSR_DEHYDRATED__${escapeJSON(\n  //         strKey,\n  //       )}\"] = ${JSON.stringify(data)}\n  //       ;(() => {\n  //         var el = document.getElementById('${id}')\n  //         el.parentElement.removeChild(el)\n  //       })()\n  //       </script>`\n  //     })\n\n  //     return () => this.hydrateData<T>(key)\n  //   }\n\n  //   return () => undefined\n  // }\n\n  // hydrateData = <T = unknown>(key: any) => {\n  //   if (typeof document !== 'undefined') {\n  //     const strKey = typeof key === 'string' ? key : JSON.stringify(key)\n\n  //     return window[`__TSR_DEHYDRATED__${strKey}` as any] as T\n  //   }\n\n  //   return undefined\n  // }\n\n  // resolveMatchPromise = (matchId: string, key: string, value: any) => {\n  //   state.matches\n  //     .find((d) => d.id === matchId)\n  //     ?.__promisesByKey[key]?.resolve(value)\n  // }\n\n  // setRouteMatch = (\n  //   id: string,\n  //   pending: boolean,\n  //   updater: NonNullableUpdater<RouteMatch<TRouteTree>>,\n  // ) => {\n  //   const key = pending ? 'pendingMatches' : 'matches'\n\n  //   this.setState((prev) => {\n  //     return {\n  //       ...prev,\n  //       [key]: prev[key].map((d) => {\n  //         if (d.id === id) {\n  //           return functionalUpdate(updater, d)\n  //         }\n\n  //         return d\n  //       }),\n  //     }\n  //   })\n  // }\n\n  // setPendingRouteMatch = (\n  //   id: string,\n  //   updater: NonNullableUpdater<RouteMatch<TRouteTree>>,\n  // ) => {\n  //   this.setRouteMatch(id, true, updater)\n  // }\n}\n\nfunction escapeJSON(jsonString: string) {\n  return jsonString\n    .replace(/\\\\/g, '\\\\\\\\') // Escape backslashes\n    .replace(/'/g, \"\\\\'\") // Escape single quotes\n    .replace(/\"/g, '\\\\\"') // Escape double quotes\n}\n\n// A function that takes an import() argument which is a function and returns a new function that will\n// proxy arguments from the caller to the imported function, retaining all type\n// information along the way\nexport function lazyFn<\n  T extends Record<string, (...args: any[]) => any>,\n  TKey extends keyof T = 'default',\n>(fn: () => Promise<T>, key?: TKey) {\n  return async (...args: Parameters<T[TKey]>): Promise<ReturnType<T[TKey]>> => {\n    const imported = await fn()\n    return imported[key || 'default'](...args)\n  }\n}\n"],"names":["componentTypes","Router","constructor","options","defaultPreloadDelay","context","undefined","stringifySearch","defaultStringifySearch","parseSearch","defaultParseSearch","routeTree","subscribers","Set","subscribe","eventType","fn","listener","add","delete","emit","routerEvent","forEach","type","lazyFn","key","args","imported"],"mappings":";;;;;;;;;;;;;;;;AAEA;;AAuBA;;AAoHO,MAAMA,cAAc,GAAG,CAC5B,WAAW,EACX,gBAAgB,EAChB,kBAAkB,EACV;AA8BH,MAAMC,MAAM,CAGjB;AAMA;AACA;AACA;EAEAC,WAAWA,CAACC,OAA0D,EAAE;IACtE,IAAI,CAACA,OAAO,GAAG;AACbC,MAAAA,mBAAmB,EAAE,EAAE;AACvBC,MAAAA,OAAO,EAAEC,SAAU;AACnB,MAAA,GAAGH,OAAO;AACVI,MAAAA,eAAe,EAAEJ,OAAO,EAAEI,eAAe,IAAIC,mCAAsB;AACnEC,MAAAA,WAAW,EAAEN,OAAO,EAAEM,WAAW,IAAIC,+BAAAA;KACtC,CAAA;AAED,IAAA,IAAI,CAACC,SAAS,GAAG,IAAI,CAACR,OAAO,CAACQ,SAAuB,CAAA;AACvD,GAAA;AAEAC,EAAAA,WAAW,GAAG,IAAIC,GAAG,EAA+B,CAAA;AAEpDC,EAAAA,SAAS,GAAGA,CACVC,SAAgB,EAChBC,EAAmC,KAChC;AACH,IAAA,MAAMC,QAA6B,GAAG;MACpCF,SAAS;AACTC,MAAAA,EAAAA;KACD,CAAA;AAED,IAAA,IAAI,CAACJ,WAAW,CAACM,GAAG,CAACD,QAAQ,CAAC,CAAA;AAE9B,IAAA,OAAO,MAAM;AACX,MAAA,IAAI,CAACL,WAAW,CAACO,MAAM,CAACF,QAAQ,CAAC,CAAA;KAClC,CAAA;GACF,CAAA;EAEDG,IAAI,GAAIC,WAAwB,IAAK;AACnC,IAAA,IAAI,CAACT,WAAW,CAACU,OAAO,CAAEL,QAAQ,IAAK;AACrC,MAAA,IAAIA,QAAQ,CAACF,SAAS,KAAKM,WAAW,CAACE,IAAI,EAAE;AAC3CN,QAAAA,QAAQ,CAACD,EAAE,CAACK,WAAW,CAAC,CAAA;AAC1B,OAAA;AACF,KAAC,CAAC,CAAA;GACH,CAAA;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACF,CAAA;;AASA;AACA;AACA;AACO,SAASG,MAAMA,CAGpBR,EAAoB,EAAES,GAAU,EAAE;EAClC,OAAO,OAAO,GAAGC,IAAyB,KAAmC;AAC3E,IAAA,MAAMC,QAAQ,GAAG,MAAMX,EAAE,EAAE,CAAA;IAC3B,OAAOW,QAAQ,CAACF,GAAG,IAAI,SAAS,CAAC,CAAC,GAAGC,IAAI,CAAC,CAAA;GAC3C,CAAA;AACH;;;;;;"}