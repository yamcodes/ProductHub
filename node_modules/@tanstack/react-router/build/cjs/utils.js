/**
 * @tanstack/react-router/src/index.tsx
 *
 * Copyright (c) TanStack
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var Matches = require('./Matches.js');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var React__namespace = /*#__PURE__*/_interopNamespace(React);

// export type Expand<T> = T

// type Compute<T> = { [K in keyof T]: T[K] } | never

// type AllKeys<T> = T extends any ? keyof T : never

// export type MergeUnion<T, Keys extends keyof T = keyof T> = Compute<
//   {
//     [K in Keys]: T[Keys]
//   } & {
//     [K in AllKeys<T>]?: T extends any
//       ? K extends keyof T
//         ? T[K]
//         : never
//       : never
//   }
// >
// // Sample types to merge
// type TypeA = {
//   shared: string
//   onlyInA: string
//   nested: {
//     shared: string
//     aProp: string
//   }
//   array: string[]
// }
// type TypeB = {
//   shared: number
//   onlyInB: number
//   nested: {
//     shared: number
//     bProp: number
//   }
//   array: number[]
// }
// type TypeC = {
//   shared: boolean
//   onlyInC: boolean
//   nested: {
//     shared: boolean
//     cProp: boolean
//   }
//   array: boolean[]
// }
// type Test = Expand<Assign<TypeA, TypeB>>
// // Using DeepMerge to merge TypeA and TypeB
// type MergedType = Expand<AssignAll<[TypeA, TypeB, TypeC]>>
//

const isServer = typeof document === 'undefined';
function last(arr) {
  return arr[arr.length - 1];
}
function isFunction(d) {
  return typeof d === 'function';
}
function functionalUpdate(updater, previous) {
  if (isFunction(updater)) {
    return updater(previous);
  }
  return updater;
}
function pick(parent, keys) {
  return keys.reduce((obj, key) => {
    obj[key] = parent[key];
    return obj;
  }, {});
}

/**
 * This function returns `a` if `b` is deeply equal.
 * If not, it will replace any deeply equal children of `b` with those of `a`.
 * This can be used for structural sharing between immutable JSON values for example.
 * Do not use this with signals
 */
function replaceEqualDeep(prev, _next) {
  if (prev === _next) {
    return prev;
  }
  const next = _next;
  const array = Array.isArray(prev) && Array.isArray(next);
  if (array || isPlainObject(prev) && isPlainObject(next)) {
    const prevSize = array ? prev.length : Object.keys(prev).length;
    const nextItems = array ? next : Object.keys(next);
    const nextSize = nextItems.length;
    const copy = array ? [] : {};
    let equalItems = 0;
    for (let i = 0; i < nextSize; i++) {
      const key = array ? i : nextItems[i];
      copy[key] = replaceEqualDeep(prev[key], next[key]);
      if (copy[key] === prev[key]) {
        equalItems++;
      }
    }
    return prevSize === nextSize && equalItems === prevSize ? prev : copy;
  }
  return next;
}

// Copied from: https://github.com/jonschlinkert/is-plain-object
function isPlainObject(o) {
  if (!hasObjectPrototype(o)) {
    return false;
  }

  // If has modified constructor
  const ctor = o.constructor;
  if (typeof ctor === 'undefined') {
    return true;
  }

  // If has modified prototype
  const prot = ctor.prototype;
  if (!hasObjectPrototype(prot)) {
    return false;
  }

  // If constructor does not have an Object-specific method
  if (!prot.hasOwnProperty('isPrototypeOf')) {
    return false;
  }

  // Most likely a plain Object
  return true;
}
function hasObjectPrototype(o) {
  return Object.prototype.toString.call(o) === '[object Object]';
}
function partialDeepEqual(a, b) {
  if (a === b) {
    return true;
  }
  if (typeof a !== typeof b) {
    return false;
  }
  if (isPlainObject(a) && isPlainObject(b)) {
    return !Object.keys(b).some(key => !partialDeepEqual(a[key], b[key]));
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    return !(a.length !== b.length || a.some((item, index) => !partialDeepEqual(item, b[index])));
  }
  return false;
}
function useStableCallback(fn) {
  const fnRef = React__namespace.useRef(fn);
  fnRef.current = fn;
  const ref = React__namespace.useRef((...args) => fnRef.current(...args));
  return ref.current;
}
function shallow(objA, objB) {
  if (Object.is(objA, objB)) {
    return true;
  }
  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
    return false;
  }
  const keysA = Object.keys(objA);
  if (keysA.length !== Object.keys(objB).length) {
    return false;
  }
  for (let i = 0; i < keysA.length; i++) {
    if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !Object.is(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }
  return true;
}
function useRouteContext(opts) {
  return Matches.useMatch({
    ...opts,
    select: match => opts?.select ? opts.select(match.context) : match.context
  });
}
const useLayoutEffect = typeof window !== 'undefined' ? React__namespace.useLayoutEffect : React__namespace.useEffect;

exports.functionalUpdate = functionalUpdate;
exports.isPlainObject = isPlainObject;
exports.isServer = isServer;
exports.last = last;
exports.partialDeepEqual = partialDeepEqual;
exports.pick = pick;
exports.replaceEqualDeep = replaceEqualDeep;
exports.shallow = shallow;
exports.useLayoutEffect = useLayoutEffect;
exports.useRouteContext = useRouteContext;
exports.useStableCallback = useStableCallback;
//# sourceMappingURL=utils.js.map
