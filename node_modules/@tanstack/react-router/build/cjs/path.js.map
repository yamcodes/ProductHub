{"version":3,"file":"path.js","sources":["../../src/path.ts"],"sourcesContent":["import { MatchLocation } from './RouterProvider'\nimport { AnyPathParams } from './route'\nimport { last } from './utils'\n\nexport interface Segment {\n  type: 'pathname' | 'param' | 'wildcard'\n  value: string\n}\n\nexport function joinPaths(paths: (string | undefined)[]) {\n  return cleanPath(paths.filter(Boolean).join('/'))\n}\n\nexport function cleanPath(path: string) {\n  // remove double slashes\n  return path.replace(/\\/{2,}/g, '/')\n}\n\nexport function trimPathLeft(path: string) {\n  return path === '/' ? path : path.replace(/^\\/{1,}/, '')\n}\n\nexport function trimPathRight(path: string) {\n  return path === '/' ? path : path.replace(/\\/{1,}$/, '')\n}\n\nexport function trimPath(path: string) {\n  return trimPathRight(trimPathLeft(path))\n}\n\nexport function resolvePath(basepath: string, base: string, to: string) {\n  base = base.replace(new RegExp(`^${basepath}`), '/')\n  to = to.replace(new RegExp(`^${basepath}`), '/')\n\n  let baseSegments = parsePathname(base)\n  const toSegments = parsePathname(to)\n\n  toSegments.forEach((toSegment, index) => {\n    if (toSegment.value === '/') {\n      if (!index) {\n        // Leading slash\n        baseSegments = [toSegment]\n      } else if (index === toSegments.length - 1) {\n        // Trailing Slash\n        baseSegments.push(toSegment)\n      } else {\n        // ignore inter-slashes\n      }\n    } else if (toSegment.value === '..') {\n      // Extra trailing slash? pop it off\n      if (baseSegments.length > 1 && last(baseSegments)?.value === '/') {\n        baseSegments.pop()\n      }\n      baseSegments.pop()\n    } else if (toSegment.value === '.') {\n      return\n    } else {\n      baseSegments.push(toSegment)\n    }\n  })\n\n  const joined = joinPaths([basepath, ...baseSegments.map((d) => d.value)])\n\n  return cleanPath(joined)\n}\n\nexport function parsePathname(pathname?: string): Segment[] {\n  if (!pathname) {\n    return []\n  }\n\n  pathname = cleanPath(pathname)\n\n  const segments: Segment[] = []\n\n  if (pathname.slice(0, 1) === '/') {\n    pathname = pathname.substring(1)\n    segments.push({\n      type: 'pathname',\n      value: '/',\n    })\n  }\n\n  if (!pathname) {\n    return segments\n  }\n\n  // Remove empty segments and '.' segments\n  const split = pathname.split('/').filter(Boolean)\n\n  segments.push(\n    ...split.map((part): Segment => {\n      if (part === '$' || part === '*') {\n        return {\n          type: 'wildcard',\n          value: part,\n        }\n      }\n\n      if (part.charAt(0) === '$') {\n        return {\n          type: 'param',\n          value: part,\n        }\n      }\n\n      return {\n        type: 'pathname',\n        value: part,\n      }\n    }),\n  )\n\n  if (pathname.slice(-1) === '/') {\n    pathname = pathname.substring(1)\n    segments.push({\n      type: 'pathname',\n      value: '/',\n    })\n  }\n\n  return segments\n}\n\nexport function interpolatePath(\n  path: string | undefined,\n  params: any,\n  leaveWildcards: boolean = false,\n) {\n  const interpolatedPathSegments = parsePathname(path)\n\n  return joinPaths(\n    interpolatedPathSegments.map((segment) => {\n      if (segment.type === 'wildcard') {\n        const value = params[segment.value]\n        if (leaveWildcards) return `${segment.value}${value ?? ''}`\n        return value\n      }\n\n      if (segment.type === 'param') {\n        return params![segment.value.substring(1)] ?? ''\n      }\n\n      return segment.value\n    }),\n  )\n}\n\nexport function matchPathname(\n  basepath: string,\n  currentPathname: string,\n  matchLocation: Pick<MatchLocation, 'to' | 'fuzzy' | 'caseSensitive'>,\n): AnyPathParams | undefined {\n  const pathParams = matchByPath(basepath, currentPathname, matchLocation)\n  // const searchMatched = matchBySearch(location.search, matchLocation)\n\n  if (matchLocation.to && !pathParams) {\n    return\n  }\n\n  return pathParams ?? {}\n}\n\nexport function matchByPath(\n  basepath: string,\n  from: string,\n  matchLocation: Pick<MatchLocation, 'to' | 'caseSensitive' | 'fuzzy'>,\n): Record<string, string> | undefined {\n  // Remove the base path from the pathname\n  from = basepath != '/' ? from.substring(basepath.length) : from\n  // Default to to $ (wildcard)\n  const to = `${matchLocation.to ?? '$'}`\n  // Parse the from and to\n  const baseSegments = parsePathname(from)\n  const routeSegments = parsePathname(to)\n\n  if (!from.startsWith('/')) {\n    baseSegments.unshift({\n      type: 'pathname',\n      value: '/',\n    })\n  }\n\n  if (!to.startsWith('/')) {\n    routeSegments.unshift({\n      type: 'pathname',\n      value: '/',\n    })\n  }\n\n  const params: Record<string, string> = {}\n\n  let isMatch = (() => {\n    for (\n      let i = 0;\n      i < Math.max(baseSegments.length, routeSegments.length);\n      i++\n    ) {\n      const baseSegment = baseSegments[i]\n      const routeSegment = routeSegments[i]\n\n      const isLastBaseSegment = i >= baseSegments.length - 1\n      const isLastRouteSegment = i >= routeSegments.length - 1\n\n      if (routeSegment) {\n        if (routeSegment.type === 'wildcard') {\n          if (baseSegment?.value) {\n            params['*'] = joinPaths(baseSegments.slice(i).map((d) => d.value))\n            return true\n          }\n          return false\n        }\n\n        if (routeSegment.type === 'pathname') {\n          if (routeSegment.value === '/' && !baseSegment?.value) {\n            return true\n          }\n\n          if (baseSegment) {\n            if (matchLocation.caseSensitive) {\n              if (routeSegment.value !== baseSegment.value) {\n                return false\n              }\n            } else if (\n              routeSegment.value.toLowerCase() !==\n              baseSegment.value.toLowerCase()\n            ) {\n              return false\n            }\n          }\n        }\n\n        if (!baseSegment) {\n          return false\n        }\n\n        if (routeSegment.type === 'param') {\n          if (baseSegment?.value === '/') {\n            return false\n          }\n          if (baseSegment.value.charAt(0) !== '$') {\n            params[routeSegment.value.substring(1)] = baseSegment.value\n          }\n        }\n      }\n\n      if (!isLastBaseSegment && isLastRouteSegment) {\n        return !!matchLocation.fuzzy\n      }\n    }\n\n    return true\n  })()\n\n  return isMatch ? (params as Record<string, string>) : undefined\n}\n"],"names":["joinPaths","paths","cleanPath","filter","Boolean","join","path","replace","trimPathLeft","trimPathRight","trimPath","resolvePath","basepath","base","to","RegExp","baseSegments","parsePathname","toSegments","forEach","toSegment","index","value","length","push","last","pop","joined","map","d","pathname","segments","slice","substring","type","split","part","charAt","interpolatePath","params","leaveWildcards","interpolatedPathSegments","segment","matchPathname","currentPathname","matchLocation","pathParams","matchByPath","from","routeSegments","startsWith","unshift","isMatch","i","Math","max","baseSegment","routeSegment","isLastBaseSegment","isLastRouteSegment","caseSensitive","toLowerCase","fuzzy","undefined"],"mappings":"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"}