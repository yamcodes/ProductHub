/**
 * @tanstack/react-router/src/index.tsx
 *
 * Copyright (c) TanStack
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var invariant = require('tiny-invariant');
var Matches = require('./Matches.js');
var path = require('./path.js');
var useParams = require('./useParams.js');
var useSearch = require('./useSearch.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var invariant__default = /*#__PURE__*/_interopDefaultLegacy(invariant);

const rootRouteId = '__root__';

// The parse type here allows a zod schema to be passed directly to the validator

class Route {
  // Set up in this.init()

  // customId!: TCustomId

  // Optional

  constructor(options) {
    this.options = options || {};
    this.isRoot = !options?.getParentRoute;
    Route.__onInit(this);
  }
  init = opts => {
    this.originalIndex = opts.originalIndex;
    const options = this.options;
    const isRoot = !options?.path && !options?.id;
    this.parentRoute = this.options?.getParentRoute?.();
    if (isRoot) {
      this.path = rootRouteId;
    } else {
      invariant__default["default"](this.parentRoute, `Child Route instances must pass a 'getParentRoute: () => ParentRoute' option that returns a Route instance.`);
    }
    let path$1 = isRoot ? rootRouteId : options.path;

    // If the path is anything other than an index path, trim it up
    if (path$1 && path$1 !== '/') {
      path$1 = path.trimPath(path$1);
    }
    const customId = options?.id || path$1;

    // Strip the parentId prefix from the first level of children
    let id = isRoot ? rootRouteId : path.joinPaths([this.parentRoute.id === rootRouteId ? '' : this.parentRoute.id, customId]);
    if (path$1 === rootRouteId) {
      path$1 = '/';
    }
    if (id !== rootRouteId) {
      id = path.joinPaths(['/', id]);
    }
    const fullPath = id === rootRouteId ? '/' : path.joinPaths([this.parentRoute.fullPath, path$1]);
    this.path = path$1;
    this.id = id;
    // this.customId = customId as TCustomId
    this.fullPath = fullPath;
    this.to = fullPath;
  };
  addChildren = children => {
    this.children = children;
    return this;
  };
  update = options => {
    Object.assign(this.options, options);
    return this;
  };
  static __onInit = route => {
    // This is a dummy static method that should get
    // replaced by a framework specific implementation if necessary
  };
  useMatch = opts => {
    return Matches.useMatch({
      ...opts,
      from: this.id
    });
  };
  useRouteContext = opts => {
    return Matches.useMatch({
      ...opts,
      from: this.id,
      select: d => opts?.select ? opts.select(d.context) : d.context
    });
  };
  useSearch = opts => {
    return useSearch.useSearch({
      ...opts,
      from: this.id
    });
  };
  useParams = opts => {
    return useParams.useParams({
      ...opts,
      from: this.id
    });
  };
}
function rootRouteWithContext() {
  return options => {
    return new RootRoute(options);
  };
}
class RootRoute extends Route {
  constructor(options) {
    super(options);
  }
}
function createRouteMask(opts) {
  return opts;
}

//

exports.RootRoute = RootRoute;
exports.Route = Route;
exports.createRouteMask = createRouteMask;
exports.rootRouteId = rootRouteId;
exports.rootRouteWithContext = rootRouteWithContext;
//# sourceMappingURL=route.js.map
