/**
 * @tanstack/react-router/src/index.tsx
 *
 * Copyright (c) TanStack
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var invariant = require('tiny-invariant');
var warning = require('tiny-warning');
var CatchBoundary = require('./CatchBoundary.js');
var RouterProvider = require('./RouterProvider.js');
var route = require('./route.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var React__namespace = /*#__PURE__*/_interopNamespace(React);
var invariant__default = /*#__PURE__*/_interopDefaultLegacy(invariant);
var warning__default = /*#__PURE__*/_interopDefaultLegacy(warning);

function Matches() {
  const {
    routesById,
    state
  } = RouterProvider.useRouter();
  const {
    matches
  } = state;
  const locationKey = RouterProvider.useRouterState().location.state.key;
  const route$1 = routesById[route.rootRouteId];
  const errorComponent = React__namespace.useCallback(props => {
    return /*#__PURE__*/React__namespace.createElement(CatchBoundary.ErrorComponent, {
      ...props,
      useMatch: route$1.useMatch,
      useRouteContext: route$1.useRouteContext,
      useSearch: route$1.useSearch,
      useParams: route$1.useParams
    });
  }, [route$1]);
  return /*#__PURE__*/React__namespace.createElement(matchesContext.Provider, {
    value: matches
  }, /*#__PURE__*/React__namespace.createElement(CatchBoundary.CatchBoundary, {
    resetKey: locationKey,
    errorComponent: errorComponent,
    onCatch: () => {
      warning__default["default"](false, `Error in router! Consider setting an 'errorComponent' in your RootRoute! ðŸ‘`);
    }
  }, matches.length ? /*#__PURE__*/React__namespace.createElement(Match, {
    matches: matches
  }) : null));
}
const defaultPending = () => null;
function Match({
  matches
}) {
  const {
    options,
    routesById
  } = RouterProvider.useRouter();
  const match = matches[0];
  const routeId = match?.routeId;
  const route = routesById[routeId];
  const locationKey = RouterProvider.useRouterState().location.state?.key;
  const PendingComponent = route.options.pendingComponent ?? options.defaultPendingComponent ?? defaultPending;
  const routeErrorComponent = route.options.errorComponent ?? options.defaultErrorComponent ?? CatchBoundary.ErrorComponent;
  const ResolvedSuspenseBoundary = route.options.wrapInSuspense ?? React__namespace.Suspense;
  // const ResolvedSuspenseBoundary = SafeFragment

  const errorComponent = React__namespace.useCallback(props => {
    return /*#__PURE__*/React__namespace.createElement(routeErrorComponent, {
      ...props,
      useMatch: route.useMatch,
      useRouteContext: route.useRouteContext,
      useSearch: route.useSearch,
      useParams: route.useParams
    });
  }, [route]);
  return /*#__PURE__*/React__namespace.createElement(matchesContext.Provider, {
    value: matches
  }, /*#__PURE__*/React__namespace.createElement(ResolvedSuspenseBoundary, {
    fallback: /*#__PURE__*/React__namespace.createElement(PendingComponent, {
      useMatch: route.useMatch,
      useRouteContext: route.useRouteContext,
      useSearch: route.useSearch,
      useParams: route.useParams
    })
  }, /*#__PURE__*/React__namespace.createElement(CatchBoundary.CatchBoundary, {
    resetKey: locationKey,
    errorComponent: errorComponent,
    onCatch: () => {
      warning__default["default"](false, `Error in route match: ${match.id}`);
    }
  }, /*#__PURE__*/React__namespace.createElement(MatchInner, {
    match: match
  }))));
}
function MatchInner({
  match
}) {
  const {
    options,
    routesById
  } = RouterProvider.useRouter();
  const route = routesById[match.routeId];
  if (match.status === 'error') {
    throw match.error;
  }
  if (match.status === 'pending') {
    throw match.loadPromise;
  }
  if (match.status === 'success') {
    let comp = route.options.component ?? options.defaultComponent;
    if (comp) {
      return /*#__PURE__*/React__namespace.createElement(comp, {
        useMatch: route.useMatch,
        useRouteContext: route.useRouteContext,
        useSearch: route.useSearch,
        useParams: route.useParams
      });
    }
    return /*#__PURE__*/React__namespace.createElement(Outlet, null);
  }
  invariant__default["default"](false, 'Idle routeMatch status encountered during rendering! You should never see this. File an issue!');
}
function Outlet() {
  const matches = React__namespace.useContext(matchesContext).slice(1);
  if (!matches[0]) {
    return null;
  }
  return /*#__PURE__*/React__namespace.createElement(Match, {
    matches: matches
  });
}
function useMatchRoute() {
  const {
    matchRoute
  } = RouterProvider.useRouter();
  return React__namespace.useCallback(opts => {
    const {
      pending,
      caseSensitive,
      ...rest
    } = opts;
    return matchRoute(rest, {
      pending,
      caseSensitive
    });
  }, []);
}
function MatchRoute(props) {
  const matchRoute = useMatchRoute();
  const params = matchRoute(props);
  if (typeof props.children === 'function') {
    return props.children(params);
  }
  return !!params ? props.children : null;
}
function useMatch(opts) {
  const nearestMatch = React__namespace.useContext(matchesContext)[0];
  const nearestMatchRouteId = nearestMatch?.routeId;
  const matchRouteId = RouterProvider.useRouterState({
    select: state => {
      const match = opts?.from ? state.matches.find(d => d.routeId === opts?.from) : state.matches.find(d => d.id === nearestMatch.id);
      return match.routeId;
    }
  });
  if (opts?.strict ?? true) {
    invariant__default["default"](nearestMatchRouteId == matchRouteId, `useMatch("${matchRouteId}") is being called in a component that is meant to render the '${nearestMatchRouteId}' route. Did you mean to 'useMatch("${matchRouteId}", { strict: false })' or 'useRoute("${matchRouteId}")' instead?`);
  }
  const matchSelection = RouterProvider.useRouterState({
    select: state => {
      const match = opts?.from ? state.matches.find(d => d.routeId === opts?.from) : state.matches.find(d => d.id === nearestMatch.id);
      invariant__default["default"](match, `Could not find ${opts?.from ? `an active match from "${opts.from}"` : 'a nearest match!'}`);
      return opts?.select ? opts.select(match) : match;
    }
  });
  return matchSelection;
}
const matchesContext = /*#__PURE__*/React__namespace.createContext(null);
function useMatches(opts) {
  const contextMatches = React__namespace.useContext(matchesContext);
  return RouterProvider.useRouterState({
    select: state => {
      const matches = state.matches.slice(state.matches.findIndex(d => d.id === contextMatches[0]?.id));
      return opts?.select ? opts.select(matches) : matches;
    }
  });
}

exports.Match = Match;
exports.MatchRoute = MatchRoute;
exports.Matches = Matches;
exports.Outlet = Outlet;
exports.matchesContext = matchesContext;
exports.useMatch = useMatch;
exports.useMatchRoute = useMatchRoute;
exports.useMatches = useMatches;
//# sourceMappingURL=Matches.js.map
