{"version":3,"file":"link.js","sources":["../../src/link.tsx"],"sourcesContent":["import * as React from 'react'\nimport { useMatch } from './Matches'\nimport { useRouter } from './RouterProvider'\nimport { Trim } from './fileRoute'\nimport { LocationState, ParsedLocation } from './location'\nimport { AnyRoute, ReactNode } from './route'\nimport {\n  AllParams,\n  FullSearchSchema,\n  RouteByPath,\n  RouteIds,\n  RoutePaths,\n} from './routeInfo'\nimport { RegisteredRouter } from './router'\nimport { MakeLinkOptions, MakeLinkPropsOptions } from './useNavigate'\nimport {\n  Expand,\n  NoInfer,\n  NonNullableUpdater,\n  PickRequired,\n  UnionToIntersection,\n  Updater,\n  functionalUpdate,\n} from './utils'\n\nexport type LinkInfo =\n  | {\n      type: 'external'\n      href: string\n    }\n  | {\n      type: 'internal'\n      next: ParsedLocation\n      handleFocus: (e: any) => void\n      handleClick: (e: any) => void\n      handleEnter: (e: any) => void\n      handleLeave: (e: any) => void\n      handleTouchStart: (e: any) => void\n      isActive: boolean\n      disabled?: boolean\n    }\n\nexport type CleanPath<T extends string> = T extends `${infer L}//${infer R}`\n  ? CleanPath<`${CleanPath<L>}/${CleanPath<R>}`>\n  : T extends `${infer L}//`\n  ? `${CleanPath<L>}/`\n  : T extends `//${infer L}`\n  ? `/${CleanPath<L>}`\n  : T\n\nexport type Split<S, TIncludeTrailingSlash = true> = S extends unknown\n  ? string extends S\n    ? string[]\n    : S extends string\n    ? CleanPath<S> extends ''\n      ? []\n      : TIncludeTrailingSlash extends true\n      ? CleanPath<S> extends `${infer T}/`\n        ? [...Split<T>, '/']\n        : CleanPath<S> extends `/${infer U}`\n        ? Split<U>\n        : CleanPath<S> extends `${infer T}/${infer U}`\n        ? [...Split<T>, ...Split<U>]\n        : [S]\n      : CleanPath<S> extends `${infer T}/${infer U}`\n      ? [...Split<T>, ...Split<U>]\n      : S extends string\n      ? [S]\n      : never\n    : never\n  : never\n\nexport type ParsePathParams<T extends string> = keyof {\n  [K in Trim<Split<T>[number], '_'> as K extends `$${infer L}` ? L : never]: K\n}\n\nexport type Join<T, Delimiter extends string = '/'> = T extends []\n  ? ''\n  : T extends [infer L extends string]\n  ? L\n  : T extends [infer L extends string, ...infer Tail extends [...string[]]]\n  ? CleanPath<`${L}${Delimiter}${Join<Tail>}`>\n  : never\n\nexport type Last<T extends any[]> = T extends [...infer _, infer L] ? L : never\n\nexport type RelativeToPathAutoComplete<\n  AllPaths extends string,\n  TFrom extends string,\n  TTo extends string,\n  SplitPaths extends string[] = Split<AllPaths, false>,\n> = TTo extends `..${infer _}`\n  ? SplitPaths extends [\n      ...Split<ResolveRelativePath<TFrom, TTo>, false>,\n      ...infer TToRest,\n    ]\n    ? `${CleanPath<\n        Join<\n          [\n            ...Split<TTo, false>,\n            ...(\n              | TToRest\n              | (Split<\n                  ResolveRelativePath<TFrom, TTo>,\n                  false\n                >['length'] extends 1\n                  ? never\n                  : ['../'])\n            ),\n          ]\n        >\n      >}`\n    : never\n  : TTo extends `./${infer RestTTo}`\n  ? SplitPaths extends [\n      ...Split<TFrom, false>,\n      ...Split<RestTTo, false>,\n      ...infer RestPath,\n    ]\n    ? `${TTo}${Join<RestPath>}`\n    : never\n  :\n      | (TFrom extends `/`\n          ? never\n          : SplitPaths extends [...Split<TFrom, false>, ...infer RestPath]\n          ? Join<RestPath> extends { length: 0 }\n            ? never\n            : './'\n          : never)\n      | (TFrom extends `/` ? never : '../')\n      | AllPaths\n\nexport type NavigateOptions<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = TFrom,\n  TMaskTo extends string = '',\n> = ToOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> & {\n  // `replace` is a boolean that determines whether the navigation should replace the current history entry or push a new one.\n  replace?: boolean\n  resetScroll?: boolean\n  // If set to `true`, the link's underlying navigate() call will be wrapped in a `React.startTransition` call. Defaults to `true`.\n  startTransition?: boolean\n}\n\nexport type ToOptions<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = '/',\n  TMaskTo extends string = '',\n> = ToSubOptions<TRouteTree, TFrom, TTo> & {\n  mask?: ToMaskOptions<TRouteTree, TMaskFrom, TMaskTo>\n}\n\nexport type ToMaskOptions<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TMaskFrom extends RoutePaths<TRouteTree> = '/',\n  TMaskTo extends string = '',\n> = ToSubOptions<TRouteTree, TMaskFrom, TMaskTo> & {\n  unmaskOnReload?: boolean\n}\n\nexport type ToSubOptions<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TResolved = ResolveRelativePath<TFrom, NoInfer<TTo>>,\n> = {\n  to?: ToPathOption<TRouteTree, TFrom, TTo>\n  // The new has string or a function to update it\n  hash?: true | Updater<string>\n  // State to pass to the history stack\n  state?: true | NonNullableUpdater<LocationState>\n  // The source route path. This is automatically set when using route-level APIs, but for type-safe relative routing on the router itself, this is required\n  from?: TFrom\n  // // When using relative route paths, this option forces resolution from the current path, instead of the route API's path or `from` path\n  // fromCurrent?: boolean\n} & CheckPath<TRouteTree, NoInfer<TResolved>, {}> &\n  SearchParamOptions<TRouteTree, TFrom, TTo, TResolved> &\n  PathParamOptions<TRouteTree, TFrom, TResolved>\n\nexport type SearchParamOptions<\n  TRouteTree extends AnyRoute,\n  TFrom,\n  TTo,\n  TResolved = ResolveRelativePath<TFrom, NoInfer<TTo>>,\n  TFromSearchEnsured = '/' extends TFrom\n    ? FullSearchSchema<TRouteTree>\n    : Expand<\n        UnionToIntersection<\n          PickRequired<\n            RouteByPath<TRouteTree, TFrom>['types']['fullSearchSchema']\n          >\n        >\n      >,\n  TFromSearchOptional = Omit<AllParams<TRouteTree>, keyof TFromSearchEnsured>,\n  TFromSearch = Expand<TFromSearchEnsured & TFromSearchOptional>,\n  TToSearch = '' extends TTo\n    ? FullSearchSchema<TRouteTree>\n    : Expand<RouteByPath<TRouteTree, TResolved>['types']['fullSearchSchema']>,\n> = keyof PickRequired<TToSearch> extends never\n  ? {\n      search?: true | SearchReducer<TFromSearch, TToSearch>\n    }\n  : {\n      search: TFromSearchEnsured extends PickRequired<TToSearch>\n        ? true | SearchReducer<TFromSearch, TToSearch>\n        : SearchReducer<TFromSearch, TToSearch>\n    }\n\ntype SearchReducer<TFrom, TTo> = TTo | ((current: TFrom) => TTo)\n\nexport type PathParamOptions<\n  TRouteTree extends AnyRoute,\n  TFrom,\n  TTo,\n  TFromParamsEnsured = Expand<\n    UnionToIntersection<\n      PickRequired<RouteByPath<TRouteTree, TFrom>['types']['allParams']>\n    >\n  >,\n  TFromParamsOptional = Omit<AllParams<TRouteTree>, keyof TFromParamsEnsured>,\n  TFromParams = Expand<TFromParamsOptional & TFromParamsEnsured>,\n  TToParams = Expand<RouteByPath<TRouteTree, TTo>['types']['allParams']>,\n> = keyof PickRequired<TToParams> extends never\n  ? {\n      params?: true | ParamsReducer<TFromParams, TToParams>\n    }\n  : {\n      params: TFromParamsEnsured extends PickRequired<TToParams>\n        ? true | ParamsReducer<TFromParams, TToParams>\n        : ParamsReducer<TFromParams, TToParams>\n    }\n\ntype ParamsReducer<TFrom, TTo> = TTo | ((current: TFrom) => TTo)\n\nexport type ToPathOption<\n  TRouteTree extends AnyRoute = AnyRoute,\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n> =\n  | TTo\n  | RelativeToPathAutoComplete<\n      RoutePaths<TRouteTree>,\n      NoInfer<TFrom> extends string ? NoInfer<TFrom> : '',\n      NoInfer<TTo> & string\n    >\n\nexport type ToIdOption<\n  TRouteTree extends AnyRoute = AnyRoute,\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n> =\n  | TTo\n  | RelativeToPathAutoComplete<\n      RouteIds<TRouteTree>,\n      NoInfer<TFrom> extends string ? NoInfer<TFrom> : '',\n      NoInfer<TTo> & string\n    >\n\nexport interface ActiveOptions {\n  exact?: boolean\n  includeHash?: boolean\n  includeSearch?: boolean\n}\n\nexport type LinkOptions<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = TFrom,\n  TMaskTo extends string = '',\n> = NavigateOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> & {\n  // The standard anchor tag target attribute\n  target?: HTMLAnchorElement['target']\n  // Defaults to `{ exact: false, includeHash: false }`\n  activeOptions?: ActiveOptions\n  // If set, will preload the linked route on hover and cache it for this many milliseconds in hopes that the user will eventually navigate there.\n  preload?: false | 'intent'\n  // Delay intent preloading by this many milliseconds. If the intent exits before this delay, the preload will be cancelled.\n  preloadDelay?: number\n  // If true, will render the link without the href attribute\n  disabled?: boolean\n}\n\nexport type CheckRelativePath<\n  TRouteTree extends AnyRoute,\n  TFrom,\n  TTo,\n> = TTo extends string\n  ? TFrom extends string\n    ? ResolveRelativePath<TFrom, TTo> extends RoutePaths<TRouteTree>\n      ? {}\n      : {\n          Error: `${TFrom} + ${TTo} resolves to ${ResolveRelativePath<\n            TFrom,\n            TTo\n          >}, which is not a valid route path.`\n          'Valid Route Paths': RoutePaths<TRouteTree>\n        }\n    : {}\n  : {}\n\nexport type CheckPath<TRouteTree extends AnyRoute, TPath, TPass> = Exclude<\n  TPath,\n  RoutePaths<TRouteTree>\n> extends never\n  ? TPass\n  : CheckPathError<TRouteTree, Exclude<TPath, RoutePaths<TRouteTree>>>\n\nexport type CheckPathError<TRouteTree extends AnyRoute, TInvalids> = {\n  to: RoutePaths<TRouteTree>\n}\n\nexport type CheckId<TRouteTree extends AnyRoute, TPath, TPass> = Exclude<\n  TPath,\n  RouteIds<TRouteTree>\n> extends never\n  ? TPass\n  : CheckIdError<TRouteTree, Exclude<TPath, RouteIds<TRouteTree>>>\n\nexport type CheckIdError<TRouteTree extends AnyRoute, TInvalids> = {\n  Error: `${TInvalids extends string\n    ? TInvalids\n    : never} is not a valid route ID.`\n  'Valid Route IDs': RouteIds<TRouteTree>\n}\n\nexport type ResolveRelativePath<TFrom, TTo = '.'> = TFrom extends string\n  ? TTo extends string\n    ? TTo extends '.'\n      ? TFrom\n      : TTo extends `./`\n      ? Join<[TFrom, '/']>\n      : TTo extends `./${infer TRest}`\n      ? ResolveRelativePath<TFrom, TRest>\n      : TTo extends `/${infer TRest}`\n      ? TTo\n      : Split<TTo> extends ['..', ...infer ToRest]\n      ? Split<TFrom> extends [...infer FromRest, infer FromTail]\n        ? ToRest extends ['/']\n          ? Join<[...FromRest, '/']>\n          : ResolveRelativePath<Join<FromRest>, Join<ToRest>>\n        : never\n      : Split<TTo> extends ['.', ...infer ToRest]\n      ? ToRest extends ['/']\n        ? Join<[TFrom, '/']>\n        : ResolveRelativePath<TFrom, Join<ToRest>>\n      : CleanPath<Join<['/', ...Split<TFrom>, ...Split<TTo>]>>\n    : never\n  : never\n\nexport function useLinkProps<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = '/',\n  TMaskTo extends string = '',\n>(\n  options: MakeLinkPropsOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>,\n): React.AnchorHTMLAttributes<HTMLAnchorElement> {\n  const { buildLink } = useRouter()\n  const match = useMatch({\n    strict: false,\n  })\n\n  const {\n    // custom props\n    type,\n    children,\n    target,\n    activeProps = () => ({ className: 'active' }),\n    inactiveProps = () => ({}),\n    activeOptions,\n    disabled,\n    hash,\n    search,\n    params,\n    to,\n    state,\n    mask,\n    preload,\n    preloadDelay,\n    replace,\n    startTransition,\n    resetScroll,\n    // element props\n    style,\n    className,\n    onClick,\n    onFocus,\n    onMouseEnter,\n    onMouseLeave,\n    onTouchStart,\n    ...rest\n  } = options\n\n  const linkInfo = buildLink({\n    from: options.to ? match.pathname : undefined,\n    ...options,\n  } as any)\n\n  if (linkInfo.type === 'external') {\n    const { href } = linkInfo\n    return { href }\n  }\n\n  const {\n    handleClick,\n    handleFocus,\n    handleEnter,\n    handleLeave,\n    handleTouchStart,\n    isActive,\n    next,\n  } = linkInfo\n\n  const composeHandlers =\n    (handlers: (undefined | ((e: any) => void))[]) =>\n    (e: React.SyntheticEvent) => {\n      if (e.persist) e.persist()\n      handlers.filter(Boolean).forEach((handler) => {\n        if (e.defaultPrevented) return\n        handler!(e)\n      })\n    }\n\n  // Get the active props\n  const resolvedActiveProps: React.HTMLAttributes<HTMLAnchorElement> = isActive\n    ? functionalUpdate(activeProps as any, {}) ?? {}\n    : {}\n\n  // Get the inactive props\n  const resolvedInactiveProps: React.HTMLAttributes<HTMLAnchorElement> =\n    isActive ? {} : functionalUpdate(inactiveProps, {}) ?? {}\n\n  return {\n    ...resolvedActiveProps,\n    ...resolvedInactiveProps,\n    ...rest,\n    href: disabled\n      ? undefined\n      : next.maskedLocation\n      ? next.maskedLocation.href\n      : next.href,\n    onClick: composeHandlers([onClick, handleClick]),\n    onFocus: composeHandlers([onFocus, handleFocus]),\n    onMouseEnter: composeHandlers([onMouseEnter, handleEnter]),\n    onMouseLeave: composeHandlers([onMouseLeave, handleLeave]),\n    onTouchStart: composeHandlers([onTouchStart, handleTouchStart]),\n    target,\n    style: {\n      ...style,\n      ...resolvedActiveProps.style,\n      ...resolvedInactiveProps.style,\n    },\n    className:\n      [\n        className,\n        resolvedActiveProps.className,\n        resolvedInactiveProps.className,\n      ]\n        .filter(Boolean)\n        .join(' ') || undefined,\n    ...(disabled\n      ? {\n          role: 'link',\n          'aria-disabled': true,\n        }\n      : undefined),\n    ['data-status']: isActive ? 'active' : undefined,\n  }\n}\n\nexport interface LinkComponent<TProps extends Record<string, any> = {}> {\n  <\n    TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n    TFrom extends RoutePaths<TRouteTree> = '/',\n    TTo extends string = '',\n    TMaskFrom extends RoutePaths<TRouteTree> = '/',\n    TMaskTo extends string = '',\n  >(\n    props: MakeLinkOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo> &\n      TProps &\n      React.RefAttributes<HTMLAnchorElement>,\n  ): ReactNode\n}\n\nexport const Link: LinkComponent = React.forwardRef((props: any, ref) => {\n  const linkProps = useLinkProps(props)\n\n  return (\n    <a\n      {...{\n        ref: ref as any,\n        ...linkProps,\n        children:\n          typeof props.children === 'function'\n            ? props.children({\n                isActive: (linkProps as any)['data-status'] === 'active',\n              })\n            : props.children,\n      }}\n    />\n  )\n}) as any\n"],"names":["useLinkProps","options","buildLink","useRouter","match","useMatch","strict","type","children","target","activeProps","className","inactiveProps","activeOptions","disabled","hash","search","params","to","state","mask","preload","preloadDelay","replace","startTransition","resetScroll","style","onClick","onFocus","onMouseEnter","onMouseLeave","onTouchStart","rest","linkInfo","from","pathname","undefined","href","handleClick","handleFocus","handleEnter","handleLeave","handleTouchStart","isActive","next","composeHandlers","handlers","e","persist","filter","Boolean","forEach","handler","defaultPrevented","resolvedActiveProps","functionalUpdate","resolvedInactiveProps","maskedLocation","join","role","Link","React","forwardRef","props","ref","linkProps","createElement","_extends"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkWO,SAASA,YAAYA,CAO1BC,OAAyE,EAC1B;EAC/C,MAAM;AAAEC,IAAAA,SAAAA;GAAW,GAAGC,wBAAS,EAAE,CAAA;EACjC,MAAMC,KAAK,GAAGC,gBAAQ,CAAC;AACrBC,IAAAA,MAAM,EAAE,KAAA;AACV,GAAC,CAAC,CAAA;EAEF,MAAM;AACJ;IACAC,IAAI;IACJC,QAAQ;IACRC,MAAM;IACNC,WAAW,GAAGA,OAAO;AAAEC,MAAAA,SAAS,EAAE,QAAA;AAAS,KAAC,CAAC;AAC7CC,IAAAA,aAAa,GAAGA,OAAO,EAAE,CAAC;IAC1BC,aAAa;IACbC,QAAQ;IACRC,IAAI;IACJC,MAAM;IACNC,MAAM;IACNC,EAAE;IACFC,KAAK;IACLC,IAAI;IACJC,OAAO;IACPC,YAAY;IACZC,OAAO;IACPC,eAAe;IACfC,WAAW;AACX;IACAC,KAAK;IACLf,SAAS;IACTgB,OAAO;IACPC,OAAO;IACPC,YAAY;IACZC,YAAY;IACZC,YAAY;IACZ,GAAGC,IAAAA;AACL,GAAC,GAAG/B,OAAO,CAAA;EAEX,MAAMgC,QAAQ,GAAG/B,SAAS,CAAC;IACzBgC,IAAI,EAAEjC,OAAO,CAACiB,EAAE,GAAGd,KAAK,CAAC+B,QAAQ,GAAGC,SAAS;IAC7C,GAAGnC,OAAAA;AACL,GAAQ,CAAC,CAAA;AAET,EAAA,IAAIgC,QAAQ,CAAC1B,IAAI,KAAK,UAAU,EAAE;IAChC,MAAM;AAAE8B,MAAAA,IAAAA;AAAK,KAAC,GAAGJ,QAAQ,CAAA;IACzB,OAAO;AAAEI,MAAAA,IAAAA;KAAM,CAAA;AACjB,GAAA;EAEA,MAAM;IACJC,WAAW;IACXC,WAAW;IACXC,WAAW;IACXC,WAAW;IACXC,gBAAgB;IAChBC,QAAQ;AACRC,IAAAA,IAAAA;AACF,GAAC,GAAGX,QAAQ,CAAA;AAEZ,EAAA,MAAMY,eAAe,GAClBC,QAA4C,IAC5CC,CAAuB,IAAK;IAC3B,IAAIA,CAAC,CAACC,OAAO,EAAED,CAAC,CAACC,OAAO,EAAE,CAAA;IAC1BF,QAAQ,CAACG,MAAM,CAACC,OAAO,CAAC,CAACC,OAAO,CAAEC,OAAO,IAAK;MAC5C,IAAIL,CAAC,CAACM,gBAAgB,EAAE,OAAA;MACxBD,OAAO,CAAEL,CAAC,CAAC,CAAA;AACb,KAAC,CAAC,CAAA;GACH,CAAA;;AAEH;AACA,EAAA,MAAMO,mBAA4D,GAAGX,QAAQ,GACzEY,sBAAgB,CAAC7C,WAAW,EAAS,EAAE,CAAC,IAAI,EAAE,GAC9C,EAAE,CAAA;;AAEN;AACA,EAAA,MAAM8C,qBAA8D,GAClEb,QAAQ,GAAG,EAAE,GAAGY,sBAAgB,CAAC3C,aAAa,EAAE,EAAE,CAAC,IAAI,EAAE,CAAA;EAE3D,OAAO;AACL,IAAA,GAAG0C,mBAAmB;AACtB,IAAA,GAAGE,qBAAqB;AACxB,IAAA,GAAGxB,IAAI;AACPK,IAAAA,IAAI,EAAEvB,QAAQ,GACVsB,SAAS,GACTQ,IAAI,CAACa,cAAc,GACnBb,IAAI,CAACa,cAAc,CAACpB,IAAI,GACxBO,IAAI,CAACP,IAAI;IACbV,OAAO,EAAEkB,eAAe,CAAC,CAAClB,OAAO,EAAEW,WAAW,CAAC,CAAC;IAChDV,OAAO,EAAEiB,eAAe,CAAC,CAACjB,OAAO,EAAEW,WAAW,CAAC,CAAC;IAChDV,YAAY,EAAEgB,eAAe,CAAC,CAAChB,YAAY,EAAEW,WAAW,CAAC,CAAC;IAC1DV,YAAY,EAAEe,eAAe,CAAC,CAACf,YAAY,EAAEW,WAAW,CAAC,CAAC;IAC1DV,YAAY,EAAEc,eAAe,CAAC,CAACd,YAAY,EAAEW,gBAAgB,CAAC,CAAC;IAC/DjC,MAAM;AACNiB,IAAAA,KAAK,EAAE;AACL,MAAA,GAAGA,KAAK;MACR,GAAG4B,mBAAmB,CAAC5B,KAAK;AAC5B,MAAA,GAAG8B,qBAAqB,CAAC9B,KAAAA;KAC1B;IACDf,SAAS,EACP,CACEA,SAAS,EACT2C,mBAAmB,CAAC3C,SAAS,EAC7B6C,qBAAqB,CAAC7C,SAAS,CAChC,CACEsC,MAAM,CAACC,OAAO,CAAC,CACfQ,IAAI,CAAC,GAAG,CAAC,IAAItB,SAAS;AAC3B,IAAA,IAAItB,QAAQ,GACR;AACE6C,MAAAA,IAAI,EAAE,MAAM;AACZ,MAAA,eAAe,EAAE,IAAA;KAClB,GACDvB,SAAS,CAAC;AACd,IAAA,CAAC,aAAa,GAAGO,QAAQ,GAAG,QAAQ,GAAGP,SAAAA;GACxC,CAAA;AACH,CAAA;AAgBO,MAAMwB,IAAmB,gBAAGC,gBAAK,CAACC,UAAU,CAAC,CAACC,KAAU,EAAEC,GAAG,KAAK;AACvE,EAAA,MAAMC,SAAS,GAAGjE,YAAY,CAAC+D,KAAK,CAAC,CAAA;AAErC,EAAA,oBACEF,gBAAA,CAAAK,aAAA,CAAA,GAAA,EAAAC,oCAAA,CAAA;AAEIH,IAAAA,GAAG,EAAEA,GAAAA;AAAU,GAAA,EACZC,SAAS,EAAA;IACZzD,QAAQ,EACN,OAAOuD,KAAK,CAACvD,QAAQ,KAAK,UAAU,GAChCuD,KAAK,CAACvD,QAAQ,CAAC;AACbmC,MAAAA,QAAQ,EAAGsB,SAAS,CAAS,aAAa,CAAC,KAAK,QAAA;KACjD,CAAC,GACFF,KAAK,CAACvD,QAAAA;AAAQ,GAAA,CAEvB,CAAC,CAAA;AAEN,CAAC;;;;;"}