{"version":3,"file":"route.js","sources":["../../src/route.ts"],"sourcesContent":["import { HistoryLocation } from '@tanstack/history'\nimport * as React from 'react'\nimport invariant from 'tiny-invariant'\nimport { useMatch } from './Matches'\nimport { AnyRouteMatch } from './RouterProvider'\nimport { NavigateOptions, ParsePathParams, ToSubOptions } from './link'\nimport { ParsedLocation } from './location'\nimport { joinPaths, trimPath } from './path'\nimport { RoutePaths } from './routeInfo'\nimport { AnyRouter } from './router'\nimport { useParams } from './useParams'\nimport { useSearch } from './useSearch'\nimport {\n  Assign,\n  Expand,\n  IsAny,\n  NoInfer,\n  PickRequired,\n  UnionToIntersection,\n} from './utils'\nimport { BuildLocationFn, NavigateFn } from './RouterProvider'\n\nexport const rootRouteId = '__root__' as const\nexport type RootRouteId = typeof rootRouteId\nexport type AnyPathParams = {}\n\nexport type AnySearchSchema = {}\n\nexport type AnyContext = {}\n\nexport interface RouteContext {}\n\nexport interface RouteMeta {}\n\nexport type PreloadableObj = { preload?: () => Promise<void> }\n\nexport type RoutePathOptions<TCustomId, TPath> =\n  | {\n      path: TPath\n    }\n  | {\n      id: TCustomId\n    }\n\nexport type RoutePathOptionsIntersection<TCustomId, TPath> =\n  UnionToIntersection<RoutePathOptions<TCustomId, TPath>>\n\nexport type MetaOptions = keyof PickRequired<RouteMeta> extends never\n  ? {\n      meta?: RouteMeta\n    }\n  : {\n      meta: RouteMeta\n    }\n\nexport type RouteOptions<\n  TParentRoute extends AnyRoute = AnyRoute,\n  TCustomId extends string = string,\n  TPath extends string = string,\n  TSearchSchema extends Record<string, any> = {},\n  TFullSearchSchema extends Record<string, any> = TSearchSchema,\n  TParams extends AnyPathParams = AnyPathParams,\n  TAllParams extends AnyPathParams = TParams,\n  TRouteContext extends RouteContext = RouteContext,\n  TAllContext extends Record<string, any> = AnyContext,\n> = BaseRouteOptions<\n  TParentRoute,\n  TCustomId,\n  TPath,\n  TSearchSchema,\n  TFullSearchSchema,\n  TParams,\n  TAllParams,\n  TRouteContext,\n  TAllContext\n> &\n  NoInfer<UpdatableRouteOptions<TFullSearchSchema, TAllParams, TAllContext>>\n\nexport type ParamsFallback<\n  TPath extends string,\n  TParams,\n> = unknown extends TParams ? Record<ParsePathParams<TPath>, string> : TParams\n\ntype Prefix<T extends string, U extends string> = U extends `${T}${infer _}`\n  ? U\n  : never\n\nexport type BaseRouteOptions<\n  TParentRoute extends AnyRoute = AnyRoute,\n  TCustomId extends string = string,\n  TPath extends string = string,\n  TSearchSchema extends Record<string, any> = {},\n  TFullSearchSchema extends Record<string, any> = TSearchSchema,\n  TParams extends AnyPathParams = {},\n  TAllParams = ParamsFallback<TPath, TParams>,\n  TRouteContext extends RouteContext = RouteContext,\n  TAllContext extends Record<string, any> = AnyContext,\n> = RoutePathOptions<TCustomId, TPath> & {\n  getParentRoute: () => TParentRoute\n  validateSearch?: SearchSchemaValidator<TSearchSchema>\n} & (keyof PickRequired<RouteContext> extends never\n    ? // This async function is called before a route is loaded.\n      // If an error is thrown here, the route's loader will not be called.\n      // If thrown during a navigation, the navigation will be cancelled and the error will be passed to the `onError` function.\n      // If thrown during a preload event, the error will be logged to the console.\n      {\n        beforeLoad?: BeforeLoadFn<\n          TFullSearchSchema,\n          TParentRoute,\n          TAllParams,\n          TRouteContext\n        >\n      }\n    : {\n        beforeLoad: BeforeLoadFn<\n          TFullSearchSchema,\n          TParentRoute,\n          TAllParams,\n          TRouteContext\n        >\n      }) & {\n    load?: RouteLoadFn<\n      TAllParams,\n      TFullSearchSchema,\n      NoInfer<TAllContext>,\n      NoInfer<TRouteContext>\n    >\n  } & (\n    | {\n        // Both or none\n        parseParams?: (\n          rawParams: IsAny<TPath, any, Record<ParsePathParams<TPath>, string>>,\n        ) => TParams extends Record<ParsePathParams<TPath>, any>\n          ? TParams\n          : 'parseParams must return an object'\n        stringifyParams?: (\n          params: NoInfer<ParamsFallback<TPath, TParams>>,\n        ) => Record<ParsePathParams<TPath>, string>\n      }\n    | {\n        stringifyParams?: never\n        parseParams?: never\n      }\n  )\n\ntype BeforeLoadFn<\n  TFullSearchSchema extends Record<string, any>,\n  TParentRoute extends AnyRoute,\n  TAllParams,\n  TRouteContext,\n> = (opts: {\n  search: TFullSearchSchema\n  abortController: AbortController\n  preload: boolean\n  params: TAllParams\n  context: TParentRoute['types']['allContext']\n  location: ParsedLocation\n  navigate: NavigateFn<AnyRoute>\n  buildLocation: BuildLocationFn<AnyRoute>\n}) => Promise<TRouteContext> | TRouteContext | void\n\nexport type UpdatableRouteOptions<\n  TFullSearchSchema extends Record<string, any>,\n  TAllParams extends AnyPathParams,\n  TAllContext extends AnyContext,\n> = MetaOptions & {\n  // test?: (args: TAllContext) => void\n  // If true, this route will be matched as case-sensitive\n  caseSensitive?: boolean\n  // If true, this route will be forcefully wrapped in a suspense boundary\n  wrapInSuspense?: boolean\n  // The content to be rendered when the route is matched. If no component is provided, defaults to `<Outlet />`\n  component?: RouteComponent<TFullSearchSchema, TAllParams, TAllContext>\n  // The content to be rendered when the route encounters an error\n  errorComponent?: ErrorRouteComponent<\n    TFullSearchSchema,\n    TAllParams,\n    {}\n    // TAllContext // TODO: I have no idea why this breaks the universe,\n    // so we'll come back to it later.\n  > //\n  // If supported by your framework, the content to be rendered as the fallback content until the route is ready to render\n  pendingComponent?: PendingRouteComponent<\n    TFullSearchSchema,\n    TAllParams,\n    TAllContext\n  >\n  // Filter functions that can manipulate search params *before* they are passed to links and navigate\n  // calls that match this route.\n  preSearchFilters?: SearchFilter<TFullSearchSchema>[]\n  // Filter functions that can manipulate search params *after* they are passed to links and navigate\n  // calls that match this route.\n  postSearchFilters?: SearchFilter<TFullSearchSchema>[]\n  onError?: (err: any) => void\n  // These functions are called as route matches are loaded, stick around and leave the active\n  // matches\n  onEnter?: (match: AnyRouteMatch) => void\n  onTransition?: (match: AnyRouteMatch) => void\n  onLeave?: (match: AnyRouteMatch) => void\n  // Set this to true or false to specifically set whether or not this route should be preloaded. If unset, will\n  // default to router.options.reloadOnWindowFocus\n  reloadOnWindowFocus?: boolean\n}\n\nexport type ParseParamsOption<TPath extends string, TParams> = ParseParamsFn<\n  TPath,\n  TParams\n>\n\nexport type ParseParamsFn<TPath extends string, TParams> = (\n  rawParams: IsAny<TPath, any, Record<ParsePathParams<TPath>, string>>,\n) => TParams extends Record<ParsePathParams<TPath>, any>\n  ? TParams\n  : 'parseParams must return an object'\n\nexport type ParseParamsObj<TPath extends string, TParams> = {\n  parse?: ParseParamsFn<TPath, TParams>\n}\n\n// The parse type here allows a zod schema to be passed directly to the validator\nexport type SearchSchemaValidator<TReturn> =\n  | SearchSchemaValidatorObj<TReturn>\n  | SearchSchemaValidatorFn<TReturn>\n\nexport type SearchSchemaValidatorObj<TReturn> = {\n  parse?: SearchSchemaValidatorFn<TReturn>\n}\n\nexport type SearchSchemaValidatorFn<TReturn> = (\n  searchObj: Record<string, unknown>,\n) => TReturn\n\nexport type DefinedPathParamWarning =\n  'Path params cannot be redefined by child routes!'\n\nexport type ParentParams<TParentParams> = AnyPathParams extends TParentParams\n  ? {}\n  : {\n      [Key in keyof TParentParams]?: DefinedPathParamWarning\n    }\n\nexport type RouteLoadFn<\n  TAllParams = {},\n  TFullSearchSchema extends Record<string, any> = {},\n  TAllContext extends Record<string, any> = AnyContext,\n  TRouteContext extends Record<string, any> = AnyContext,\n> = (\n  match: LoadFnContext<\n    TAllParams,\n    TFullSearchSchema,\n    TAllContext,\n    TRouteContext\n  > & {\n    parentMatchPromise?: Promise<void>\n  },\n) => any\n\nexport interface LoadFnContext<\n  TAllParams = {},\n  TFullSearchSchema extends Record<string, any> = {},\n  TAllContext extends Record<string, any> = AnyContext,\n  TRouteContext extends Record<string, any> = AnyContext,\n> {\n  abortController: AbortController\n  preload: boolean\n  params: TAllParams\n  search: TFullSearchSchema\n  context: Expand<Assign<TAllContext, TRouteContext>>\n  location: ParsedLocation<TFullSearchSchema>\n  navigate: (opts: NavigateOptions<AnyRoute>) => Promise<void>\n}\n\nexport type SearchFilter<T, U = T> = (prev: T) => U\n\nexport type ResolveId<\n  TParentRoute,\n  TCustomId extends string,\n  TPath extends string,\n> = TParentRoute extends { id: infer TParentId extends string }\n  ? RoutePrefix<TParentId, string extends TCustomId ? TPath : TCustomId>\n  : RootRouteId\n\nexport type InferFullSearchSchema<TRoute> = TRoute extends {\n  types: {\n    fullSearchSchema: infer TFullSearchSchema\n  }\n}\n  ? TFullSearchSchema\n  : {}\n\nexport type ResolveFullSearchSchema<TParentRoute, TSearchSchema> = Expand<\n  Assign<InferFullSearchSchema<TParentRoute>, TSearchSchema>\n>\n\nexport interface AnyRoute\n  extends Route<\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any,\n    any\n  > {}\n\nexport type MergeFromFromParent<T, U> = IsAny<T, U, T & U>\n\nexport type StreamedPromise<T> = {\n  promise: Promise<T>\n  status: 'resolved' | 'pending'\n  data: T\n  resolve: (value: T) => void\n}\n\nexport type ResolveAllParams<\n  TParentRoute extends AnyRoute,\n  TParams extends AnyPathParams,\n> = Record<never, string> extends TParentRoute['types']['allParams']\n  ? TParams\n  : Expand<\n      UnionToIntersection<TParentRoute['types']['allParams'] & TParams> & {}\n    >\n\nexport type RouteConstraints = {\n  TParentRoute: AnyRoute\n  TPath: string\n  TFullPath: string\n  TCustomId: string\n  TId: string\n  TSearchSchema: AnySearchSchema\n  TFullSearchSchema: AnySearchSchema\n  TParams: Record<string, any>\n  TAllParams: Record<string, any>\n  TParentContext: AnyContext\n  TRouteContext: RouteContext\n  TAllContext: AnyContext\n  TRouterContext: AnyContext\n  TChildren: unknown\n  TRouteTree: AnyRoute\n}\n\nexport class Route<\n  TParentRoute extends RouteConstraints['TParentRoute'] = AnyRoute,\n  TPath extends RouteConstraints['TPath'] = '/',\n  TFullPath extends RouteConstraints['TFullPath'] = ResolveFullPath<\n    TParentRoute,\n    TPath\n  >,\n  TCustomId extends RouteConstraints['TCustomId'] = string,\n  TId extends RouteConstraints['TId'] = ResolveId<\n    TParentRoute,\n    TCustomId,\n    TPath\n  >,\n  TSearchSchema extends RouteConstraints['TSearchSchema'] = {},\n  TFullSearchSchema extends RouteConstraints['TFullSearchSchema'] = ResolveFullSearchSchema<\n    TParentRoute,\n    TSearchSchema\n  >,\n  TParams extends RouteConstraints['TParams'] = Expand<\n    Record<ParsePathParams<TPath>, string>\n  >,\n  TAllParams extends RouteConstraints['TAllParams'] = ResolveAllParams<\n    TParentRoute,\n    TParams\n  >,\n  TRouteContext extends RouteConstraints['TRouteContext'] = RouteContext,\n  TAllContext extends Expand<\n    Assign<IsAny<TParentRoute['types']['allContext'], {}>, TRouteContext>\n  > = Expand<\n    Assign<IsAny<TParentRoute['types']['allContext'], {}>, TRouteContext>\n  >,\n  TRouterContext extends RouteConstraints['TRouterContext'] = AnyContext,\n  TChildren extends RouteConstraints['TChildren'] = unknown,\n  TRouteTree extends RouteConstraints['TRouteTree'] = AnyRoute,\n> {\n  isRoot: TParentRoute extends Route<any> ? true : false\n  options: RouteOptions<\n    TParentRoute,\n    TCustomId,\n    TPath,\n    TSearchSchema,\n    TFullSearchSchema,\n    TParams,\n    TAllParams,\n    TRouteContext,\n    TAllContext\n  >\n\n  test!: Expand<\n    Assign<IsAny<TParentRoute['types']['allContext'], {}>, TRouteContext>\n  >\n\n  // Set up in this.init()\n  parentRoute!: TParentRoute\n  id!: TId\n  // customId!: TCustomId\n  path!: TPath\n  fullPath!: TFullPath\n  to!: TrimPathRight<TFullPath>\n\n  // Optional\n  children?: TChildren\n  originalIndex?: number\n  router?: AnyRouter\n  rank!: number\n\n  constructor(\n    options: RouteOptions<\n      TParentRoute,\n      TCustomId,\n      TPath,\n      TSearchSchema,\n      TFullSearchSchema,\n      TParams,\n      TAllParams,\n      TRouteContext,\n      TAllContext\n    >,\n  ) {\n    this.options = (options as any) || {}\n    this.isRoot = !options?.getParentRoute as any\n    Route.__onInit(this)\n  }\n\n  types!: {\n    parentRoute: TParentRoute\n    path: TPath\n    to: TrimPathRight<TFullPath>\n    fullPath: TFullPath\n    customId: TCustomId\n    id: TId\n    searchSchema: TSearchSchema\n    fullSearchSchema: TFullSearchSchema\n    params: TParams\n    allParams: TAllParams\n    routeContext: TRouteContext\n    allContext: TAllContext\n    children: TChildren\n    routeTree: TRouteTree\n    routerContext: TRouterContext\n  }\n\n  init = (opts: { originalIndex: number }) => {\n    this.originalIndex = opts.originalIndex\n\n    const options = this.options as RouteOptions<\n      TParentRoute,\n      TCustomId,\n      TPath,\n      TSearchSchema,\n      TFullSearchSchema,\n      TParams,\n      TAllParams,\n      TRouteContext,\n      TAllContext\n    > &\n      RoutePathOptionsIntersection<TCustomId, TPath>\n\n    const isRoot = !options?.path && !options?.id\n\n    this.parentRoute = this.options?.getParentRoute?.()\n\n    if (isRoot) {\n      this.path = rootRouteId as TPath\n    } else {\n      invariant(\n        this.parentRoute,\n        `Child Route instances must pass a 'getParentRoute: () => ParentRoute' option that returns a Route instance.`,\n      )\n    }\n\n    let path: undefined | string = isRoot ? rootRouteId : options.path\n\n    // If the path is anything other than an index path, trim it up\n    if (path && path !== '/') {\n      path = trimPath(path)\n    }\n\n    const customId = options?.id || path\n\n    // Strip the parentId prefix from the first level of children\n    let id = isRoot\n      ? rootRouteId\n      : joinPaths([\n          (this.parentRoute.id as any) === rootRouteId\n            ? ''\n            : this.parentRoute.id,\n          customId,\n        ])\n\n    if (path === rootRouteId) {\n      path = '/'\n    }\n\n    if (id !== rootRouteId) {\n      id = joinPaths(['/', id])\n    }\n\n    const fullPath =\n      id === rootRouteId ? '/' : joinPaths([this.parentRoute.fullPath, path])\n\n    this.path = path as TPath\n    this.id = id as TId\n    // this.customId = customId as TCustomId\n    this.fullPath = fullPath as TFullPath\n    this.to = fullPath as TrimPathRight<TFullPath>\n  }\n\n  addChildren = <TNewChildren extends AnyRoute[]>(\n    children: TNewChildren,\n  ): Route<\n    TParentRoute,\n    TPath,\n    TFullPath,\n    TCustomId,\n    TId,\n    TSearchSchema,\n    TFullSearchSchema,\n    TParams,\n    TAllParams,\n    TRouteContext,\n    TAllContext,\n    TRouterContext,\n    TNewChildren,\n    TRouteTree\n  > => {\n    this.children = children as any\n    return this as any\n  }\n\n  update = (\n    options: UpdatableRouteOptions<\n      TFullSearchSchema,\n      TAllParams,\n      Expand<\n        Assign<IsAny<TParentRoute['types']['allContext'], {}>, TRouteContext>\n      >\n    >,\n  ) => {\n    Object.assign(this.options, options)\n    return this\n  }\n\n  static __onInit = (route: any) => {\n    // This is a dummy static method that should get\n    // replaced by a framework specific implementation if necessary\n  }\n\n  useMatch = <TSelected = TAllContext>(opts?: {\n    select?: (search: TAllContext) => TSelected\n  }): TSelected => {\n    return useMatch({ ...opts, from: this.id }) as any\n  }\n  useRouteContext = <TSelected = TAllContext>(opts?: {\n    select?: (search: TAllContext) => TSelected\n  }): TSelected => {\n    return useMatch({\n      ...opts,\n      from: this.id,\n      select: (d: any) => (opts?.select ? opts.select(d.context) : d.context),\n    } as any)\n  }\n  useSearch = <TSelected = TFullSearchSchema>(opts?: {\n    select?: (search: TFullSearchSchema) => TSelected\n  }): TSelected => {\n    return useSearch({ ...opts, from: this.id } as any)\n  }\n  useParams = <TSelected = TAllParams>(opts?: {\n    select?: (search: TAllParams) => TSelected\n  }): TSelected => {\n    return useParams({ ...opts, from: this.id } as any)\n  }\n}\n\nexport type AnyRootRoute = RootRoute<any, any, any>\n\nexport function rootRouteWithContext<TRouterContext extends {}>() {\n  return <\n    TSearchSchema extends Record<string, any> = {},\n    TRouteContext extends RouteContext = RouteContext,\n  >(\n    options?: Omit<\n      RouteOptions<\n        AnyRoute, // TParentRoute\n        RootRouteId, // TCustomId\n        '', // TPath\n        TSearchSchema, // TSearchSchema\n        TSearchSchema, // TFullSearchSchema\n        {}, // TParams\n        {}, // TAllParams\n        TRouteContext, // TRouteContext\n        Assign<TRouterContext, TRouteContext> // TAllContext\n      >,\n      | 'path'\n      | 'id'\n      | 'getParentRoute'\n      | 'caseSensitive'\n      | 'parseParams'\n      | 'stringifyParams'\n    >,\n  ): RootRoute<TSearchSchema, TRouteContext, TRouterContext> => {\n    return new RootRoute(options) as any\n  }\n}\n\nexport class RootRoute<\n  TSearchSchema extends Record<string, any> = {},\n  TRouteContext extends RouteContext = RouteContext,\n  TRouterContext extends {} = {},\n> extends Route<\n  any, // TParentRoute\n  '/', // TPath\n  '/', // TFullPath\n  string, // TCustomId\n  RootRouteId, // TId\n  TSearchSchema, // TSearchSchema\n  TSearchSchema, // TFullSearchSchema\n  {}, // TParams\n  {}, // TAllParams\n  TRouteContext, // TRouteContext\n  Expand<Assign<TRouterContext, TRouteContext>>, // TAllContext\n  TRouterContext, // TRouterContext\n  any, // TChildren\n  any // TRouteTree\n> {\n  constructor(\n    options?: Omit<\n      RouteOptions<\n        AnyRoute, // TParentRoute\n        RootRouteId, // TCustomId\n        '', // TPath\n        TSearchSchema, // TSearchSchema\n        TSearchSchema, // TFullSearchSchema\n        {}, // TParams\n        {}, // TAllParams\n        TRouteContext, // TRouteContext\n        Assign<TRouterContext, TRouteContext> // TAllContext\n      >,\n      | 'path'\n      | 'id'\n      | 'getParentRoute'\n      | 'caseSensitive'\n      | 'parseParams'\n      | 'stringifyParams'\n    >,\n  ) {\n    super(options as any)\n  }\n}\n\nexport type ResolveFullPath<\n  TParentRoute extends AnyRoute,\n  TPath extends string,\n  TPrefixed = RoutePrefix<TParentRoute['fullPath'], TPath>,\n> = TPrefixed extends RootRouteId ? '/' : TPrefixed\n\ntype RoutePrefix<\n  TPrefix extends string,\n  TPath extends string,\n> = string extends TPath\n  ? RootRouteId\n  : TPath extends string\n  ? TPrefix extends RootRouteId\n    ? TPath extends '/'\n      ? '/'\n      : `/${TrimPath<TPath>}`\n    : `${TPrefix}/${TPath}` extends '/'\n    ? '/'\n    : `/${TrimPathLeft<`${TrimPathRight<TPrefix>}/${TrimPath<TPath>}`>}`\n  : never\n\nexport type TrimPath<T extends string> = '' extends T\n  ? ''\n  : TrimPathRight<TrimPathLeft<T>>\n\nexport type TrimPathLeft<T extends string> =\n  T extends `${RootRouteId}/${infer U}`\n    ? TrimPathLeft<U>\n    : T extends `/${infer U}`\n    ? TrimPathLeft<U>\n    : T\nexport type TrimPathRight<T extends string> = T extends '/'\n  ? '/'\n  : T extends `${infer U}/`\n  ? TrimPathRight<U>\n  : T\n\nexport type RouteMask<TRouteTree extends AnyRoute> = {\n  routeTree: TRouteTree\n  from: RoutePaths<TRouteTree>\n  to?: any\n  params?: any\n  search?: any\n  hash?: any\n  state?: any\n  unmaskOnReload?: boolean\n}\n\nexport function createRouteMask<\n  TRouteTree extends AnyRoute,\n  TFrom extends RoutePaths<TRouteTree>,\n  TTo extends string,\n>(\n  opts: {\n    routeTree: TRouteTree\n  } & ToSubOptions<TRouteTree, TFrom, TTo>,\n): RouteMask<TRouteTree> {\n  return opts as any\n}\n\nexport type RouteProps<\n  TFullSearchSchema extends Record<string, any> = AnySearchSchema,\n  TAllParams extends AnyPathParams = AnyPathParams,\n  TAllContext extends Record<string, any> = AnyContext,\n> = {\n  useMatch: <TSelected = TAllContext>(opts?: {\n    select?: (search: TAllContext) => TSelected\n  }) => TSelected\n  useRouteContext: <TSelected = TAllContext>(opts?: {\n    select?: (search: TAllContext) => TSelected\n  }) => TSelected\n  useSearch: <TSelected = TFullSearchSchema>(opts?: {\n    select?: (search: TFullSearchSchema) => TSelected\n  }) => TSelected\n  useParams: <TSelected = TAllParams>(opts?: {\n    select?: (search: TAllParams) => TSelected\n  }) => TSelected\n}\n\nexport type ErrorRouteProps<\n  TFullSearchSchema extends Record<string, any> = AnySearchSchema,\n  TAllParams extends AnyPathParams = AnyPathParams,\n  TAllContext extends Record<string, any> = AnyContext,\n> = {\n  error: unknown\n  info: { componentStack: string }\n} & RouteProps<TFullSearchSchema, TAllParams, TAllContext>\n\nexport type PendingRouteProps<\n  TFullSearchSchema extends Record<string, any> = AnySearchSchema,\n  TAllParams extends AnyPathParams = AnyPathParams,\n  TAllContext extends Record<string, any> = AnyContext,\n> = RouteProps<TFullSearchSchema, TAllParams, TAllContext>\n//\n\nexport type ReactNode = any\n\nexport type SyncRouteComponent<TProps> =\n  | ((props: TProps) => ReactNode)\n  | React.LazyExoticComponent<(props: TProps) => ReactNode>\n\nexport type AsyncRouteComponent<TProps> = SyncRouteComponent<TProps> & {\n  preload?: () => Promise<void>\n}\n\nexport type RouteComponent<\n  TFullSearchSchema extends Record<string, any>,\n  TAllParams extends AnyPathParams,\n  TAllContext extends Record<string, any>,\n> = AsyncRouteComponent<RouteProps<TFullSearchSchema, TAllParams, TAllContext>>\n\nexport type ErrorRouteComponent<\n  TFullSearchSchema extends Record<string, any>,\n  TAllParams extends AnyPathParams,\n  TAllContext extends Record<string, any>,\n> = AsyncRouteComponent<\n  ErrorRouteProps<TFullSearchSchema, TAllParams, TAllContext>\n>\n\nexport type PendingRouteComponent<\n  TFullSearchSchema extends Record<string, any>,\n  TAllParams extends AnyPathParams,\n  TAllContext extends Record<string, any>,\n> = AsyncRouteComponent<\n  PendingRouteProps<TFullSearchSchema, TAllParams, TAllContext>\n>\n\nexport type AnyRouteComponent = RouteComponent<any, any, any>\n"],"names":["rootRouteId","Route","constructor","options","isRoot","getParentRoute","__onInit","init","opts","originalIndex","path","id","parentRoute","invariant","trimPath","customId","joinPaths","fullPath","to","addChildren","children","update","Object","assign","route","useMatch","from","useRouteContext","select","d","context","useSearch","useParams","rootRouteWithContext","RootRoute","createRouteMask"],"mappings":"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"}