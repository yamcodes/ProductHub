{"version":3,"file":"RouterProvider.js","sources":["../../src/RouterProvider.tsx"],"sourcesContent":["import {\n  HistoryLocation,\n  HistoryState,\n  RouterHistory,\n  createBrowserHistory,\n} from '@tanstack/history'\nimport * as React from 'react'\nimport invariant from 'tiny-invariant'\nimport warning from 'tiny-warning'\nimport { Matches } from './Matches'\nimport {\n  LinkInfo,\n  LinkOptions,\n  NavigateOptions,\n  ResolveRelativePath,\n  ToOptions,\n} from './link'\nimport { ParsedLocation } from './location'\nimport {\n  cleanPath,\n  interpolatePath,\n  joinPaths,\n  matchPathname,\n  parsePathname,\n  resolvePath,\n  trimPath,\n  trimPathRight,\n} from './path'\nimport { isRedirect } from './redirects'\nimport { AnyPathParams, AnyRoute, AnySearchSchema, Route } from './route'\nimport {\n  FullSearchSchema,\n  ParseRoute,\n  RouteById,\n  RouteIds,\n  RoutePaths,\n  RoutesById,\n  RoutesByPath,\n} from './routeInfo'\nimport {\n  BuildNextOptions,\n  DehydratedRouteMatch,\n  RegisteredRouter,\n  Router,\n  RouterOptions,\n  RouterState,\n  componentTypes,\n} from './router'\nimport {\n  NoInfer,\n  PickAsRequired,\n  functionalUpdate,\n  last,\n  partialDeepEqual,\n  pick,\n  replaceEqualDeep,\n  useStableCallback,\n} from './utils'\nimport { MatchRouteOptions } from './Matches'\n\nexport interface CommitLocationOptions {\n  replace?: boolean\n  resetScroll?: boolean\n  startTransition?: boolean\n}\n\nexport interface MatchLocation {\n  to?: string | number | null\n  fuzzy?: boolean\n  caseSensitive?: boolean\n  from?: string\n}\n\ntype LinkCurrentTargetElement = {\n  preloadTimeout?: null | ReturnType<typeof setTimeout>\n}\n\nexport type BuildLinkFn<TRouteTree extends AnyRoute> = <\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n>(\n  dest: LinkOptions<TRouteTree, TFrom, TTo>,\n) => LinkInfo\n\nexport type NavigateFn<TRouteTree extends AnyRoute> = <\n  TRouteTree extends AnyRoute,\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TMaskFrom extends RoutePaths<TRouteTree> = TFrom,\n  TMaskTo extends string = '',\n>({\n  from,\n  to = '' as any,\n  ...rest\n}: NavigateOptions<TRouteTree, TFrom, TTo, TMaskFrom, TMaskTo>) => Promise<void>\n\nexport type MatchRouteFn<TRouteTree extends AnyRoute> = <\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string = '',\n  TResolved = ResolveRelativePath<TFrom, NoInfer<TTo>>,\n>(\n  location: ToOptions<TRouteTree, TFrom, TTo>,\n  opts?: MatchRouteOptions,\n) => false | RouteById<TRouteTree, TResolved>['types']['allParams']\n\nexport type LoadFn = (opts?: {\n  next?: ParsedLocation\n  throwOnError?: boolean\n  __dehydratedMatches?: DehydratedRouteMatch[]\n}) => Promise<void>\n\nexport type BuildLocationFn<TRouteTree extends AnyRoute> = (\n  opts: BuildNextOptions,\n) => ParsedLocation\n\nexport type RouterContext<\n  TRouteTree extends AnyRoute,\n  // TDehydrated extends Record<string, any>,\n> = {\n  buildLink: BuildLinkFn<TRouteTree>\n  state: RouterState<TRouteTree>\n  navigate: NavigateFn<TRouteTree>\n  matchRoute: MatchRouteFn<TRouteTree>\n  routeTree: TRouteTree\n  routesById: RoutesById<TRouteTree>\n  options: RouterOptions<TRouteTree>\n  history: RouterHistory\n  load: LoadFn\n  buildLocation: BuildLocationFn<TRouteTree>\n  subscribe: Router<TRouteTree>['subscribe']\n  resetNextScrollRef: React.MutableRefObject<boolean>\n}\n\nexport const routerContext = React.createContext<RouterContext<any>>(null!)\n\nif (typeof document !== 'undefined') {\n  window.__TSR_ROUTER_CONTEXT__ = routerContext as any\n}\n\nconst preloadWarning = 'Error preloading route! ☝️'\n\nfunction isCtrlEvent(e: MouseEvent) {\n  return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)\n}\n\nexport class SearchParamError extends Error {}\n\nexport class PathParamError extends Error {}\n\nexport function getInitialRouterState(\n  location: ParsedLocation,\n): RouterState<any> {\n  return {\n    status: 'idle',\n    resolvedLocation: location,\n    location,\n    matches: [],\n    pendingMatches: [],\n    lastUpdated: Date.now(),\n  }\n}\n\nexport function RouterProvider<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TDehydrated extends Record<string, any> = Record<string, any>,\n>({ router, ...rest }: RouterProps<TRouteTree, TDehydrated>) {\n  const options = {\n    ...router.options,\n    ...rest,\n    context: {\n      ...router.options.context,\n      ...rest?.context,\n    },\n  } as PickAsRequired<\n    RouterOptions<TRouteTree, TDehydrated>,\n    'stringifySearch' | 'parseSearch' | 'context'\n  >\n\n  const history = React.useState(\n    () => options.history ?? createBrowserHistory(),\n  )[0]\n\n  const tempLocationKeyRef = React.useRef<string | undefined>(\n    `${Math.round(Math.random() * 10000000)}`,\n  )\n  const resetNextScrollRef = React.useRef<boolean>(true)\n  const navigateTimeoutRef = React.useRef<NodeJS.Timeout | null>(null)\n  const latestLoadPromiseRef = React.useRef<Promise<void>>(Promise.resolve())\n\n  const checkLatest = (promise: Promise<void>): undefined | Promise<void> => {\n    return latestLoadPromiseRef.current !== promise\n      ? latestLoadPromiseRef.current\n      : undefined\n  }\n\n  const parseLocation = useStableCallback(\n    (\n      previousLocation?: ParsedLocation,\n    ): ParsedLocation<FullSearchSchema<TRouteTree>> => {\n      const parse = ({\n        pathname,\n        search,\n        hash,\n        state,\n      }: HistoryLocation): ParsedLocation<FullSearchSchema<TRouteTree>> => {\n        const parsedSearch = options.parseSearch(search)\n\n        return {\n          pathname: pathname,\n          searchStr: search,\n          search: replaceEqualDeep(\n            previousLocation?.search,\n            parsedSearch,\n          ) as any,\n          hash: hash.split('#').reverse()[0] ?? '',\n          href: `${pathname}${search}${hash}`,\n          state: replaceEqualDeep(\n            previousLocation?.state,\n            state,\n          ) as HistoryState,\n        }\n      }\n\n      const location = parse(history.location)\n\n      let { __tempLocation, __tempKey } = location.state\n\n      if (\n        __tempLocation &&\n        (!__tempKey || __tempKey === tempLocationKeyRef.current)\n      ) {\n        // Sync up the location keys\n        const parsedTempLocation = parse(__tempLocation) as any\n        parsedTempLocation.state.key = location.state.key\n\n        delete parsedTempLocation.state.__tempLocation\n\n        return {\n          ...parsedTempLocation,\n          maskedLocation: location,\n        }\n      }\n\n      return location\n    },\n  )\n\n  const latestLocationRef = React.useRef<ParsedLocation>(parseLocation())\n  const [preState, setState] = React.useState<RouterState<TRouteTree>>(() =>\n    getInitialRouterState(latestLocationRef.current),\n  )\n  const [isTransitioning, startReactTransition] = React.useTransition()\n\n  const state = React.useMemo<RouterState<TRouteTree>>(\n    () => ({\n      ...preState,\n      status: isTransitioning ? 'pending' : 'idle',\n      location: isTransitioning ? latestLocationRef.current : preState.location,\n    }),\n    [preState, isTransitioning],\n  )\n\n  React.useLayoutEffect(() => {\n    if (!isTransitioning && state.resolvedLocation !== state.location) {\n      router.emit({\n        type: 'onResolved',\n        fromLocation: state.resolvedLocation,\n        toLocation: state.location,\n        pathChanged: state.location!.href !== state.resolvedLocation?.href,\n      })\n      setState((s) => ({\n        ...s,\n        resolvedLocation: s.location,\n      }))\n    }\n  })\n\n  const basepath = `/${trimPath(options.basepath ?? '') ?? ''}`\n\n  const resolvePathWithBase = useStableCallback(\n    (from: string, path: string) => {\n      return resolvePath(basepath!, from, cleanPath(path))\n    },\n  )\n\n  const [routesById, routesByPath] = React.useMemo(() => {\n    const routesById = {} as RoutesById<TRouteTree>\n    const routesByPath = {} as RoutesByPath<TRouteTree>\n\n    const recurseRoutes = (routes: AnyRoute[]) => {\n      routes.forEach((route, i) => {\n        route.init({ originalIndex: i })\n\n        const existingRoute = (routesById as any)[route.id]\n\n        invariant(\n          !existingRoute,\n          `Duplicate routes found with id: ${String(route.id)}`,\n        )\n        ;(routesById as any)[route.id] = route\n\n        if (!route.isRoot && route.path) {\n          const trimmedFullPath = trimPathRight(route.fullPath)\n          if (\n            !(routesByPath as any)[trimmedFullPath] ||\n            route.fullPath.endsWith('/')\n          ) {\n            ;(routesByPath as any)[trimmedFullPath] = route\n          }\n        }\n\n        const children = route.children as Route[]\n\n        if (children?.length) {\n          recurseRoutes(children)\n        }\n      })\n    }\n\n    recurseRoutes([router.routeTree])\n\n    return [routesById, routesByPath] as const\n  }, [])\n\n  const looseRoutesById = routesById as Record<string, AnyRoute>\n\n  const flatRoutes = React.useMemo(\n    () =>\n      (Object.values(routesByPath) as AnyRoute[])\n        .map((d, i) => {\n          const trimmed = trimPath(d.fullPath)\n          const parsed = parsePathname(trimmed)\n\n          while (parsed.length > 1 && parsed[0]?.value === '/') {\n            parsed.shift()\n          }\n\n          const score = parsed.map((d) => {\n            if (d.type === 'param') {\n              return 0.5\n            }\n\n            if (d.type === 'wildcard') {\n              return 0.25\n            }\n\n            return 1\n          })\n\n          return { child: d, trimmed, parsed, index: i, score }\n        })\n        .sort((a, b) => {\n          let isIndex = a.trimmed === '/' ? 1 : b.trimmed === '/' ? -1 : 0\n\n          if (isIndex !== 0) return isIndex\n\n          const length = Math.min(a.score.length, b.score.length)\n\n          // Sort by length of score\n          if (a.score.length !== b.score.length) {\n            return b.score.length - a.score.length\n          }\n\n          // Sort by min available score\n          for (let i = 0; i < length; i++) {\n            if (a.score[i] !== b.score[i]) {\n              return b.score[i]! - a.score[i]!\n            }\n          }\n\n          // Sort by min available parsed value\n          for (let i = 0; i < length; i++) {\n            if (a.parsed[i]!.value !== b.parsed[i]!.value) {\n              return a.parsed[i]!.value! > b.parsed[i]!.value! ? 1 : -1\n            }\n          }\n\n          // Sort by length of trimmed full path\n          if (a.trimmed !== b.trimmed) {\n            return a.trimmed > b.trimmed ? 1 : -1\n          }\n\n          // Sort by original index\n          return a.index - b.index\n        })\n        .map((d, i) => {\n          d.child.rank = i\n          return d.child\n        }),\n    [routesByPath],\n  )\n\n  const matchRoutes = useStableCallback(\n    <TRouteTree extends AnyRoute>(\n      pathname: string,\n      locationSearch: AnySearchSchema,\n      opts?: { throwOnError?: boolean; debug?: boolean },\n    ): RouteMatch<TRouteTree>[] => {\n      let routeParams: AnyPathParams = {}\n\n      let foundRoute = flatRoutes.find((route) => {\n        const matchedParams = matchPathname(basepath, trimPathRight(pathname), {\n          to: route.fullPath,\n          caseSensitive: route.options.caseSensitive ?? options.caseSensitive,\n          fuzzy: false,\n        })\n\n        if (matchedParams) {\n          routeParams = matchedParams\n          return true\n        }\n\n        return false\n      })\n\n      let routeCursor: AnyRoute = foundRoute || (routesById as any)['__root__']\n\n      let matchedRoutes: AnyRoute[] = [routeCursor]\n      // let includingLayouts = true\n      while (routeCursor?.parentRoute) {\n        routeCursor = routeCursor.parentRoute\n        if (routeCursor) matchedRoutes.unshift(routeCursor)\n      }\n\n      // Existing matches are matches that are already loaded along with\n      // pending matches that are still loading\n\n      const parseErrors = matchedRoutes.map((route) => {\n        let parsedParamsError\n\n        if (route.options.parseParams) {\n          try {\n            const parsedParams = route.options.parseParams(routeParams)\n            // Add the parsed params to the accumulated params bag\n            Object.assign(routeParams, parsedParams)\n          } catch (err: any) {\n            parsedParamsError = new PathParamError(err.message, {\n              cause: err,\n            })\n\n            if (opts?.throwOnError) {\n              throw parsedParamsError\n            }\n\n            return parsedParamsError\n          }\n        }\n\n        return\n      })\n\n      const matches = matchedRoutes.map((route, index) => {\n        const interpolatedPath = interpolatePath(route.path, routeParams)\n        const matchId = interpolatePath(route.id, routeParams, true)\n\n        // Waste not, want not. If we already have a match for this route,\n        // reuse it. This is important for layout routes, which might stick\n        // around between navigation actions that only change leaf routes.\n        const existingMatch = getRouteMatch(state, matchId)\n\n        if (existingMatch) {\n          return { ...existingMatch }\n        }\n\n        // Create a fresh route match\n        const hasLoaders = !!(\n          route.options.load ||\n          componentTypes.some((d) => (route.options[d] as any)?.preload)\n        )\n\n        const routeMatch: AnyRouteMatch = {\n          id: matchId,\n          routeId: route.id,\n          params: routeParams,\n          pathname: joinPaths([basepath, interpolatedPath]),\n          updatedAt: Date.now(),\n          routeSearch: {},\n          search: {} as any,\n          status: hasLoaders ? 'pending' : 'success',\n          isFetching: false,\n          invalid: false,\n          error: undefined,\n          paramsError: parseErrors[index],\n          searchError: undefined,\n          loadPromise: Promise.resolve(),\n          context: undefined!,\n          abortController: new AbortController(),\n          fetchedAt: 0,\n        }\n\n        return routeMatch\n      })\n\n      // Take each match and resolve its search params and context\n      // This has to happen after the matches are created or found\n      // so that we can use the parent match's search params and context\n      matches.forEach((match, i): any => {\n        const parentMatch = matches[i - 1]\n        const route = looseRoutesById[match.routeId]!\n\n        const searchInfo = (() => {\n          // Validate the search params and stabilize them\n          const parentSearchInfo = {\n            search: parentMatch?.search ?? locationSearch,\n            routeSearch: parentMatch?.routeSearch ?? locationSearch,\n          }\n\n          try {\n            const validator =\n              typeof route.options.validateSearch === 'object'\n                ? route.options.validateSearch.parse\n                : route.options.validateSearch\n\n            let routeSearch = validator?.(parentSearchInfo.search) ?? {}\n\n            let search = {\n              ...parentSearchInfo.search,\n              ...routeSearch,\n            }\n\n            routeSearch = replaceEqualDeep(match.routeSearch, routeSearch)\n            search = replaceEqualDeep(match.search, search)\n\n            return {\n              routeSearch,\n              search,\n              searchDidChange: match.routeSearch !== routeSearch,\n            }\n          } catch (err: any) {\n            match.searchError = new SearchParamError(err.message, {\n              cause: err,\n            })\n\n            if (opts?.throwOnError) {\n              throw match.searchError\n            }\n\n            return parentSearchInfo\n          }\n        })()\n\n        Object.assign(match, searchInfo)\n      })\n\n      return matches as any\n    },\n  )\n\n  const cancelMatch = useStableCallback(\n    <TRouteTree extends AnyRoute>(id: string) => {\n      getRouteMatch(state, id)?.abortController?.abort()\n    },\n  )\n\n  const cancelMatches = useStableCallback(\n    <TRouteTree extends AnyRoute>(state: RouterState<TRouteTree>) => {\n      state.matches.forEach((match) => {\n        cancelMatch(match.id)\n      })\n    },\n  )\n\n  const buildLocation = useStableCallback<BuildLocationFn<TRouteTree>>(\n    (opts) => {\n      const build = (\n        dest: BuildNextOptions & {\n          unmaskOnReload?: boolean\n        } = {},\n        matches?: AnyRouteMatch[],\n      ): ParsedLocation => {\n        const from = latestLocationRef.current\n        const fromPathname = dest.from ?? from.pathname\n\n        let pathname = resolvePathWithBase(fromPathname, `${dest.to ?? ''}`)\n\n        const fromMatches = matchRoutes(fromPathname, from.search)\n        const stayingMatches = matches?.filter((d) =>\n          fromMatches?.find((e) => e.routeId === d.routeId),\n        )\n\n        const prevParams = { ...last(fromMatches)?.params }\n\n        let nextParams =\n          (dest.params ?? true) === true\n            ? prevParams\n            : functionalUpdate(dest.params!, prevParams)\n\n        if (nextParams) {\n          matches\n            ?.map((d) => looseRoutesById[d.routeId]!.options.stringifyParams)\n            .filter(Boolean)\n            .forEach((fn) => {\n              nextParams = { ...nextParams!, ...fn!(nextParams!) }\n            })\n        }\n\n        pathname = interpolatePath(pathname, nextParams ?? {})\n\n        const preSearchFilters =\n          stayingMatches\n            ?.map(\n              (match) =>\n                looseRoutesById[match.routeId]!.options.preSearchFilters ?? [],\n            )\n            .flat()\n            .filter(Boolean) ?? []\n\n        const postSearchFilters =\n          stayingMatches\n            ?.map(\n              (match) =>\n                looseRoutesById[match.routeId]!.options.postSearchFilters ?? [],\n            )\n            .flat()\n            .filter(Boolean) ?? []\n\n        // Pre filters first\n        const preFilteredSearch = preSearchFilters?.length\n          ? preSearchFilters?.reduce(\n              (prev, next) => next(prev) as any,\n              from.search,\n            )\n          : from.search\n\n        // Then the link/navigate function\n        const destSearch =\n          dest.search === true\n            ? preFilteredSearch // Preserve resolvedFrom true\n            : dest.search\n            ? functionalUpdate(dest.search, preFilteredSearch) ?? {} // Updater\n            : preSearchFilters?.length\n            ? preFilteredSearch // Preserve resolvedFrom filters\n            : {}\n\n        // Then post filters\n        const postFilteredSearch = postSearchFilters?.length\n          ? postSearchFilters.reduce((prev, next) => next(prev), destSearch)\n          : destSearch\n\n        const search = replaceEqualDeep(from.search, postFilteredSearch)\n\n        const searchStr = options.stringifySearch(search)\n\n        const hash =\n          dest.hash === true\n            ? from.hash\n            : dest.hash\n            ? functionalUpdate(dest.hash!, from.hash)\n            : from.hash\n\n        const hashStr = hash ? `#${hash}` : ''\n\n        let nextState =\n          dest.state === true\n            ? from.state\n            : dest.state\n            ? functionalUpdate(dest.state, from.state)\n            : from.state\n\n        nextState = replaceEqualDeep(from.state, nextState)\n\n        return {\n          pathname,\n          search,\n          searchStr,\n          state: nextState as any,\n          hash,\n          href: history.createHref(`${pathname}${searchStr}${hashStr}`),\n          unmaskOnReload: dest.unmaskOnReload,\n        }\n      }\n\n      const buildWithMatches = (\n        dest: BuildNextOptions = {},\n        maskedDest?: BuildNextOptions,\n      ) => {\n        let next = build(dest)\n        let maskedNext = maskedDest ? build(maskedDest) : undefined\n\n        if (!maskedNext) {\n          let params = {}\n\n          let foundMask = options.routeMasks?.find((d) => {\n            const match = matchPathname(basepath, next.pathname, {\n              to: d.from,\n              caseSensitive: false,\n              fuzzy: false,\n            })\n\n            if (match) {\n              params = match\n              return true\n            }\n\n            return false\n          })\n\n          if (foundMask) {\n            foundMask = {\n              ...foundMask,\n              from: interpolatePath(foundMask.from, params) as any,\n            }\n            maskedDest = foundMask\n            maskedNext = build(maskedDest)\n          }\n        }\n\n        const nextMatches = matchRoutes(next.pathname, next.search)\n        const maskedMatches = maskedNext\n          ? matchRoutes(maskedNext.pathname, maskedNext.search)\n          : undefined\n        const maskedFinal = maskedNext\n          ? build(maskedDest, maskedMatches)\n          : undefined\n\n        const final = build(dest, nextMatches)\n\n        if (maskedFinal) {\n          final.maskedLocation = maskedFinal\n        }\n\n        return final\n      }\n\n      if (opts.mask) {\n        return buildWithMatches(opts, {\n          ...pick(opts, ['from']),\n          ...opts.mask,\n        })\n      }\n\n      return buildWithMatches(opts)\n    },\n  )\n\n  const commitLocation = useStableCallback(\n    async ({\n      startTransition,\n      ...next\n    }: ParsedLocation & CommitLocationOptions) => {\n      if (navigateTimeoutRef.current) clearTimeout(navigateTimeoutRef.current)\n\n      const isSameUrl = latestLocationRef.current.href === next.href\n\n      // If the next urls are the same and we're not replacing,\n      // do nothing\n      if (!isSameUrl || !next.replace) {\n        let { maskedLocation, ...nextHistory } = next\n\n        if (maskedLocation) {\n          nextHistory = {\n            ...maskedLocation,\n            state: {\n              ...maskedLocation.state,\n              __tempKey: undefined,\n              __tempLocation: {\n                ...nextHistory,\n                search: nextHistory.searchStr,\n                state: {\n                  ...nextHistory.state,\n                  __tempKey: undefined!,\n                  __tempLocation: undefined!,\n                  key: undefined!,\n                },\n              },\n            },\n          }\n\n          if (nextHistory.unmaskOnReload ?? options.unmaskOnReload ?? false) {\n            nextHistory.state.__tempKey = tempLocationKeyRef.current\n          }\n        }\n\n        const apply = () => {\n          history[next.replace ? 'replace' : 'push'](\n            nextHistory.href,\n            nextHistory.state,\n          )\n        }\n\n        if (startTransition ?? true) {\n          startReactTransition(apply)\n        } else {\n          apply()\n        }\n      }\n\n      resetNextScrollRef.current = next.resetScroll ?? true\n\n      return latestLoadPromiseRef.current\n    },\n  )\n\n  const buildAndCommitLocation = useStableCallback(\n    ({\n      replace,\n      resetScroll,\n      startTransition,\n      ...rest\n    }: BuildNextOptions & CommitLocationOptions = {}) => {\n      const location = buildLocation(rest)\n      return commitLocation({\n        ...location,\n        startTransition,\n        replace,\n        resetScroll,\n      })\n    },\n  )\n\n  const navigate = useStableCallback<NavigateFn<TRouteTree>>(\n    ({ from, to = '', ...rest }) => {\n      // If this link simply reloads the current route,\n      // make sure it has a new key so it will trigger a data refresh\n\n      // If this `to` is a valid external URL, return\n      // null for LinkUtils\n      const toString = String(to)\n      const fromString = typeof from === 'undefined' ? from : String(from)\n      let isExternal\n\n      try {\n        new URL(`${toString}`)\n        isExternal = true\n      } catch (e) {}\n\n      invariant(\n        !isExternal,\n        'Attempting to navigate to external url with this.navigate!',\n      )\n\n      return buildAndCommitLocation({\n        ...rest,\n        from: fromString,\n        to: toString,\n      })\n    },\n  )\n\n  const loadMatches = useStableCallback(\n    async ({\n      checkLatest,\n      matches,\n      preload,\n    }: {\n      checkLatest: () => Promise<void> | undefined\n      matches: AnyRouteMatch[]\n      preload?: boolean\n    }): Promise<RouteMatch[]> => {\n      let latestPromise\n      let firstBadMatchIndex: number | undefined\n\n      // Check each match middleware to see if the route can be accessed\n      try {\n        for (let [index, match] of matches.entries()) {\n          const parentMatch = matches[index - 1]\n          const route = looseRoutesById[match.routeId]!\n\n          const handleError = (err: any, code: string) => {\n            err.routerCode = code\n            firstBadMatchIndex = firstBadMatchIndex ?? index\n\n            if (isRedirect(err)) {\n              throw err\n            }\n\n            try {\n              route.options.onError?.(err)\n            } catch (errorHandlerErr) {\n              err = errorHandlerErr\n\n              if (isRedirect(errorHandlerErr)) {\n                throw errorHandlerErr\n              }\n            }\n\n            matches[index] = match = {\n              ...match,\n              error: err,\n              status: 'error',\n              updatedAt: Date.now(),\n            }\n          }\n\n          try {\n            if (match.paramsError) {\n              handleError(match.paramsError, 'PARSE_PARAMS')\n            }\n\n            if (match.searchError) {\n              handleError(match.searchError, 'VALIDATE_SEARCH')\n            }\n\n            const parentContext = parentMatch?.context ?? options.context ?? {}\n\n            const beforeLoadContext =\n              (await route.options.beforeLoad?.({\n                search: match.search,\n                abortController: match.abortController,\n                params: match.params,\n                preload: !!preload,\n                context: parentContext,\n                location: state.location,\n                navigate: (opts) =>\n                  navigate({ ...opts, from: match.pathname } as any),\n                buildLocation,\n              })) ?? ({} as any)\n\n            const context = {\n              ...parentContext,\n              ...beforeLoadContext,\n            }\n\n            matches[index] = match = {\n              ...match,\n              context: replaceEqualDeep(match.context, context),\n            }\n          } catch (err) {\n            handleError(err, 'BEFORE_LOAD')\n            break\n          }\n        }\n      } catch (err) {\n        if (isRedirect(err)) {\n          if (!preload) navigate(err as any)\n          return matches\n        }\n\n        throw err\n      }\n\n      const validResolvedMatches = matches.slice(0, firstBadMatchIndex)\n      const matchPromises: Promise<any>[] = []\n\n      validResolvedMatches.forEach((match, index) => {\n        matchPromises.push(\n          (async () => {\n            const parentMatchPromise = matchPromises[index - 1]\n            const route = looseRoutesById[match.routeId]!\n\n            if (match.isFetching) {\n              return getRouteMatch(state, match.id)?.loadPromise\n            }\n\n            const handleIfRedirect = (err: any) => {\n              if (isRedirect(err)) {\n                if (!preload) {\n                  navigate(err as any)\n                }\n                return true\n              }\n              return false\n            }\n\n            const load = async () => {\n              try {\n                const componentsPromise = Promise.all(\n                  componentTypes.map(async (type) => {\n                    const component = route.options[type]\n\n                    if ((component as any)?.preload) {\n                      await (component as any).preload()\n                    }\n                  }),\n                )\n\n                const loaderPromise = route.options.load?.({\n                  params: match.params,\n                  search: match.search,\n                  preload: !!preload,\n                  parentMatchPromise,\n                  abortController: match.abortController,\n                  context: match.context,\n                  location: state.location,\n                  navigate: (opts) =>\n                    navigate({ ...opts, from: match.pathname }),\n                })\n\n                const [_, loaderContext] = await Promise.all([\n                  componentsPromise,\n                  loaderPromise,\n                ])\n                if ((latestPromise = checkLatest())) return await latestPromise\n\n                matches[index] = match = {\n                  ...match,\n                  error: undefined,\n                  status: 'success',\n                  isFetching: false,\n                  updatedAt: Date.now(),\n                }\n              } catch (error) {\n                if ((latestPromise = checkLatest())) return await latestPromise\n                if (handleIfRedirect(error)) return\n\n                try {\n                  route.options.onError?.(error)\n                } catch (onErrorError) {\n                  error = onErrorError\n                  if (handleIfRedirect(onErrorError)) return\n                }\n\n                matches[index] = match = {\n                  ...match,\n                  error,\n                  status: 'error',\n                  isFetching: false,\n                  updatedAt: Date.now(),\n                }\n              }\n\n              if (!preload) {\n                setState((s) => ({\n                  ...s,\n                  matches: s.matches.map((d) =>\n                    d.id === match.id ? match : d,\n                  ),\n                }))\n              }\n            }\n\n            let loadPromise: Promise<void> | undefined\n\n            matches[index] = match = {\n              ...match,\n              isFetching: true,\n              fetchedAt: Date.now(),\n              invalid: false,\n            }\n\n            loadPromise = load()\n\n            matches[index] = match = {\n              ...match,\n              loadPromise,\n            }\n\n            await loadPromise\n          })(),\n        )\n      })\n\n      await Promise.all(matchPromises)\n      return matches\n    },\n  )\n\n  const load = useStableCallback<LoadFn>(async () => {\n    const promise = new Promise<void>(async (resolve, reject) => {\n      const next = latestLocationRef.current\n      const prevLocation = state.resolvedLocation\n      const pathDidChange = prevLocation!.href !== next.href\n      let latestPromise: Promise<void> | undefined | null\n\n      // Cancel any pending matches\n      cancelMatches(state)\n\n      router.emit({\n        type: 'onBeforeLoad',\n        fromLocation: prevLocation,\n        toLocation: next,\n        pathChanged: pathDidChange,\n      })\n\n      // Match the routes\n      let matches: RouteMatch<any, any>[] = matchRoutes(\n        next.pathname,\n        next.search,\n        {\n          debug: true,\n        },\n      )\n\n      const previousMatches = state.matches\n\n      // Ingest the new matches\n      setState((s) => ({\n        ...s,\n        status: 'pending',\n        location: next,\n        matches,\n      }))\n\n      try {\n        try {\n          // Load the matches\n          await loadMatches({\n            matches,\n            checkLatest: () => checkLatest(promise),\n          })\n        } catch (err) {\n          // swallow this error, since we'll display the\n          // errors on the route components\n        }\n\n        // Only apply the latest transition\n        if ((latestPromise = checkLatest(promise))) {\n          return latestPromise\n        }\n\n        const exitingMatchIds = previousMatches.filter(\n          (id) => !state.pendingMatches.includes(id),\n        )\n        const enteringMatchIds = state.pendingMatches.filter(\n          (id) => !previousMatches.includes(id),\n        )\n        const stayingMatchIds = previousMatches.filter((id) =>\n          state.pendingMatches.includes(id),\n        )\n\n        // setState((s) => ({\n        //   ...s,\n        //   status: 'idle',\n        //   resolvedLocation: s.location,\n        // }))\n\n        //\n        ;(\n          [\n            [exitingMatchIds, 'onLeave'],\n            [enteringMatchIds, 'onEnter'],\n            [stayingMatchIds, 'onTransition'],\n          ] as const\n        ).forEach(([matches, hook]) => {\n          matches.forEach((match) => {\n            looseRoutesById[match.routeId]!.options[hook]?.(match)\n          })\n        })\n\n        router.emit({\n          type: 'onLoad',\n          fromLocation: prevLocation,\n          toLocation: next,\n          pathChanged: pathDidChange,\n        })\n\n        resolve()\n      } catch (err) {\n        // Only apply the latest transition\n        if ((latestPromise = checkLatest(promise))) {\n          return latestPromise\n        }\n\n        reject(err)\n      }\n    })\n\n    latestLoadPromiseRef.current = promise\n\n    return latestLoadPromiseRef.current\n  })\n\n  const preloadRoute = useStableCallback(\n    async (navigateOpts: BuildNextOptions = state.location) => {\n      let next = buildLocation(navigateOpts)\n\n      let matches = matchRoutes(next.pathname, next.search, {\n        throwOnError: true,\n      })\n\n      await loadMatches({\n        matches,\n        preload: true,\n        checkLatest: () => undefined,\n      })\n\n      return [last(matches)!, matches] as const\n    },\n  )\n\n  const buildLink = useStableCallback<BuildLinkFn<TRouteTree>>((dest) => {\n    // If this link simply reloads the current route,\n    // make sure it has a new key so it will trigger a data refresh\n\n    // If this `to` is a valid external URL, return\n    // null for LinkUtils\n\n    const {\n      to,\n      preload: userPreload,\n      preloadDelay: userPreloadDelay,\n      activeOptions,\n      disabled,\n      target,\n      replace,\n      resetScroll,\n      startTransition,\n    } = dest\n\n    try {\n      new URL(`${to}`)\n      return {\n        type: 'external',\n        href: to as any,\n      }\n    } catch (e) {}\n\n    const nextOpts = dest\n    const next = buildLocation(nextOpts as any)\n\n    const preload = userPreload ?? options.defaultPreload\n    const preloadDelay = userPreloadDelay ?? options.defaultPreloadDelay ?? 0\n\n    // Compare path/hash for matches\n    const currentPathSplit = latestLocationRef.current.pathname.split('/')\n    const nextPathSplit = next.pathname.split('/')\n    const pathIsFuzzyEqual = nextPathSplit.every(\n      (d, i) => d === currentPathSplit[i],\n    )\n    // Combine the matches based on user options\n    const pathTest = activeOptions?.exact\n      ? latestLocationRef.current.pathname === next.pathname\n      : pathIsFuzzyEqual\n    const hashTest = activeOptions?.includeHash\n      ? latestLocationRef.current.hash === next.hash\n      : true\n    const searchTest =\n      activeOptions?.includeSearch ?? true\n        ? partialDeepEqual(latestLocationRef.current.search, next.search)\n        : true\n\n    // The final \"active\" test\n    const isActive = pathTest && hashTest && searchTest\n\n    // The click handler\n    const handleClick = (e: MouseEvent) => {\n      if (\n        !disabled &&\n        !isCtrlEvent(e) &&\n        !e.defaultPrevented &&\n        (!target || target === '_self') &&\n        e.button === 0\n      ) {\n        e.preventDefault()\n\n        // All is well? Navigate!\n        commitLocation({ ...next, replace, resetScroll, startTransition })\n      }\n    }\n\n    // The click handler\n    const handleFocus = (e: MouseEvent) => {\n      if (preload) {\n        preloadRoute(nextOpts as any).catch((err) => {\n          console.warn(err)\n          console.warn(preloadWarning)\n        })\n      }\n    }\n\n    const handleTouchStart = (e: TouchEvent) => {\n      preloadRoute(nextOpts as any).catch((err) => {\n        console.warn(err)\n        console.warn(preloadWarning)\n      })\n    }\n\n    const handleEnter = (e: MouseEvent) => {\n      const target = (e.target || {}) as LinkCurrentTargetElement\n\n      if (preload) {\n        if (target.preloadTimeout) {\n          return\n        }\n\n        target.preloadTimeout = setTimeout(() => {\n          target.preloadTimeout = null\n          preloadRoute(nextOpts as any).catch((err) => {\n            console.warn(err)\n            console.warn(preloadWarning)\n          })\n        }, preloadDelay)\n      }\n    }\n\n    const handleLeave = (e: MouseEvent) => {\n      const target = (e.target || {}) as LinkCurrentTargetElement\n\n      if (target.preloadTimeout) {\n        clearTimeout(target.preloadTimeout)\n        target.preloadTimeout = null\n      }\n    }\n\n    return {\n      type: 'internal',\n      next,\n      handleFocus,\n      handleClick,\n      handleEnter,\n      handleLeave,\n      handleTouchStart,\n      isActive,\n      disabled,\n    }\n  })\n\n  React.useLayoutEffect(() => {\n    const unsub = history.subscribe(() => {\n      latestLocationRef.current = parseLocation(latestLocationRef.current)\n\n      if (state.location !== latestLocationRef.current) {\n        startReactTransition(() => {\n          try {\n            load()\n          } catch (err) {\n            console.error(err)\n          }\n        })\n      }\n    })\n\n    const nextLocation = buildLocation({\n      search: true,\n      params: true,\n      hash: true,\n      state: true,\n    })\n\n    if (state.location.href !== nextLocation.href) {\n      commitLocation({ ...nextLocation, replace: true })\n    }\n\n    return () => {\n      unsub()\n    }\n  }, [history])\n\n  const initialLoad = React.useRef(true)\n\n  if (initialLoad.current) {\n    initialLoad.current = false\n    startReactTransition(() => {\n      try {\n        load()\n      } catch (err) {\n        console.error(err)\n      }\n    })\n  }\n\n  const matchRoute = useStableCallback<MatchRouteFn<TRouteTree>>(\n    (location, opts) => {\n      location = {\n        ...location,\n        to: location.to\n          ? resolvePathWithBase((location.from || '') as string, location.to)\n          : undefined,\n      } as any\n\n      const next = buildLocation(location as any)\n\n      if (opts?.pending && state.status !== 'pending') {\n        return false\n      }\n\n      const baseLocation = opts?.pending\n        ? latestLocationRef.current\n        : state.resolvedLocation\n\n      // const baseLocation = state.resolvedLocation\n\n      if (!baseLocation) {\n        return false\n      }\n\n      const match = matchPathname(basepath, baseLocation.pathname, {\n        ...opts,\n        to: next.pathname,\n      }) as any\n\n      if (!match) {\n        return false\n      }\n\n      if (match && (opts?.includeSearch ?? true)) {\n        return partialDeepEqual(baseLocation.search, next.search)\n          ? match\n          : false\n      }\n\n      return match\n    },\n  )\n\n  const routerContextValue: RouterContext<TRouteTree> = {\n    routeTree: router.routeTree,\n    navigate,\n    buildLink,\n    state,\n    matchRoute,\n    routesById,\n    options,\n    history,\n    load,\n    buildLocation,\n    subscribe: router.subscribe,\n    resetNextScrollRef,\n  }\n\n  return (\n    <routerContext.Provider value={routerContextValue}>\n      <Matches />\n    </routerContext.Provider>\n  )\n}\n\nexport function getRouteMatch<TRouteTree extends AnyRoute>(\n  state: RouterState<TRouteTree>,\n  id: string,\n): undefined | RouteMatch<TRouteTree> {\n  return [...state.pendingMatches, ...state.matches].find((d) => d.id === id)\n}\n\nexport function useRouterState<\n  TSelected = RouterState<RegisteredRouter['routeTree']>,\n>(opts?: {\n  select: (state: RouterState<RegisteredRouter['routeTree']>) => TSelected\n}): TSelected {\n  const { state } = useRouter()\n  // return useStore(router.__store, opts?.select as any)\n  return opts?.select ? opts.select(state) : (state as any)\n}\n\nexport type RouterProps<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n  TDehydrated extends Record<string, any> = Record<string, any>,\n> = Omit<RouterOptions<TRouteTree, TDehydrated>, 'context'> & {\n  router: Router<TRouteTree>\n  context?: Partial<RouterOptions<TRouteTree, TDehydrated>['context']>\n}\n\nexport function useRouter<\n  TRouteTree extends AnyRoute = RegisteredRouter['routeTree'],\n>(): RouterContext<TRouteTree> {\n  const resolvedContext = window.__TSR_ROUTER_CONTEXT__ || routerContext\n  const value = React.useContext(resolvedContext)\n  warning(value, 'useRouter must be used inside a <RouterProvider> component!')\n  return value as any\n}\nexport interface RouteMatch<\n  TRouteTree extends AnyRoute = AnyRoute,\n  TRouteId extends RouteIds<TRouteTree> = ParseRoute<TRouteTree>['id'],\n> {\n  id: string\n  routeId: TRouteId\n  pathname: string\n  params: RouteById<TRouteTree, TRouteId>['types']['allParams']\n  status: 'pending' | 'success' | 'error'\n  isFetching: boolean\n  invalid: boolean\n  error: unknown\n  paramsError: unknown\n  searchError: unknown\n  updatedAt: number\n  loadPromise?: Promise<void>\n  __resolveLoadPromise?: () => void\n  context: RouteById<TRouteTree, TRouteId>['types']['allContext']\n  routeSearch: RouteById<TRouteTree, TRouteId>['types']['searchSchema']\n  search: FullSearchSchema<TRouteTree> &\n    RouteById<TRouteTree, TRouteId>['types']['fullSearchSchema']\n  fetchedAt: number\n  abortController: AbortController\n}\n\nexport type AnyRouteMatch = RouteMatch<any>\n"],"names":["routerContext","React","createContext","document","window","__TSR_ROUTER_CONTEXT__","preloadWarning","isCtrlEvent","e","metaKey","altKey","ctrlKey","shiftKey","SearchParamError","Error","PathParamError","getInitialRouterState","location","status","resolvedLocation","matches","pendingMatches","lastUpdated","Date","now","RouterProvider","router","rest","options","context","history","useState","createBrowserHistory","tempLocationKeyRef","useRef","Math","round","random","resetNextScrollRef","navigateTimeoutRef","latestLoadPromiseRef","Promise","resolve","checkLatest","promise","current","undefined","parseLocation","useStableCallback","previousLocation","parse","pathname","search","hash","state","parsedSearch","parseSearch","searchStr","replaceEqualDeep","split","reverse","href","__tempLocation","__tempKey","parsedTempLocation","key","maskedLocation","latestLocationRef","preState","setState","isTransitioning","startReactTransition","useTransition","useMemo","useLayoutEffect","emit","type","fromLocation","toLocation","pathChanged","s","basepath","trimPath","resolvePathWithBase","from","path","resolvePath","cleanPath","routesById","routesByPath","recurseRoutes","routes","forEach","route","i","init","originalIndex","existingRoute","id","invariant","String","isRoot","trimmedFullPath","trimPathRight","fullPath","endsWith","children","length","routeTree","looseRoutesById","flatRoutes","Object","values","map","d","trimmed","parsed","parsePathname","value","shift","score","child","index","sort","a","b","isIndex","min","rank","matchRoutes","locationSearch","opts","routeParams","foundRoute","find","matchedParams","matchPathname","to","caseSensitive","fuzzy","routeCursor","matchedRoutes","parentRoute","unshift","parseErrors","parsedParamsError","parseParams","parsedParams","assign","err","message","cause","throwOnError","interpolatedPath","interpolatePath","matchId","existingMatch","getRouteMatch","hasLoaders","load","componentTypes","some","preload","routeMatch","routeId","params","joinPaths","updatedAt","routeSearch","isFetching","invalid","error","paramsError","searchError","loadPromise","abortController","AbortController","fetchedAt","match","parentMatch","searchInfo","parentSearchInfo","validator","validateSearch","searchDidChange","cancelMatch","abort","cancelMatches","buildLocation","build","dest","fromPathname","fromMatches","stayingMatches","filter","prevParams","last","nextParams","functionalUpdate","stringifyParams","Boolean","fn","preSearchFilters","flat","postSearchFilters","preFilteredSearch","reduce","prev","next","destSearch","postFilteredSearch","stringifySearch","hashStr","nextState","createHref","unmaskOnReload","buildWithMatches","maskedDest","maskedNext","foundMask","routeMasks","nextMatches","maskedMatches","maskedFinal","final","mask","pick","commitLocation","startTransition","clearTimeout","isSameUrl","replace","nextHistory","apply","resetScroll","buildAndCommitLocation","navigate","toString","fromString","isExternal","URL","loadMatches","latestPromise","firstBadMatchIndex","entries","handleError","code","routerCode","isRedirect","onError","errorHandlerErr","parentContext","beforeLoadContext","beforeLoad","validResolvedMatches","slice","matchPromises","push","parentMatchPromise","handleIfRedirect","componentsPromise","all","component","loaderPromise","_","loaderContext","onErrorError","reject","prevLocation","pathDidChange","debug","previousMatches","exitingMatchIds","includes","enteringMatchIds","stayingMatchIds","hook","preloadRoute","navigateOpts","buildLink","userPreload","preloadDelay","userPreloadDelay","activeOptions","disabled","target","nextOpts","defaultPreload","defaultPreloadDelay","currentPathSplit","nextPathSplit","pathIsFuzzyEqual","every","pathTest","exact","hashTest","includeHash","searchTest","includeSearch","partialDeepEqual","isActive","handleClick","defaultPrevented","button","preventDefault","handleFocus","catch","console","warn","handleTouchStart","handleEnter","preloadTimeout","setTimeout","handleLeave","unsub","subscribe","nextLocation","initialLoad","matchRoute","pending","baseLocation","routerContextValue","createElement","Provider","Matches","useRouterState","useRouter","select","resolvedContext","useContext","warning"],"mappings":"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"}