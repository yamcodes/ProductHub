/**
 * @tanstack/react-router/src/index.tsx
 *
 * Copyright (c) TanStack
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var RouterProvider = require('./RouterProvider.js');
var utils = require('./utils.js');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var React__namespace = /*#__PURE__*/_interopNamespace(React);

const useLayoutEffect = typeof window !== 'undefined' ? React__namespace.useLayoutEffect : React__namespace.useEffect;
const windowKey = 'window';
const delimiter = '___';
let weakScrolledElements = new WeakSet();
let cache;
const sessionsStorage = typeof window !== 'undefined' && window.sessionStorage;
const defaultGetKey = location => location.state.key;
function useScrollRestoration(options) {
  const {
    state,
    subscribe,
    resetNextScrollRef
  } = RouterProvider.useRouter();
  useLayoutEffect(() => {
    const getKey = options?.getKey || defaultGetKey;
    if (sessionsStorage) {
      if (!cache) {
        cache = (() => {
          const storageKey = 'tsr-scroll-restoration-v2';
          const state = JSON.parse(window.sessionStorage.getItem(storageKey) || 'null') || {
            cached: {},
            next: {}
          };
          return {
            state,
            set: updater => {
              cache.state = utils.functionalUpdate(updater, cache.state);
              window.sessionStorage.setItem(storageKey, JSON.stringify(cache.state));
            }
          };
        })();
      }
    }
    const {
      history
    } = window;
    if (history.scrollRestoration) {
      history.scrollRestoration = 'manual';
    }
    const onScroll = event => {
      if (weakScrolledElements.has(event.target)) return;
      weakScrolledElements.add(event.target);
      const elementSelector = event.target === document || event.target === window ? windowKey : getCssSelector(event.target);
      if (!cache.state.next[elementSelector]) {
        cache.set(c => ({
          ...c,
          next: {
            ...c.next,
            [elementSelector]: {
              scrollX: NaN,
              scrollY: NaN
            }
          }
        }));
      }
    };
    const getCssSelector = el => {
      let path = [],
        parent;
      while (parent = el.parentNode) {
        path.unshift(`${el.tagName}:nth-child(${[].indexOf.call(parent.children, el) + 1})`);
        el = parent;
      }
      return `${path.join(' > ')}`.toLowerCase();
    };
    if (typeof document !== 'undefined') {
      document.addEventListener('scroll', onScroll, true);
    }
    const unsubOnBeforeLoad = subscribe('onBeforeLoad', event => {
      if (event.pathChanged) {
        const restoreKey = getKey(event.fromLocation);
        for (const elementSelector in cache.state.next) {
          const entry = cache.state.next[elementSelector];
          if (elementSelector === windowKey) {
            entry.scrollX = window.scrollX || 0;
            entry.scrollY = window.scrollY || 0;
          } else if (elementSelector) {
            const element = document.querySelector(elementSelector);
            entry.scrollX = element?.scrollLeft || 0;
            entry.scrollY = element?.scrollTop || 0;
          }
          cache.set(c => {
            const next = {
              ...c.next
            };
            delete next[elementSelector];
            return {
              ...c,
              next,
              cached: {
                ...c.cached,
                [[restoreKey, elementSelector].join(delimiter)]: entry
              }
            };
          });
        }
      }
    });
    const unsubOnResolved = subscribe('onResolved', event => {
      if (event.pathChanged) {
        if (!resetNextScrollRef.current) {
          return;
        }
        resetNextScrollRef.current = true;
        const getKey = options?.getKey || defaultGetKey;
        const restoreKey = getKey(event.toLocation);
        let windowRestored = false;
        for (const cacheKey in cache.state.cached) {
          const entry = cache.state.cached[cacheKey];
          const [key, elementSelector] = cacheKey.split(delimiter);
          if (key === restoreKey) {
            if (elementSelector === windowKey) {
              windowRestored = true;
              window.scrollTo(entry.scrollX, entry.scrollY);
            } else if (elementSelector) {
              const element = document.querySelector(elementSelector);
              if (element) {
                element.scrollLeft = entry.scrollX;
                element.scrollTop = entry.scrollY;
              }
            }
          }
        }
        if (!windowRestored) {
          window.scrollTo(0, 0);
        }
        cache.set(c => ({
          ...c,
          next: {}
        }));
        weakScrolledElements = new WeakSet();
      }
    });
    return () => {
      document.removeEventListener('scroll', onScroll);
      unsubOnBeforeLoad();
      unsubOnResolved();
    };
  }, []);
}
function ScrollRestoration(props) {
  useScrollRestoration(props);
  return null;
}

exports.ScrollRestoration = ScrollRestoration;
exports.useScrollRestoration = useScrollRestoration;
//# sourceMappingURL=scroll-restoration.js.map
