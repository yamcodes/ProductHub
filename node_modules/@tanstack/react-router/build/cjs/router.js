/**
 * @tanstack/react-router/src/index.tsx
 *
 * Copyright (c) TanStack
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var searchParams = require('./searchParams.js');

//

//

const componentTypes = ['component', 'errorComponent', 'pendingComponent'];
class Router {
  // dehydratedData?: TDehydrated
  // resetNextScroll = false
  // tempLocationKey = `${Math.round(Math.random() * 10000000)}`
  constructor(options) {
    this.options = {
      defaultPreloadDelay: 50,
      context: undefined,
      ...options,
      stringifySearch: options?.stringifySearch ?? searchParams.defaultStringifySearch,
      parseSearch: options?.parseSearch ?? searchParams.defaultParseSearch
    };
    this.routeTree = this.options.routeTree;
  }
  subscribers = new Set();
  subscribe = (eventType, fn) => {
    const listener = {
      eventType,
      fn
    };
    this.subscribers.add(listener);
    return () => {
      this.subscribers.delete(listener);
    };
  };
  emit = routerEvent => {
    this.subscribers.forEach(listener => {
      if (listener.eventType === routerEvent.type) {
        listener.fn(routerEvent);
      }
    });
  };

  // dehydrate = (): DehydratedRouter => {
  //   return {
  //     state: {
  //       dehydratedMatches: state.matches.map((d) =>
  //         pick(d, ['fetchedAt', 'invalid', 'id', 'status', 'updatedAt']),
  //       ),
  //     },
  //   }
  // }

  // hydrate = async (__do_not_use_server_ctx?: HydrationCtx) => {
  //   let _ctx = __do_not_use_server_ctx
  //   // Client hydrates from window
  //   if (typeof document !== 'undefined') {
  //     _ctx = window.__TSR_DEHYDRATED__
  //   }

  //   invariant(
  //     _ctx,
  //     'Expected to find a __TSR_DEHYDRATED__ property on window... but we did not. Did you forget to render <DehydrateRouter /> in your app?',
  //   )

  //   const ctx = _ctx
  //   this.dehydratedData = ctx.payload as any
  //   this.options.hydrate?.(ctx.payload as any)
  //   const dehydratedState = ctx.router.state

  //   let matches = this.matchRoutes(
  //     state.location.pathname,
  //     state.location.search,
  //   ).map((match) => {
  //     const dehydratedMatch = dehydratedState.dehydratedMatches.find(
  //       (d) => d.id === match.id,
  //     )

  //     invariant(
  //       dehydratedMatch,
  //       `Could not find a client-side match for dehydrated match with id: ${match.id}!`,
  //     )

  //     if (dehydratedMatch) {
  //       return {
  //         ...match,
  //         ...dehydratedMatch,
  //       }
  //     }
  //     return match
  //   })

  //   this.setState((s) => {
  //     return {
  //       ...s,
  //       matches: dehydratedState.dehydratedMatches as any,
  //     }
  //   })
  // }

  // TODO:
  // injectedHtml: (string | (() => Promise<string> | string))[] = []

  // TODO:
  // injectHtml = async (html: string | (() => Promise<string> | string)) => {
  //   this.injectedHtml.push(html)
  // }

  // TODO:
  // dehydrateData = <T>(key: any, getData: T | (() => Promise<T> | T)) => {
  //   if (typeof document === 'undefined') {
  //     const strKey = typeof key === 'string' ? key : JSON.stringify(key)

  //     this.injectHtml(async () => {
  //       const id = `__TSR_DEHYDRATED__${strKey}`
  //       const data =
  //         typeof getData === 'function' ? await (getData as any)() : getData
  //       return `<script id='${id}' suppressHydrationWarning>window["__TSR_DEHYDRATED__${escapeJSON(
  //         strKey,
  //       )}"] = ${JSON.stringify(data)}
  //       ;(() => {
  //         var el = document.getElementById('${id}')
  //         el.parentElement.removeChild(el)
  //       })()
  //       </script>`
  //     })

  //     return () => this.hydrateData<T>(key)
  //   }

  //   return () => undefined
  // }

  // hydrateData = <T = unknown>(key: any) => {
  //   if (typeof document !== 'undefined') {
  //     const strKey = typeof key === 'string' ? key : JSON.stringify(key)

  //     return window[`__TSR_DEHYDRATED__${strKey}` as any] as T
  //   }

  //   return undefined
  // }

  // resolveMatchPromise = (matchId: string, key: string, value: any) => {
  //   state.matches
  //     .find((d) => d.id === matchId)
  //     ?.__promisesByKey[key]?.resolve(value)
  // }

  // setRouteMatch = (
  //   id: string,
  //   pending: boolean,
  //   updater: NonNullableUpdater<RouteMatch<TRouteTree>>,
  // ) => {
  //   const key = pending ? 'pendingMatches' : 'matches'

  //   this.setState((prev) => {
  //     return {
  //       ...prev,
  //       [key]: prev[key].map((d) => {
  //         if (d.id === id) {
  //           return functionalUpdate(updater, d)
  //         }

  //         return d
  //       }),
  //     }
  //   })
  // }

  // setPendingRouteMatch = (
  //   id: string,
  //   updater: NonNullableUpdater<RouteMatch<TRouteTree>>,
  // ) => {
  //   this.setRouteMatch(id, true, updater)
  // }
}

// A function that takes an import() argument which is a function and returns a new function that will
// proxy arguments from the caller to the imported function, retaining all type
// information along the way
function lazyFn(fn, key) {
  return async (...args) => {
    const imported = await fn();
    return imported[key || 'default'](...args);
  };
}

exports.Router = Router;
exports.componentTypes = componentTypes;
exports.lazyFn = lazyFn;
//# sourceMappingURL=router.js.map
