/**
 * router-cli
 *
 * Copyright (c) TanStack
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
import * as yargs from 'yargs';
import path from 'path';
import fs from 'fs-extra';
import klaw from 'klaw';
import through2 from 'through2';
import crypto from 'crypto';
import * as babel from '@babel/core';
import * as t from '@babel/types';
import syntaxTS from '@babel/plugin-syntax-typescript';
import chokidar from 'chokidar';

const configFilePathJson = path.resolve(process.cwd(), 'tsr.config.json');
async function getConfig() {
  return fs.readJson(configFilePathJson);
}

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}

const isolatedProperties = ['loader', 'action', 'component', 'errorComponent', 'pendingComponent'];
const getBasePlugins = () => [[syntaxTS, {
  isTSX: true
  // disallowAmbiguousJSXLike: true,
}]];

async function ensureBoilerplate(node, code) {
  var _originalFile$code, _originalFile$code2, _file$code, _file$code2;
  const relativeImportPath = path.relative(node.fullDir, node.genPathNoExt);
  const originalFile = await babel.transformAsync(code, {
    configFile: false,
    babelrc: false,
    plugins: [...getBasePlugins()]
  });
  const file = await babel.transformAsync(code, {
    configFile: false,
    babelrc: false,
    plugins: [...getBasePlugins(), {
      visitor: {
        Program: {
          enter(programPath) {
            // Remove all properties except for our isolated one

            if (node.isRoot) {
              let foundImport = false;
              programPath.traverse({
                ImportSpecifier(importPath) {
                  if (t.isIdentifier(importPath.node.imported) && importPath.node.imported.name === 'createRouteConfig') {
                    foundImport = true;
                  }
                }
              });
              if (!foundImport) {
                programPath.node.body.unshift(babel.template.statement("import { createRouteConfig } from '@tanstack/react-router'")());
              }
            } else {
              let foundImport = false;
              programPath.traverse({
                ImportSpecifier(importPath) {
                  if (t.isIdentifier(importPath.node.imported) && importPath.node.imported.name === 'routeConfig') {
                    foundImport = true;
                    if (t.isImportDeclaration(importPath.parentPath.node)) {
                      if (importPath.parentPath.node.source.value !== relativeImportPath) {
                        importPath.parentPath.node.source.value = relativeImportPath;
                      }
                    }
                  }
                }
              });
              if (!foundImport) {
                programPath.node.body.unshift(babel.template.statement("import { routeConfig } from '" + relativeImportPath + "'")());
              }
            }
          }
        }
      }
    }]
  });
  const separator = node.isRoot ? 'createRouteConfig(' : 'routeConfig.generate(';
  if (!(originalFile != null && originalFile.code)) {
    return (file == null ? void 0 : file.code) + "\n\n" + separator + "{\n\n})";
  }
  const originalHead = originalFile == null ? void 0 : (_originalFile$code = originalFile.code) == null ? void 0 : _originalFile$code.substring(0, originalFile == null ? void 0 : (_originalFile$code2 = originalFile.code) == null ? void 0 : _originalFile$code2.indexOf(separator));
  const generatedHead = file == null ? void 0 : (_file$code = file.code) == null ? void 0 : _file$code.substring(0, file == null ? void 0 : (_file$code2 = file.code) == null ? void 0 : _file$code2.indexOf(separator));
  if (originalHead !== generatedHead) {
    var _originalFile$code3, _originalFile$code4;
    return generatedHead + "\n\n" + (originalFile == null ? void 0 : (_originalFile$code3 = originalFile.code) == null ? void 0 : _originalFile$code3.substring(originalFile == null ? void 0 : (_originalFile$code4 = originalFile.code) == null ? void 0 : _originalFile$code4.indexOf(separator)));
  }
  return;
}
async function isolateOptionToExport(node, code, opts) {
  var _await$babel$transfor;
  return (_await$babel$transfor = await babel.transformAsync(code, {
    configFile: false,
    babelrc: false,
    plugins: [...getBasePlugins(), plugin()],
    ast: true
  })) == null ? void 0 : _await$babel$transfor.code;
  function plugin() {
    return {
      visitor: {
        Program: {
          enter(programPath, state) {
            // If we're the root, handle things a bit differently
            if (node.isRoot) {
              programPath.traverse({
                Identifier(path) {
                  if (path.node.name === 'createRouteConfig' && t.isCallExpression(path.parentPath.node)) {
                    const options = getCreateRouteConfigOptions(path);
                    if (options) {
                      var _path$findParent;
                      const property = options.properties.find(property => {
                        return t.isObjectProperty(property) && t.isIdentifier(property.key) && property.key.name === opts.isolate;
                      });
                      if (t.isObjectProperty(property)) {
                        const program = path.findParent(d => d.isProgram());
                        if (program != null && program.isProgram()) {
                          program.node.body.push(babel.template.statement("export const " + opts.isolate + " = $LOADER")({
                            $LOADER: property.value
                          }));
                        }
                      }
                      (_path$findParent = path.findParent(d => d.isExpressionStatement())) == null ? void 0 : _path$findParent.remove();
                    }
                  }
                }
              });
            }

            // We're not in the root, handle things normally
            if (!node.isRoot) {
              // Remove all properties except for our isolated one
              programPath.traverse({
                Identifier(path) {
                  if (path.node.name === 'generate') {
                    const options = getRouteConfigGenerateOptions(path);
                    if (options) {
                      var _path$findParent2;
                      const property = options.properties.find(property => {
                        return t.isObjectProperty(property) && t.isIdentifier(property.key) && property.key.name === opts.isolate;
                      });
                      if (t.isObjectProperty(property) && t.isIdentifier(property.key)) {
                        if (property.key.name === opts.isolate) {
                          const program = path.findParent(d => d.isProgram());
                          if (program != null && program.isProgram()) {
                            program.node.body.push(babel.template.statement("export const " + opts.isolate + " = $LOADER")({
                              $LOADER: property.value
                            }));
                          }
                        }
                      }
                      (_path$findParent2 = path.findParent(d => d.isExpressionStatement())) == null ? void 0 : _path$findParent2.remove();
                    }
                  }
                }
              });
            }
            cleanUnusedCode(programPath, state, [opts.isolate]);
          }
        }
      }
    };
  }
}
async function detectExports(code) {
  let exported = [];

  // try {
  await babel.transformAsync(code, {
    configFile: false,
    babelrc: false,
    plugins: [...getBasePlugins(), {
      visitor: {
        ExportNamedDeclaration(path) {
          if (t.isVariableDeclaration(path.node.declaration)) {
            var _path$node$declaratio;
            if (t.isVariableDeclarator((_path$node$declaratio = path.node.declaration.declarations) == null ? void 0 : _path$node$declaratio[0])) {
              if (t.isIdentifier(path.node.declaration.declarations[0].id)) {
                exported.push(path.node.declaration.declarations[0].id.name);
              }
            }
          }
        }
      }
    }],
    ast: true
  });
  return exported;
}
async function generateRouteConfig(node, routeCode, imports, clientOnly) {
  var _node$parent, _node$parent2, _node$parent3, _node$parent4, _await$babel$transfor2;
  const relativeParentRoutePath = clientOnly ? node.parent ? removeExt(path.relative(node.genDir, path.resolve((_node$parent = node.parent) == null ? void 0 : _node$parent.genDir, (_node$parent2 = node.parent) == null ? void 0 : _node$parent2.clientFilename))) : "./" + rootRouteClientName : node.parent ? removeExt(path.relative(node.genDir, path.resolve((_node$parent3 = node.parent) == null ? void 0 : _node$parent3.genDir, (_node$parent4 = node.parent) == null ? void 0 : _node$parent4.filename))) : "./" + rootRouteName;
  const pathName = node.isRoot ? undefined : node.fileNameNoExt.startsWith('__') ? undefined : node.fileNameNoExt === 'index' ? '/' : node.fileNameNoExt;
  const routeId = node.isRoot ? undefined : node.fileNameNoExt;
  function plugin() {
    return {
      visitor: {
        Program: {
          enter(programPath, state) {
            // Remove all of the isolated import properties from the config
            programPath.traverse({
              ImportSpecifier(path) {
                if (t.isIdentifier(path.node.imported)) {
                  if (!node.isRoot) {
                    if (path.node.imported.name === 'routeConfig') {
                      path.parentPath.remove();
                      const program = path.findParent(d => d.isProgram());
                      if (program != null && program.isProgram()) {
                        program.node.body.unshift(babel.template.statement("import { routeConfig as parentRouteConfig } from '$IMPORT'")({
                          $IMPORT: relativeParentRoutePath
                        }));
                      }
                    }
                  }
                }
              },
              Identifier(iPath) {
                let options;
                if (node.isRoot) {
                  if (iPath.node.name === 'createRouteConfig') {
                    if (t.isCallExpression(iPath.parentPath.node)) {
                      var _iPath$parentPath$par;
                      if (t.isExpressionStatement((_iPath$parentPath$par = iPath.parentPath.parentPath) == null ? void 0 : _iPath$parentPath$par.node)) {
                        var _iPath$parentPath$par2;
                        (_iPath$parentPath$par2 = iPath.parentPath.parentPath) == null ? void 0 : _iPath$parentPath$par2.replaceWith(t.variableDeclaration('const', [t.variableDeclarator(t.identifier('routeConfig'), iPath.parentPath.node)]));
                      }
                    }
                  }
                } else {
                  if (iPath.node.name === 'generate') {
                    if (t.isMemberExpression(iPath.parentPath.node)) {
                      if (t.isIdentifier(iPath.parentPath.node.object)) {
                        iPath.node.name = 'createRoute';
                        iPath.parentPath.node.object.name = 'parentRouteConfig';
                        options = getRouteConfigGenerateOptions(iPath);
                      }
                    }
                  }
                }
                if (options) {
                  options.properties = [...(pathName ? [t.objectProperty(t.identifier('path'), t.stringLiteral(pathName))] : routeId ? [t.objectProperty(t.identifier('id'), t.stringLiteral(routeId))] : []), ...options.properties.map(property => {
                    if (t.isObjectProperty(property) && t.isIdentifier(property.key) && isolatedProperties.includes(property.key.name)) {
                      const key = property.key.name;
                      if (key === 'loader') {
                        if (clientOnly) {
                          return t.objectProperty(t.identifier('loader'), t.tSAsExpression(t.booleanLiteral(true), t.tsAnyKeyword()));
                        }
                        return t.objectProperty(t.identifier(key), babel.template.expression("(...args) => import('./" + path.relative(node.genDir, node.genPathNoExt) + "-" + key + "').then(d => d." + key + ".apply(d." + key + ", (args as any)))", {
                          plugins: ['typescript']
                        })({}));
                      }
                      if (key === 'action') {
                        if (clientOnly) {
                          return t.objectProperty(t.identifier('action'), t.tSAsExpression(t.booleanLiteral(true), t.tSAnyKeyword()));
                        }
                        return t.objectProperty(t.identifier(key), babel.template.expression("(...payload: Parameters<typeof import('./" + path.relative(node.genDir, node.genPathNoExt) + "-" + key + "').action>) => import('./" + path.relative(node.genDir, node.genPathNoExt) + "-" + key + "').then(d => d." + key + ".apply(d." + key + ", (payload as any)))", {
                          plugins: ['typescript']
                        })({}));
                      }
                      return t.objectProperty(t.identifier(key), babel.template.expression("\n                              lazy(() => import('./" + path.relative(node.genDir, node.genPathNoExt) + "-" + key + "').then(d => ({ default: d." + key + " }) ))")());
                    }
                    return property;
                  })];
                  const program = iPath.findParent(d => d.isProgram());
                  if (program != null && program.isProgram() && options) {
                    const index = program.node.body.findIndex(d => {
                      var _iPath$parentPath$par3;
                      return d.start === ((_iPath$parentPath$par3 = iPath.parentPath.parentPath) == null ? void 0 : _iPath$parentPath$par3.node.start);
                    });
                    if (node.isRoot) {
                      program.node.body[index] = babel.template.statement("const routeConfig = createRouteConfig(\n                          $OPTIONS\n                          )")({
                        $OPTIONS: options
                      });
                    } else {
                      program.node.body[index] = babel.template.statement("const routeConfig = parentRouteConfig.createRoute(\n                          $OPTIONS\n                          )")({
                        $OPTIONS: options
                      });
                    }
                  }
                }
              }
            });
            programPath.node.body.unshift(babel.template.statement("import { lazy } from '@tanstack/react-router'")());

            // Add the routeConfig exports
            programPath.node.body.push(babel.template.statement(clientOnly ? "export { routeConfig, routeConfig as " + node.variable + "Route }" : "export { routeConfig }")());
            cleanUnusedCode(programPath, state, ['routeConfig', node.variable + "Route"]);
          }
        }
      }
    };
  }
  const code = (_await$babel$transfor2 = await babel.transformAsync(routeCode, {
    configFile: false,
    babelrc: false,
    plugins: [...getBasePlugins(), plugin()],
    ast: true
  })) == null ? void 0 : _await$babel$transfor2.code;
  if (!code) {
    // console.log(code, node, imports)
    throw new Error('Error while generating a route file!');
  }
  return code;
}
function getIdentifier(path) {
  const parentPath = path.parentPath;
  if (parentPath.type === 'VariableDeclarator') {
    const pp = parentPath;
    const name = pp.get('id');
    return name.node.type === 'Identifier' ? name : null;
  }
  if (parentPath.type === 'AssignmentExpression') {
    const pp = parentPath;
    const name = pp.get('left');
    return name.node.type === 'Identifier' ? name : null;
  }
  if (path.node.type === 'ArrowFunctionExpression') {
    return null;
  }
  return path.node.id && path.node.id.type === 'Identifier' ? path.get('id') : null;
}
function isIdentifierReferenced(ident) {
  const b = ident.scope.getBinding(ident.node.name);
  if (b && b.referenced) {
    if (b.path.type === 'FunctionDeclaration') {
      return !b.constantViolations.concat(b.referencePaths).every(ref => ref.findParent(p => p === b.path));
    }
    return true;
  }
  return false;
}
function markFunction(path, state) {
  const ident = getIdentifier(path);
  if (ident && ident.node && isIdentifierReferenced(ident)) {
    state.refs.add(ident);
  }
}
function markImport(path, state) {
  const local = path.get('local');
  if (isIdentifierReferenced(local)) {
    state.refs.add(local);
  }
}
function getRouteConfigGenerateOptions(path) {
  var _path$parentPath$pare;
  const tryOptions = node => {
    if (t.isIdentifier(node)) {
      var _path$scope$getBindin;
      const initNode = (_path$scope$getBindin = path.scope.getBinding(node.name)) == null ? void 0 : _path$scope$getBindin.path.node;
      if (t.isVariableDeclarator(initNode)) {
        return tryOptions(initNode.init);
      }
    } else if (t.isObjectExpression(node)) {
      return node;
    }
    return;
  };
  if (t.isMemberExpression(path.parentPath.node) && t.isCallExpression((_path$parentPath$pare = path.parentPath.parentPath) == null ? void 0 : _path$parentPath$pare.node)) {
    var _path$parentPath$pare2;
    const options = (_path$parentPath$pare2 = path.parentPath.parentPath) == null ? void 0 : _path$parentPath$pare2.node.arguments[0];
    return tryOptions(options);
  }
}
function getCreateRouteConfigOptions(path) {
  var _path$parentPath;
  const tryOptions = node => {
    if (t.isIdentifier(node)) {
      var _path$scope$getBindin2;
      const initNode = (_path$scope$getBindin2 = path.scope.getBinding(node.name)) == null ? void 0 : _path$scope$getBindin2.path.node;
      if (t.isVariableDeclarator(initNode)) {
        return tryOptions(initNode.init);
      }
    } else if (t.isObjectExpression(node)) {
      return node;
    }
    return;
  };
  if (t.isCallExpression((_path$parentPath = path.parentPath) == null ? void 0 : _path$parentPath.node)) {
    var _path$parentPath2;
    const options = (_path$parentPath2 = path.parentPath) == null ? void 0 : _path$parentPath2.node.arguments[0];
    return tryOptions(options);
  }
}

// All credit for this amazing function goes to the Next.js team
// (and the Solid.js team for their derivative work).
// https://github.com/vercel/next.js/blob/canary/packages/next/build/babel/plugins/next-ssg-transform.ts
// https://github.com/solidjs/solid-start/blob/main/packages/start/server/routeData.js

function cleanUnusedCode(programPath, state, keepExports) {
  state.refs = new Set();
  state.done = false;
  function markVariable(variablePath, variableState) {
    if (variablePath.node.id.type === 'Identifier') {
      const local = variablePath.get('id');
      if (isIdentifierReferenced(local)) {
        variableState.refs.add(local);
      }
    } else if (variablePath.node.id.type === 'ObjectPattern') {
      const pattern = variablePath.get('id');
      const properties = pattern.get('properties');
      properties.forEach(p => {
        const local = p.get(p.node.type === 'ObjectProperty' ? 'value' : p.node.type === 'RestElement' ? 'argument' : function () {
          throw new Error('invariant');
        }());
        if (isIdentifierReferenced(local)) {
          variableState.refs.add(local);
        }
      });
    } else if (variablePath.node.id.type === 'ArrayPattern') {
      const pattern = variablePath.get('id');
      const elements = pattern.get('elements');
      elements.forEach(e => {
        let local;
        if (e.node && e.node.type === 'Identifier') {
          local = e;
        } else if (e.node && e.node.type === 'RestElement') {
          local = e.get('argument');
        } else {
          return;
        }
        if (isIdentifierReferenced(local)) {
          variableState.refs.add(local);
        }
      });
    }
  }

  // Mark all variables and functions if used
  programPath.traverse({
    VariableDeclarator: markVariable,
    FunctionDeclaration: markFunction,
    FunctionExpression: markFunction,
    ArrowFunctionExpression: markFunction,
    ImportSpecifier: markImport,
    ImportDefaultSpecifier: markImport,
    ImportNamespaceSpecifier: markImport,
    ExportDefaultDeclaration: markImport,
    // ExportNamedDeclaration(path, state) {
    //   if (t.isVariableDeclaration(path.node.declaration)) {
    //     if (t.isVariableDeclarator(path.node.declaration.declarations?.[0])) {
    //       if (t.isIdentifier(path.node.declaration.declarations[0].id)) {
    //         if (
    //           keepExports.includes(
    //             path.node.declaration.declarations[0].id.name,
    //           )
    //         ) {
    //           return
    //         }
    //       }
    //       path.replaceWith(path.node.declaration.declarations[0])
    //       return
    //     }
    //   }
    //   path.remove()
    // },
    ImportDeclaration: path => {
      if (path.node.source.value.endsWith('.css')) {
        path.remove();
      }
    }
  }, state);

  // Sweet all of the remaining references and remove unused ones
  const refs = state.refs;
  let count;
  function sweepFunction(sweepPath) {
    const ident = getIdentifier(sweepPath);
    if (ident && ident.node && refs.has(ident) && !isIdentifierReferenced(ident)) {
      ++count;
      if (t.isAssignmentExpression(sweepPath.parentPath) || t.isVariableDeclarator(sweepPath.parentPath)) {
        sweepPath.parentPath.remove();
      } else {
        sweepPath.remove();
      }
    }
  }
  function sweepImport(sweepPath) {
    const local = sweepPath.get('local');
    if (refs.has(local) && !isIdentifierReferenced(local)) {
      ++count;
      sweepPath.remove();
      if (sweepPath.parent.specifiers.length === 0) {
        sweepPath.parentPath.remove();
      }
    }
  }
  do {
    programPath.scope.crawl();
    count = 0;
    programPath.traverse({
      VariableDeclarator(variablePath) {
        if (variablePath.node.id.type === 'Identifier') {
          const local = variablePath.get('id');
          if (refs.has(local) && !isIdentifierReferenced(local)) {
            ++count;
            variablePath.remove();
          }
        } else if (variablePath.node.id.type === 'ObjectPattern') {
          const pattern = variablePath.get('id');
          const beforeCount = count;
          const properties = pattern.get('properties');
          properties.forEach(p => {
            const local = p.get(p.node.type === 'ObjectProperty' ? 'value' : p.node.type === 'RestElement' ? 'argument' : function () {
              throw new Error('invariant');
            }());
            if (refs.has(local) && !isIdentifierReferenced(local)) {
              ++count;
              p.remove();
            }
          });
          if (beforeCount !== count && pattern.get('properties').length < 1) {
            variablePath.remove();
          }
        } else if (variablePath.node.id.type === 'ArrayPattern') {
          const pattern = variablePath.get('id');
          const beforeCount = count;
          const elements = pattern.get('elements');
          elements.forEach(e => {
            let local;
            if (e.node && e.node.type === 'Identifier') {
              local = e;
            } else if (e.node && e.node.type === 'RestElement') {
              local = e.get('argument');
            } else {
              return;
            }
            if (refs.has(local) && !isIdentifierReferenced(local)) {
              ++count;
              e.remove();
            }
          });
          if (beforeCount !== count && pattern.get('elements').length < 1) {
            variablePath.remove();
          }
        }
      },
      FunctionDeclaration: sweepFunction,
      FunctionExpression: sweepFunction,
      ArrowFunctionExpression: sweepFunction,
      ImportSpecifier: sweepImport,
      ImportDefaultSpecifier: sweepImport,
      ImportNamespaceSpecifier: sweepImport
    });
  } while (count);

  // Do we need the * import for react?
  let hasReact = false;

  // Mark react elements as having react
  programPath.traverse({
    JSXElement(path) {
      hasReact = true;
    }
  });
  if (!hasReact) {
    // Mark all variables and functions if used
    programPath.traverse({
      ImportDeclaration(path) {
        if (t.isStringLiteral(path.node.source) && path.node.source.value === 'react' && t.isImportNamespaceSpecifier(path.node.specifiers[0])) {
          path.remove();
        }
      }
    });
  }
}

let latestTask = 0;
const rootRouteName = '__root';
const rootRouteClientName = '__root.client';
let nodeCache = undefined;
async function generator(config) {
  console.log();
  let first = false;
  if (!nodeCache) {
    first = true;
    console.log('🔄 Generating routes...');
    nodeCache = [];
  } else {
    console.log('♻️  Regenerating routes...');
  }
  const taskId = latestTask + 1;
  latestTask = taskId;
  const checkLatest = () => {
    if (latestTask !== taskId) {
      console.log("- Skipping since file changes were made while generating.");
      return false;
    }
    return true;
  };
  const start = Date.now();
  let routeConfigImports = [];
  let routeConfigClientImports = [];
  let nodesChanged = false;
  const fileQueue = [];
  const queueWriteFile = (filename, content) => {
    fileQueue.push([filename, content]);
  };
  async function reparent(dir) {
    let dirList;
    try {
      dirList = await fs.readdir(dir);
    } catch (err) {
      console.log();
      console.error('TSR: Error reading the config.routesDirectory. Does it exist?');
      console.log();
      throw err;
    }
    const dirListCombo = multiSortBy(await Promise.all(dirList.map(async filename => {
      const fullPath = path.resolve(dir, filename);
      const stat = await fs.lstat(fullPath);
      const ext = path.extname(filename);
      const clientFilename = filename.replace(ext, ".client" + ext);
      const pathFromRoutes = path.relative(config.routesDirectory, fullPath);
      const genPath = path.resolve(config.routeGenDirectory, pathFromRoutes);
      const genPathNoExt = removeExt(genPath);
      const genDir = path.resolve(genPath, '..');
      const fileNameNoExt = removeExt(filename);
      return {
        filename,
        clientFilename,
        fileNameNoExt,
        fullPath,
        fullDir: dir,
        genPath,
        genDir,
        genPathNoExt,
        variable: fileToVariable(removeExt(pathFromRoutes)),
        isDirectory: stat.isDirectory(),
        isIndex: fileNameNoExt === 'index'
      };
    })), [d => d.fileNameNoExt === 'index' ? -1 : 1, d => d.fileNameNoExt, d => d.isDirectory ? 1 : -1]);
    const reparented = [];
    dirListCombo.forEach(async (d, i) => {
      if (d.isDirectory) {
        const parent = reparented.find(dd => !dd.isDirectory && dd.fileNameNoExt === d.filename);
        if (parent) {
          parent.childRoutesDir = d.fullPath;
        } else {
          reparented.push(d);
        }
      } else {
        reparented.push(d);
      }
    });
    return Promise.all(reparented.map(async d => {
      if (d.childRoutesDir) {
        const children = await reparent(d.childRoutesDir);
        d = _extends({}, d, {
          children
        });
        children.forEach(child => child.parent = d);
        return d;
      }
      return d;
    }));
  }
  const reparented = await reparent(config.routesDirectory);
  async function buildRouteConfig(nodes, depth) {
    if (depth === void 0) {
      depth = 1;
    }
    const children = nodes.map(async n => {
      var _node$children;
      let node = nodeCache.find(d => d.fullPath === n.fullPath);
      if (node) {
        node.new = false;
      } else {
        node = n;
        nodeCache.push(node);
        if (!first) {
          node.new = true;
        }
      }
      node.version = latestTask;
      if (node.fileNameNoExt === '__root') {
        node.isRoot = true;
      }
      const routeCode = await fs.readFile(node.fullPath, 'utf-8');
      const hashSum = crypto.createHash('sha256');
      hashSum.update(routeCode);
      const hash = hashSum.digest('hex');
      node.changed = node.hash !== hash;
      if (node.changed) {
        nodesChanged = true;
        node.hash = hash;
        try {
          // Ensure the boilerplate for the route exists
          const code = await ensureBoilerplate(node, routeCode);
          if (code) {
            await fs.writeFile(node.fullPath, code);
          }
          let imports = [];
          if (!node.isRoot) {
            // Generate the isolated files
            const transforms = await Promise.all(isolatedProperties.map(async key => {
              let exported = false;
              let exports = [];
              const transformed = await isolateOptionToExport(node, routeCode, {
                isolate: key
              });
              if (transformed) {
                exports = await detectExports(transformed);
                if (exports.includes(key)) {
                  exported = true;
                }
              }
              return {
                key,
                exported,
                code: transformed
              };
            }));
            imports = transforms.filter(_ref => {
              let {
                exported
              } = _ref;
              return exported;
            });
            node.importedFiles = await Promise.all(imports.map(_ref2 => {
              let {
                key,
                code
              } = _ref2;
              const importFilename = node.genPathNoExt + "-" + key + ".tsx";
              queueWriteFile(importFilename, code);
              return importFilename;
            }));
          }
          const routeConfigCode = await generateRouteConfig(node, routeCode, imports, false);
          const clientRouteConfigCode = await generateRouteConfig(node, routeCode, imports, true);
          queueWriteFile(node.genPath, routeConfigCode);
          queueWriteFile(path.resolve(node.genDir, node.clientFilename), clientRouteConfigCode);
        } catch (err) {
          node.hash = '';
        }
      }
      routeConfigImports.push("import { routeConfig as " + node.variable + "Route } from './" + removeExt(path.relative(config.routeGenDirectory, node.genPath)) + "'");
      routeConfigClientImports.push("import { routeConfig as " + node.variable + "Route } from './" + removeExt(path.relative(config.routeGenDirectory, path.resolve(node.genDir, node.clientFilename))) + "'");
      if (node.isRoot) {
        return undefined;
      }
      const route = node.variable + "Route";
      if ((_node$children = node.children) != null && _node$children.length) {
        const childConfigs = await buildRouteConfig(node.children, depth + 1);
        return route + ".addChildren([\n" + spaces(depth * 4) + childConfigs + "\n" + spaces(depth * 2) + "])";
      }
      return route;
    });
    return (await Promise.all(children)).filter(Boolean).join(",\n" + spaces(depth * 2));
  }
  const routeConfigChildrenText = await buildRouteConfig(reparented);
  routeConfigImports = multiSortBy(routeConfigImports, [d => d.includes('__root') ? -1 : 1, d => d.split('/').length, d => d.endsWith("index'") ? -1 : 1, d => d]);
  routeConfigClientImports = multiSortBy(routeConfigClientImports, [d => d.includes('__root') ? -1 : 1, d => d.split('/').length, d => d.endsWith("index.client'") ? -1 : 1, d => d]);
  const routeConfig = "export const routeConfig = rootRoute.addChildren([\n  " + routeConfigChildrenText + "\n])\nexport type __GeneratedRouteConfig = typeof routeConfig";
  const routeConfigClient = "export const routeConfigClient = rootRoute.addChildren([\n  " + routeConfigChildrenText + "\n]) as __GeneratedRouteConfig";
  const routeConfigFileContent = [routeConfigImports.join('\n'), routeConfig].join('\n\n');
  const routeConfigClientFileContent = ["import type { __GeneratedRouteConfig } from './routeConfig'", routeConfigClientImports.join('\n'), routeConfigClient].join('\n\n');
  if (nodesChanged) {
    queueWriteFile(path.resolve(config.routeGenDirectory, 'routeConfig.ts'), routeConfigFileContent);
    queueWriteFile(path.resolve(config.routeGenDirectory, 'routeConfig.client.ts'), routeConfigClientFileContent);
  }

  // Do all of our file system manipulation at the end
  await fs.mkdir(config.routeGenDirectory, {
    recursive: true
  });
  if (!checkLatest()) return;
  await Promise.all(fileQueue.map(async _ref3 => {
    let [filename, content] = _ref3;
    await fs.ensureDir(path.dirname(filename));
    const exists = await fs.pathExists(filename);
    let current = '';
    if (exists) {
      current = await fs.readFile(filename, 'utf-8');
    }
    if (current !== content) {
      await fs.writeFile(filename, content);
    }
  }));
  if (!checkLatest()) return;
  const allFiles = await getAllFiles(config.routeGenDirectory);
  if (!checkLatest()) return;
  const removedNodes = [];
  nodeCache = nodeCache.filter(d => {
    if (d.version !== latestTask) {
      removedNodes.push(d);
      return false;
    }
    return true;
  });
  const newNodes = nodeCache.filter(d => d.new);
  const updatedNodes = nodeCache.filter(d => !d.new && d.changed);
  const unusedFiles = allFiles.filter(d => {
    if (d === path.resolve(config.routeGenDirectory, 'routeConfig.ts') || d === path.resolve(config.routeGenDirectory, 'routeConfig.client.ts')) {
      return false;
    }
    let node = nodeCache.find(n => {
      var _n$importedFiles;
      return n.genPath === d || path.resolve(n.genDir, n.clientFilename) === d || ((_n$importedFiles = n.importedFiles) == null ? void 0 : _n$importedFiles.includes(d));
    });
    return !node;
  });
  await Promise.all(unusedFiles.map(d => {
    fs.remove(d);
  }));
  console.log("\uD83C\uDF32 Processed " + nodeCache.length + " routes in " + (Date.now() - start) + "ms");
  if (newNodes.length || updatedNodes.length || removedNodes.length) {
    if (newNodes.length) {
      console.log("\uD83E\uDD73 Added " + newNodes.length + " new routes");
    }
    if (updatedNodes.length) {
      console.log("\u2705 Updated " + updatedNodes.length + " routes");
    }
    if (removedNodes.length) {
      console.log("\uD83D\uDDD1 Removed " + removedNodes.length + " unused routes");
    }
  } else {
    console.log("\uD83C\uDF89 No changes were found. Carry on!");
  }
}
function getAllFiles(dir) {
  return new Promise((resolve, reject) => {
    const excludeDirFilter = through2.obj(function (item, enc, next) {
      if (!item.stats.isDirectory()) this.push(item);
      next();
    });
    const items = [];
    klaw(dir).pipe(excludeDirFilter).on('data', item => items.push(item.path)).on('error', err => reject(err)).on('end', () => resolve(items));
  });
}
function fileToVariable(d) {
  return d.split('/').map((d, i) => i > 0 ? capitalize(d) : d).join('').replace(/([^a-zA-Z0-9]|[\.])/gm, '');
}
function removeExt(d) {
  return d.substring(0, d.lastIndexOf('.')) || d;
}
function spaces(d) {
  return Array.from({
    length: d
  }).map(() => ' ').join('');
}
function multiSortBy(arr, accessors) {
  if (accessors === void 0) {
    accessors = [d => d];
  }
  return arr.map((d, i) => [d, i]).sort((_ref4, _ref5) => {
    let [a, ai] = _ref4;
    let [b, bi] = _ref5;
    for (const accessor of accessors) {
      const ao = accessor(a);
      const bo = accessor(b);
      if (typeof ao === 'undefined') {
        if (typeof bo === 'undefined') {
          continue;
        }
        return 1;
      }
      if (ao === bo) {
        continue;
      }
      return ao > bo ? 1 : -1;
    }
    return ai - bi;
  }).map(_ref6 => {
    let [d] = _ref6;
    return d;
  });
}
function capitalize(s) {
  if (typeof s !== 'string') return '';
  return s.charAt(0).toUpperCase() + s.slice(1);
}

async function generate(config) {
  try {
    await generator(config);
    process.exit(0);
  } catch (err) {
    console.error(err);
    process.exit(1);
  }
}

async function watch() {
  const configWatcher = chokidar.watch(path.resolve(process.cwd(), 'tsr.config.js'));
  let watcher = new chokidar.FSWatcher();
  const generatorWatcher = async () => {
    const config = await getConfig();
    watcher.close();
    console.log("TSR: Watching routes (" + config.routesDirectory + ")...");
    watcher = chokidar.watch(config.routesDirectory);
    watcher.on('ready', async () => {
      try {
        await generator(config);
      } catch (err) {
        console.error(err);
        console.log();
      }
      const handle = async () => {
        try {
          await generator(config);
        } catch (err) {
          console.error(err);
          console.log();
        }
      };
      watcher.on('change', handle);
      watcher.on('add', handle);
      watcher.on('addDir', handle);
      watcher.on('unlink', handle);
      watcher.on('unlinkDir', handle);
    });
  };
  configWatcher.on('ready', generatorWatcher);
  configWatcher.on('change', generatorWatcher);
}

main();
function main() {
  yargs.scriptName('tsr').usage('$0 <cmd> [args]').command('generate', 'Generate the routes for a project', async argv => {
    const config = await getConfig();
    await generate(config);
  }).command('watch', 'Continuously watch and generate the routes for a project', async argv => {
    watch();
  }).help().argv;
}

export { main };
//# sourceMappingURL=index.js.map
