/**
 * router-cli
 *
 * Copyright (c) TanStack
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _rollupPluginBabelHelpers = require('./_virtual/_rollupPluginBabelHelpers.js');
var klaw = require('klaw');
var through2 = require('through2');
var path = require('path');
var fs = require('fs-extra');
var crypto = require('crypto');
var transformCode = require('./transformCode.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var klaw__default = /*#__PURE__*/_interopDefaultLegacy(klaw);
var through2__default = /*#__PURE__*/_interopDefaultLegacy(through2);
var path__default = /*#__PURE__*/_interopDefaultLegacy(path);
var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);
var crypto__default = /*#__PURE__*/_interopDefaultLegacy(crypto);

let latestTask = 0;
const rootRouteName = '__root';
const rootRouteClientName = '__root.client';
let nodeCache = undefined;
async function generator(config) {
  console.log();
  let first = false;
  if (!nodeCache) {
    first = true;
    console.log('🔄 Generating routes...');
    nodeCache = [];
  } else {
    console.log('♻️  Regenerating routes...');
  }
  const taskId = latestTask + 1;
  latestTask = taskId;
  const checkLatest = () => {
    if (latestTask !== taskId) {
      console.log("- Skipping since file changes were made while generating.");
      return false;
    }
    return true;
  };
  const start = Date.now();
  let routeConfigImports = [];
  let routeConfigClientImports = [];
  let nodesChanged = false;
  const fileQueue = [];
  const queueWriteFile = (filename, content) => {
    fileQueue.push([filename, content]);
  };
  async function reparent(dir) {
    let dirList;
    try {
      dirList = await fs__default["default"].readdir(dir);
    } catch (err) {
      console.log();
      console.error('TSR: Error reading the config.routesDirectory. Does it exist?');
      console.log();
      throw err;
    }
    const dirListCombo = multiSortBy(await Promise.all(dirList.map(async filename => {
      const fullPath = path__default["default"].resolve(dir, filename);
      const stat = await fs__default["default"].lstat(fullPath);
      const ext = path__default["default"].extname(filename);
      const clientFilename = filename.replace(ext, ".client" + ext);
      const pathFromRoutes = path__default["default"].relative(config.routesDirectory, fullPath);
      const genPath = path__default["default"].resolve(config.routeGenDirectory, pathFromRoutes);
      const genPathNoExt = removeExt(genPath);
      const genDir = path__default["default"].resolve(genPath, '..');
      const fileNameNoExt = removeExt(filename);
      return {
        filename,
        clientFilename,
        fileNameNoExt,
        fullPath,
        fullDir: dir,
        genPath,
        genDir,
        genPathNoExt,
        variable: fileToVariable(removeExt(pathFromRoutes)),
        isDirectory: stat.isDirectory(),
        isIndex: fileNameNoExt === 'index'
      };
    })), [d => d.fileNameNoExt === 'index' ? -1 : 1, d => d.fileNameNoExt, d => d.isDirectory ? 1 : -1]);
    const reparented = [];
    dirListCombo.forEach(async (d, i) => {
      if (d.isDirectory) {
        const parent = reparented.find(dd => !dd.isDirectory && dd.fileNameNoExt === d.filename);
        if (parent) {
          parent.childRoutesDir = d.fullPath;
        } else {
          reparented.push(d);
        }
      } else {
        reparented.push(d);
      }
    });
    return Promise.all(reparented.map(async d => {
      if (d.childRoutesDir) {
        const children = await reparent(d.childRoutesDir);
        d = _rollupPluginBabelHelpers["extends"]({}, d, {
          children
        });
        children.forEach(child => child.parent = d);
        return d;
      }
      return d;
    }));
  }
  const reparented = await reparent(config.routesDirectory);
  async function buildRouteConfig(nodes, depth) {
    if (depth === void 0) {
      depth = 1;
    }
    const children = nodes.map(async n => {
      var _node$children;
      let node = nodeCache.find(d => d.fullPath === n.fullPath);
      if (node) {
        node.new = false;
      } else {
        node = n;
        nodeCache.push(node);
        if (!first) {
          node.new = true;
        }
      }
      node.version = latestTask;
      if (node.fileNameNoExt === '__root') {
        node.isRoot = true;
      }
      const routeCode = await fs__default["default"].readFile(node.fullPath, 'utf-8');
      const hashSum = crypto__default["default"].createHash('sha256');
      hashSum.update(routeCode);
      const hash = hashSum.digest('hex');
      node.changed = node.hash !== hash;
      if (node.changed) {
        nodesChanged = true;
        node.hash = hash;
        try {
          // Ensure the boilerplate for the route exists
          const code = await transformCode.ensureBoilerplate(node, routeCode);
          if (code) {
            await fs__default["default"].writeFile(node.fullPath, code);
          }
          let imports = [];
          if (!node.isRoot) {
            // Generate the isolated files
            const transforms = await Promise.all(transformCode.isolatedProperties.map(async key => {
              let exported = false;
              let exports = [];
              const transformed = await transformCode.isolateOptionToExport(node, routeCode, {
                isolate: key
              });
              if (transformed) {
                exports = await transformCode.detectExports(transformed);
                if (exports.includes(key)) {
                  exported = true;
                }
              }
              return {
                key,
                exported,
                code: transformed
              };
            }));
            imports = transforms.filter(_ref => {
              let {
                exported
              } = _ref;
              return exported;
            });
            node.importedFiles = await Promise.all(imports.map(_ref2 => {
              let {
                key,
                code
              } = _ref2;
              const importFilename = node.genPathNoExt + "-" + key + ".tsx";
              queueWriteFile(importFilename, code);
              return importFilename;
            }));
          }
          const routeConfigCode = await transformCode.generateRouteConfig(node, routeCode, imports, false);
          const clientRouteConfigCode = await transformCode.generateRouteConfig(node, routeCode, imports, true);
          queueWriteFile(node.genPath, routeConfigCode);
          queueWriteFile(path__default["default"].resolve(node.genDir, node.clientFilename), clientRouteConfigCode);
        } catch (err) {
          node.hash = '';
        }
      }
      routeConfigImports.push("import { routeConfig as " + node.variable + "Route } from './" + removeExt(path__default["default"].relative(config.routeGenDirectory, node.genPath)) + "'");
      routeConfigClientImports.push("import { routeConfig as " + node.variable + "Route } from './" + removeExt(path__default["default"].relative(config.routeGenDirectory, path__default["default"].resolve(node.genDir, node.clientFilename))) + "'");
      if (node.isRoot) {
        return undefined;
      }
      const route = node.variable + "Route";
      if ((_node$children = node.children) != null && _node$children.length) {
        const childConfigs = await buildRouteConfig(node.children, depth + 1);
        return route + ".addChildren([\n" + spaces(depth * 4) + childConfigs + "\n" + spaces(depth * 2) + "])";
      }
      return route;
    });
    return (await Promise.all(children)).filter(Boolean).join(",\n" + spaces(depth * 2));
  }
  const routeConfigChildrenText = await buildRouteConfig(reparented);
  routeConfigImports = multiSortBy(routeConfigImports, [d => d.includes('__root') ? -1 : 1, d => d.split('/').length, d => d.endsWith("index'") ? -1 : 1, d => d]);
  routeConfigClientImports = multiSortBy(routeConfigClientImports, [d => d.includes('__root') ? -1 : 1, d => d.split('/').length, d => d.endsWith("index.client'") ? -1 : 1, d => d]);
  const routeConfig = "export const routeConfig = rootRoute.addChildren([\n  " + routeConfigChildrenText + "\n])\nexport type __GeneratedRouteConfig = typeof routeConfig";
  const routeConfigClient = "export const routeConfigClient = rootRoute.addChildren([\n  " + routeConfigChildrenText + "\n]) as __GeneratedRouteConfig";
  const routeConfigFileContent = [routeConfigImports.join('\n'), routeConfig].join('\n\n');
  const routeConfigClientFileContent = ["import type { __GeneratedRouteConfig } from './routeConfig'", routeConfigClientImports.join('\n'), routeConfigClient].join('\n\n');
  if (nodesChanged) {
    queueWriteFile(path__default["default"].resolve(config.routeGenDirectory, 'routeConfig.ts'), routeConfigFileContent);
    queueWriteFile(path__default["default"].resolve(config.routeGenDirectory, 'routeConfig.client.ts'), routeConfigClientFileContent);
  }

  // Do all of our file system manipulation at the end
  await fs__default["default"].mkdir(config.routeGenDirectory, {
    recursive: true
  });
  if (!checkLatest()) return;
  await Promise.all(fileQueue.map(async _ref3 => {
    let [filename, content] = _ref3;
    await fs__default["default"].ensureDir(path__default["default"].dirname(filename));
    const exists = await fs__default["default"].pathExists(filename);
    let current = '';
    if (exists) {
      current = await fs__default["default"].readFile(filename, 'utf-8');
    }
    if (current !== content) {
      await fs__default["default"].writeFile(filename, content);
    }
  }));
  if (!checkLatest()) return;
  const allFiles = await getAllFiles(config.routeGenDirectory);
  if (!checkLatest()) return;
  const removedNodes = [];
  nodeCache = nodeCache.filter(d => {
    if (d.version !== latestTask) {
      removedNodes.push(d);
      return false;
    }
    return true;
  });
  const newNodes = nodeCache.filter(d => d.new);
  const updatedNodes = nodeCache.filter(d => !d.new && d.changed);
  const unusedFiles = allFiles.filter(d => {
    if (d === path__default["default"].resolve(config.routeGenDirectory, 'routeConfig.ts') || d === path__default["default"].resolve(config.routeGenDirectory, 'routeConfig.client.ts')) {
      return false;
    }
    let node = nodeCache.find(n => {
      var _n$importedFiles;
      return n.genPath === d || path__default["default"].resolve(n.genDir, n.clientFilename) === d || ((_n$importedFiles = n.importedFiles) == null ? void 0 : _n$importedFiles.includes(d));
    });
    return !node;
  });
  await Promise.all(unusedFiles.map(d => {
    fs__default["default"].remove(d);
  }));
  console.log("\uD83C\uDF32 Processed " + nodeCache.length + " routes in " + (Date.now() - start) + "ms");
  if (newNodes.length || updatedNodes.length || removedNodes.length) {
    if (newNodes.length) {
      console.log("\uD83E\uDD73 Added " + newNodes.length + " new routes");
    }
    if (updatedNodes.length) {
      console.log("\u2705 Updated " + updatedNodes.length + " routes");
    }
    if (removedNodes.length) {
      console.log("\uD83D\uDDD1 Removed " + removedNodes.length + " unused routes");
    }
  } else {
    console.log("\uD83C\uDF89 No changes were found. Carry on!");
  }
}
function getAllFiles(dir) {
  return new Promise((resolve, reject) => {
    const excludeDirFilter = through2__default["default"].obj(function (item, enc, next) {
      if (!item.stats.isDirectory()) this.push(item);
      next();
    });
    const items = [];
    klaw__default["default"](dir).pipe(excludeDirFilter).on('data', item => items.push(item.path)).on('error', err => reject(err)).on('end', () => resolve(items));
  });
}
function fileToVariable(d) {
  return d.split('/').map((d, i) => i > 0 ? capitalize(d) : d).join('').replace(/([^a-zA-Z0-9]|[\.])/gm, '');
}
function removeExt(d) {
  return d.substring(0, d.lastIndexOf('.')) || d;
}
function spaces(d) {
  return Array.from({
    length: d
  }).map(() => ' ').join('');
}
function multiSortBy(arr, accessors) {
  if (accessors === void 0) {
    accessors = [d => d];
  }
  return arr.map((d, i) => [d, i]).sort((_ref4, _ref5) => {
    let [a, ai] = _ref4;
    let [b, bi] = _ref5;
    for (const accessor of accessors) {
      const ao = accessor(a);
      const bo = accessor(b);
      if (typeof ao === 'undefined') {
        if (typeof bo === 'undefined') {
          continue;
        }
        return 1;
      }
      if (ao === bo) {
        continue;
      }
      return ao > bo ? 1 : -1;
    }
    return ai - bi;
  }).map(_ref6 => {
    let [d] = _ref6;
    return d;
  });
}
function capitalize(s) {
  if (typeof s !== 'string') return '';
  return s.charAt(0).toUpperCase() + s.slice(1);
}

exports.generator = generator;
exports.multiSortBy = multiSortBy;
exports.removeExt = removeExt;
exports.rootRouteClientName = rootRouteClientName;
exports.rootRouteName = rootRouteName;
//# sourceMappingURL=generator.js.map
