/**
 * router-cli
 *
 * Copyright (c) TanStack
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var babel = require('@babel/core');
var t = require('@babel/types');
var syntaxTS = require('@babel/plugin-syntax-typescript');
var generator = require('./generator.js');
var path = require('path');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var babel__namespace = /*#__PURE__*/_interopNamespace(babel);
var t__namespace = /*#__PURE__*/_interopNamespace(t);
var syntaxTS__default = /*#__PURE__*/_interopDefaultLegacy(syntaxTS);
var path__default = /*#__PURE__*/_interopDefaultLegacy(path);

const isolatedProperties = ['loader', 'action', 'component', 'errorComponent', 'pendingComponent'];
const getBasePlugins = () => [[syntaxTS__default["default"], {
  isTSX: true
  // disallowAmbiguousJSXLike: true,
}]];

async function ensureBoilerplate(node, code) {
  var _originalFile$code, _originalFile$code2, _file$code, _file$code2;
  const relativeImportPath = path__default["default"].relative(node.fullDir, node.genPathNoExt);
  const originalFile = await babel__namespace.transformAsync(code, {
    configFile: false,
    babelrc: false,
    plugins: [...getBasePlugins()]
  });
  const file = await babel__namespace.transformAsync(code, {
    configFile: false,
    babelrc: false,
    plugins: [...getBasePlugins(), {
      visitor: {
        Program: {
          enter(programPath) {
            // Remove all properties except for our isolated one

            if (node.isRoot) {
              let foundImport = false;
              programPath.traverse({
                ImportSpecifier(importPath) {
                  if (t__namespace.isIdentifier(importPath.node.imported) && importPath.node.imported.name === 'createRouteConfig') {
                    foundImport = true;
                  }
                }
              });
              if (!foundImport) {
                programPath.node.body.unshift(babel__namespace.template.statement("import { createRouteConfig } from '@tanstack/react-router'")());
              }
            } else {
              let foundImport = false;
              programPath.traverse({
                ImportSpecifier(importPath) {
                  if (t__namespace.isIdentifier(importPath.node.imported) && importPath.node.imported.name === 'routeConfig') {
                    foundImport = true;
                    if (t__namespace.isImportDeclaration(importPath.parentPath.node)) {
                      if (importPath.parentPath.node.source.value !== relativeImportPath) {
                        importPath.parentPath.node.source.value = relativeImportPath;
                      }
                    }
                  }
                }
              });
              if (!foundImport) {
                programPath.node.body.unshift(babel__namespace.template.statement("import { routeConfig } from '" + relativeImportPath + "'")());
              }
            }
          }
        }
      }
    }]
  });
  const separator = node.isRoot ? 'createRouteConfig(' : 'routeConfig.generate(';
  if (!(originalFile != null && originalFile.code)) {
    return (file == null ? void 0 : file.code) + "\n\n" + separator + "{\n\n})";
  }
  const originalHead = originalFile == null ? void 0 : (_originalFile$code = originalFile.code) == null ? void 0 : _originalFile$code.substring(0, originalFile == null ? void 0 : (_originalFile$code2 = originalFile.code) == null ? void 0 : _originalFile$code2.indexOf(separator));
  const generatedHead = file == null ? void 0 : (_file$code = file.code) == null ? void 0 : _file$code.substring(0, file == null ? void 0 : (_file$code2 = file.code) == null ? void 0 : _file$code2.indexOf(separator));
  if (originalHead !== generatedHead) {
    var _originalFile$code3, _originalFile$code4;
    return generatedHead + "\n\n" + (originalFile == null ? void 0 : (_originalFile$code3 = originalFile.code) == null ? void 0 : _originalFile$code3.substring(originalFile == null ? void 0 : (_originalFile$code4 = originalFile.code) == null ? void 0 : _originalFile$code4.indexOf(separator)));
  }
  return;
}
async function isolateOptionToExport(node, code, opts) {
  var _await$babel$transfor;
  return (_await$babel$transfor = await babel__namespace.transformAsync(code, {
    configFile: false,
    babelrc: false,
    plugins: [...getBasePlugins(), plugin()],
    ast: true
  })) == null ? void 0 : _await$babel$transfor.code;
  function plugin() {
    return {
      visitor: {
        Program: {
          enter(programPath, state) {
            // If we're the root, handle things a bit differently
            if (node.isRoot) {
              programPath.traverse({
                Identifier(path) {
                  if (path.node.name === 'createRouteConfig' && t__namespace.isCallExpression(path.parentPath.node)) {
                    const options = getCreateRouteConfigOptions(path);
                    if (options) {
                      var _path$findParent;
                      const property = options.properties.find(property => {
                        return t__namespace.isObjectProperty(property) && t__namespace.isIdentifier(property.key) && property.key.name === opts.isolate;
                      });
                      if (t__namespace.isObjectProperty(property)) {
                        const program = path.findParent(d => d.isProgram());
                        if (program != null && program.isProgram()) {
                          program.node.body.push(babel__namespace.template.statement("export const " + opts.isolate + " = $LOADER")({
                            $LOADER: property.value
                          }));
                        }
                      }
                      (_path$findParent = path.findParent(d => d.isExpressionStatement())) == null ? void 0 : _path$findParent.remove();
                    }
                  }
                }
              });
            }

            // We're not in the root, handle things normally
            if (!node.isRoot) {
              // Remove all properties except for our isolated one
              programPath.traverse({
                Identifier(path) {
                  if (path.node.name === 'generate') {
                    const options = getRouteConfigGenerateOptions(path);
                    if (options) {
                      var _path$findParent2;
                      const property = options.properties.find(property => {
                        return t__namespace.isObjectProperty(property) && t__namespace.isIdentifier(property.key) && property.key.name === opts.isolate;
                      });
                      if (t__namespace.isObjectProperty(property) && t__namespace.isIdentifier(property.key)) {
                        if (property.key.name === opts.isolate) {
                          const program = path.findParent(d => d.isProgram());
                          if (program != null && program.isProgram()) {
                            program.node.body.push(babel__namespace.template.statement("export const " + opts.isolate + " = $LOADER")({
                              $LOADER: property.value
                            }));
                          }
                        }
                      }
                      (_path$findParent2 = path.findParent(d => d.isExpressionStatement())) == null ? void 0 : _path$findParent2.remove();
                    }
                  }
                }
              });
            }
            cleanUnusedCode(programPath, state, [opts.isolate]);
          }
        }
      }
    };
  }
}
async function detectExports(code) {
  let exported = [];

  // try {
  await babel__namespace.transformAsync(code, {
    configFile: false,
    babelrc: false,
    plugins: [...getBasePlugins(), {
      visitor: {
        ExportNamedDeclaration(path) {
          if (t__namespace.isVariableDeclaration(path.node.declaration)) {
            var _path$node$declaratio;
            if (t__namespace.isVariableDeclarator((_path$node$declaratio = path.node.declaration.declarations) == null ? void 0 : _path$node$declaratio[0])) {
              if (t__namespace.isIdentifier(path.node.declaration.declarations[0].id)) {
                exported.push(path.node.declaration.declarations[0].id.name);
              }
            }
          }
        }
      }
    }],
    ast: true
  });
  return exported;
}
async function generateRouteConfig(node, routeCode, imports, clientOnly) {
  var _node$parent, _node$parent2, _node$parent3, _node$parent4, _await$babel$transfor2;
  const relativeParentRoutePath = clientOnly ? node.parent ? generator.removeExt(path__default["default"].relative(node.genDir, path__default["default"].resolve((_node$parent = node.parent) == null ? void 0 : _node$parent.genDir, (_node$parent2 = node.parent) == null ? void 0 : _node$parent2.clientFilename))) : "./" + generator.rootRouteClientName : node.parent ? generator.removeExt(path__default["default"].relative(node.genDir, path__default["default"].resolve((_node$parent3 = node.parent) == null ? void 0 : _node$parent3.genDir, (_node$parent4 = node.parent) == null ? void 0 : _node$parent4.filename))) : "./" + generator.rootRouteName;
  const pathName = node.isRoot ? undefined : node.fileNameNoExt.startsWith('__') ? undefined : node.fileNameNoExt === 'index' ? '/' : node.fileNameNoExt;
  const routeId = node.isRoot ? undefined : node.fileNameNoExt;
  function plugin() {
    return {
      visitor: {
        Program: {
          enter(programPath, state) {
            // Remove all of the isolated import properties from the config
            programPath.traverse({
              ImportSpecifier(path) {
                if (t__namespace.isIdentifier(path.node.imported)) {
                  if (!node.isRoot) {
                    if (path.node.imported.name === 'routeConfig') {
                      path.parentPath.remove();
                      const program = path.findParent(d => d.isProgram());
                      if (program != null && program.isProgram()) {
                        program.node.body.unshift(babel__namespace.template.statement("import { routeConfig as parentRouteConfig } from '$IMPORT'")({
                          $IMPORT: relativeParentRoutePath
                        }));
                      }
                    }
                  }
                }
              },
              Identifier(iPath) {
                let options;
                if (node.isRoot) {
                  if (iPath.node.name === 'createRouteConfig') {
                    if (t__namespace.isCallExpression(iPath.parentPath.node)) {
                      var _iPath$parentPath$par;
                      if (t__namespace.isExpressionStatement((_iPath$parentPath$par = iPath.parentPath.parentPath) == null ? void 0 : _iPath$parentPath$par.node)) {
                        var _iPath$parentPath$par2;
                        (_iPath$parentPath$par2 = iPath.parentPath.parentPath) == null ? void 0 : _iPath$parentPath$par2.replaceWith(t__namespace.variableDeclaration('const', [t__namespace.variableDeclarator(t__namespace.identifier('routeConfig'), iPath.parentPath.node)]));
                      }
                    }
                  }
                } else {
                  if (iPath.node.name === 'generate') {
                    if (t__namespace.isMemberExpression(iPath.parentPath.node)) {
                      if (t__namespace.isIdentifier(iPath.parentPath.node.object)) {
                        iPath.node.name = 'createRoute';
                        iPath.parentPath.node.object.name = 'parentRouteConfig';
                        options = getRouteConfigGenerateOptions(iPath);
                      }
                    }
                  }
                }
                if (options) {
                  options.properties = [...(pathName ? [t__namespace.objectProperty(t__namespace.identifier('path'), t__namespace.stringLiteral(pathName))] : routeId ? [t__namespace.objectProperty(t__namespace.identifier('id'), t__namespace.stringLiteral(routeId))] : []), ...options.properties.map(property => {
                    if (t__namespace.isObjectProperty(property) && t__namespace.isIdentifier(property.key) && isolatedProperties.includes(property.key.name)) {
                      const key = property.key.name;
                      if (key === 'loader') {
                        if (clientOnly) {
                          return t__namespace.objectProperty(t__namespace.identifier('loader'), t__namespace.tSAsExpression(t__namespace.booleanLiteral(true), t__namespace.tsAnyKeyword()));
                        }
                        return t__namespace.objectProperty(t__namespace.identifier(key), babel__namespace.template.expression("(...args) => import('./" + path__default["default"].relative(node.genDir, node.genPathNoExt) + "-" + key + "').then(d => d." + key + ".apply(d." + key + ", (args as any)))", {
                          plugins: ['typescript']
                        })({}));
                      }
                      if (key === 'action') {
                        if (clientOnly) {
                          return t__namespace.objectProperty(t__namespace.identifier('action'), t__namespace.tSAsExpression(t__namespace.booleanLiteral(true), t__namespace.tSAnyKeyword()));
                        }
                        return t__namespace.objectProperty(t__namespace.identifier(key), babel__namespace.template.expression("(...payload: Parameters<typeof import('./" + path__default["default"].relative(node.genDir, node.genPathNoExt) + "-" + key + "').action>) => import('./" + path__default["default"].relative(node.genDir, node.genPathNoExt) + "-" + key + "').then(d => d." + key + ".apply(d." + key + ", (payload as any)))", {
                          plugins: ['typescript']
                        })({}));
                      }
                      return t__namespace.objectProperty(t__namespace.identifier(key), babel__namespace.template.expression("\n                              lazy(() => import('./" + path__default["default"].relative(node.genDir, node.genPathNoExt) + "-" + key + "').then(d => ({ default: d." + key + " }) ))")());
                    }
                    return property;
                  })];
                  const program = iPath.findParent(d => d.isProgram());
                  if (program != null && program.isProgram() && options) {
                    const index = program.node.body.findIndex(d => {
                      var _iPath$parentPath$par3;
                      return d.start === ((_iPath$parentPath$par3 = iPath.parentPath.parentPath) == null ? void 0 : _iPath$parentPath$par3.node.start);
                    });
                    if (node.isRoot) {
                      program.node.body[index] = babel__namespace.template.statement("const routeConfig = createRouteConfig(\n                          $OPTIONS\n                          )")({
                        $OPTIONS: options
                      });
                    } else {
                      program.node.body[index] = babel__namespace.template.statement("const routeConfig = parentRouteConfig.createRoute(\n                          $OPTIONS\n                          )")({
                        $OPTIONS: options
                      });
                    }
                  }
                }
              }
            });
            programPath.node.body.unshift(babel__namespace.template.statement("import { lazy } from '@tanstack/react-router'")());

            // Add the routeConfig exports
            programPath.node.body.push(babel__namespace.template.statement(clientOnly ? "export { routeConfig, routeConfig as " + node.variable + "Route }" : "export { routeConfig }")());
            cleanUnusedCode(programPath, state, ['routeConfig', node.variable + "Route"]);
          }
        }
      }
    };
  }
  const code = (_await$babel$transfor2 = await babel__namespace.transformAsync(routeCode, {
    configFile: false,
    babelrc: false,
    plugins: [...getBasePlugins(), plugin()],
    ast: true
  })) == null ? void 0 : _await$babel$transfor2.code;
  if (!code) {
    // console.log(code, node, imports)
    throw new Error('Error while generating a route file!');
  }
  return code;
}
function getIdentifier(path) {
  const parentPath = path.parentPath;
  if (parentPath.type === 'VariableDeclarator') {
    const pp = parentPath;
    const name = pp.get('id');
    return name.node.type === 'Identifier' ? name : null;
  }
  if (parentPath.type === 'AssignmentExpression') {
    const pp = parentPath;
    const name = pp.get('left');
    return name.node.type === 'Identifier' ? name : null;
  }
  if (path.node.type === 'ArrowFunctionExpression') {
    return null;
  }
  return path.node.id && path.node.id.type === 'Identifier' ? path.get('id') : null;
}
function isIdentifierReferenced(ident) {
  const b = ident.scope.getBinding(ident.node.name);
  if (b && b.referenced) {
    if (b.path.type === 'FunctionDeclaration') {
      return !b.constantViolations.concat(b.referencePaths).every(ref => ref.findParent(p => p === b.path));
    }
    return true;
  }
  return false;
}
function markFunction(path, state) {
  const ident = getIdentifier(path);
  if (ident && ident.node && isIdentifierReferenced(ident)) {
    state.refs.add(ident);
  }
}
function markImport(path, state) {
  const local = path.get('local');
  if (isIdentifierReferenced(local)) {
    state.refs.add(local);
  }
}
function getRouteConfigGenerateOptions(path) {
  var _path$parentPath$pare;
  const tryOptions = node => {
    if (t__namespace.isIdentifier(node)) {
      var _path$scope$getBindin;
      const initNode = (_path$scope$getBindin = path.scope.getBinding(node.name)) == null ? void 0 : _path$scope$getBindin.path.node;
      if (t__namespace.isVariableDeclarator(initNode)) {
        return tryOptions(initNode.init);
      }
    } else if (t__namespace.isObjectExpression(node)) {
      return node;
    }
    return;
  };
  if (t__namespace.isMemberExpression(path.parentPath.node) && t__namespace.isCallExpression((_path$parentPath$pare = path.parentPath.parentPath) == null ? void 0 : _path$parentPath$pare.node)) {
    var _path$parentPath$pare2;
    const options = (_path$parentPath$pare2 = path.parentPath.parentPath) == null ? void 0 : _path$parentPath$pare2.node.arguments[0];
    return tryOptions(options);
  }
}
function getCreateRouteConfigOptions(path) {
  var _path$parentPath;
  const tryOptions = node => {
    if (t__namespace.isIdentifier(node)) {
      var _path$scope$getBindin2;
      const initNode = (_path$scope$getBindin2 = path.scope.getBinding(node.name)) == null ? void 0 : _path$scope$getBindin2.path.node;
      if (t__namespace.isVariableDeclarator(initNode)) {
        return tryOptions(initNode.init);
      }
    } else if (t__namespace.isObjectExpression(node)) {
      return node;
    }
    return;
  };
  if (t__namespace.isCallExpression((_path$parentPath = path.parentPath) == null ? void 0 : _path$parentPath.node)) {
    var _path$parentPath2;
    const options = (_path$parentPath2 = path.parentPath) == null ? void 0 : _path$parentPath2.node.arguments[0];
    return tryOptions(options);
  }
}

// All credit for this amazing function goes to the Next.js team
// (and the Solid.js team for their derivative work).
// https://github.com/vercel/next.js/blob/canary/packages/next/build/babel/plugins/next-ssg-transform.ts
// https://github.com/solidjs/solid-start/blob/main/packages/start/server/routeData.js

function cleanUnusedCode(programPath, state, keepExports) {
  state.refs = new Set();
  state.done = false;
  function markVariable(variablePath, variableState) {
    if (variablePath.node.id.type === 'Identifier') {
      const local = variablePath.get('id');
      if (isIdentifierReferenced(local)) {
        variableState.refs.add(local);
      }
    } else if (variablePath.node.id.type === 'ObjectPattern') {
      const pattern = variablePath.get('id');
      const properties = pattern.get('properties');
      properties.forEach(p => {
        const local = p.get(p.node.type === 'ObjectProperty' ? 'value' : p.node.type === 'RestElement' ? 'argument' : function () {
          throw new Error('invariant');
        }());
        if (isIdentifierReferenced(local)) {
          variableState.refs.add(local);
        }
      });
    } else if (variablePath.node.id.type === 'ArrayPattern') {
      const pattern = variablePath.get('id');
      const elements = pattern.get('elements');
      elements.forEach(e => {
        let local;
        if (e.node && e.node.type === 'Identifier') {
          local = e;
        } else if (e.node && e.node.type === 'RestElement') {
          local = e.get('argument');
        } else {
          return;
        }
        if (isIdentifierReferenced(local)) {
          variableState.refs.add(local);
        }
      });
    }
  }

  // Mark all variables and functions if used
  programPath.traverse({
    VariableDeclarator: markVariable,
    FunctionDeclaration: markFunction,
    FunctionExpression: markFunction,
    ArrowFunctionExpression: markFunction,
    ImportSpecifier: markImport,
    ImportDefaultSpecifier: markImport,
    ImportNamespaceSpecifier: markImport,
    ExportDefaultDeclaration: markImport,
    // ExportNamedDeclaration(path, state) {
    //   if (t.isVariableDeclaration(path.node.declaration)) {
    //     if (t.isVariableDeclarator(path.node.declaration.declarations?.[0])) {
    //       if (t.isIdentifier(path.node.declaration.declarations[0].id)) {
    //         if (
    //           keepExports.includes(
    //             path.node.declaration.declarations[0].id.name,
    //           )
    //         ) {
    //           return
    //         }
    //       }
    //       path.replaceWith(path.node.declaration.declarations[0])
    //       return
    //     }
    //   }
    //   path.remove()
    // },
    ImportDeclaration: path => {
      if (path.node.source.value.endsWith('.css')) {
        path.remove();
      }
    }
  }, state);

  // Sweet all of the remaining references and remove unused ones
  const refs = state.refs;
  let count;
  function sweepFunction(sweepPath) {
    const ident = getIdentifier(sweepPath);
    if (ident && ident.node && refs.has(ident) && !isIdentifierReferenced(ident)) {
      ++count;
      if (t__namespace.isAssignmentExpression(sweepPath.parentPath) || t__namespace.isVariableDeclarator(sweepPath.parentPath)) {
        sweepPath.parentPath.remove();
      } else {
        sweepPath.remove();
      }
    }
  }
  function sweepImport(sweepPath) {
    const local = sweepPath.get('local');
    if (refs.has(local) && !isIdentifierReferenced(local)) {
      ++count;
      sweepPath.remove();
      if (sweepPath.parent.specifiers.length === 0) {
        sweepPath.parentPath.remove();
      }
    }
  }
  do {
    programPath.scope.crawl();
    count = 0;
    programPath.traverse({
      VariableDeclarator(variablePath) {
        if (variablePath.node.id.type === 'Identifier') {
          const local = variablePath.get('id');
          if (refs.has(local) && !isIdentifierReferenced(local)) {
            ++count;
            variablePath.remove();
          }
        } else if (variablePath.node.id.type === 'ObjectPattern') {
          const pattern = variablePath.get('id');
          const beforeCount = count;
          const properties = pattern.get('properties');
          properties.forEach(p => {
            const local = p.get(p.node.type === 'ObjectProperty' ? 'value' : p.node.type === 'RestElement' ? 'argument' : function () {
              throw new Error('invariant');
            }());
            if (refs.has(local) && !isIdentifierReferenced(local)) {
              ++count;
              p.remove();
            }
          });
          if (beforeCount !== count && pattern.get('properties').length < 1) {
            variablePath.remove();
          }
        } else if (variablePath.node.id.type === 'ArrayPattern') {
          const pattern = variablePath.get('id');
          const beforeCount = count;
          const elements = pattern.get('elements');
          elements.forEach(e => {
            let local;
            if (e.node && e.node.type === 'Identifier') {
              local = e;
            } else if (e.node && e.node.type === 'RestElement') {
              local = e.get('argument');
            } else {
              return;
            }
            if (refs.has(local) && !isIdentifierReferenced(local)) {
              ++count;
              e.remove();
            }
          });
          if (beforeCount !== count && pattern.get('elements').length < 1) {
            variablePath.remove();
          }
        }
      },
      FunctionDeclaration: sweepFunction,
      FunctionExpression: sweepFunction,
      ArrowFunctionExpression: sweepFunction,
      ImportSpecifier: sweepImport,
      ImportDefaultSpecifier: sweepImport,
      ImportNamespaceSpecifier: sweepImport
    });
  } while (count);

  // Do we need the * import for react?
  let hasReact = false;

  // Mark react elements as having react
  programPath.traverse({
    JSXElement(path) {
      hasReact = true;
    }
  });
  if (!hasReact) {
    // Mark all variables and functions if used
    programPath.traverse({
      ImportDeclaration(path) {
        if (t__namespace.isStringLiteral(path.node.source) && path.node.source.value === 'react' && t__namespace.isImportNamespaceSpecifier(path.node.specifiers[0])) {
          path.remove();
        }
      }
    });
  }
}

exports.detectExports = detectExports;
exports.ensureBoilerplate = ensureBoilerplate;
exports.generateRouteConfig = generateRouteConfig;
exports.isolateOptionToExport = isolateOptionToExport;
exports.isolatedProperties = isolatedProperties;
//# sourceMappingURL=transformCode.js.map
