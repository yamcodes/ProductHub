{"version":3,"file":"index.production.js","sources":["../../src/index.ts"],"sourcesContent":["// While the public API was clearly inspired by the \"history\" npm package,\n// This implementation attempts to be more lightweight by\n// making assumptions about the way TanStack Router works\n\nexport interface RouterHistory {\n  location: HistoryLocation\n  subscribe: (cb: () => void) => () => void\n  push: (path: string, state?: any) => void\n  replace: (path: string, state?: any) => void\n  go: (index: number) => void\n  back: () => void\n  forward: () => void\n  createHref: (href: string) => string\n  block: (blockerFn: BlockerFn) => () => void\n  flush: () => void\n  destroy: () => void\n  notify: () => void\n}\n\nexport interface HistoryLocation extends ParsedPath {\n  state: HistoryState\n}\n\nexport interface ParsedPath {\n  href: string\n  pathname: string\n  search: string\n  hash: string\n}\n\nexport interface HistoryState {\n  key: string\n}\n\ntype BlockerFn = (retry: () => void, cancel: () => void) => void\n\nconst pushStateEvent = 'pushstate'\nconst popStateEvent = 'popstate'\nconst beforeUnloadEvent = 'beforeunload'\n\nconst beforeUnloadListener = (event: Event) => {\n  event.preventDefault()\n  // @ts-ignore\n  return (event.returnValue = '')\n}\n\nconst stopBlocking = () => {\n  removeEventListener(beforeUnloadEvent, beforeUnloadListener, {\n    capture: true,\n  })\n}\n\nfunction createHistory(opts: {\n  getLocation: () => HistoryLocation\n  pushState: (path: string, state: any, onUpdate: () => void) => void\n  replaceState: (path: string, state: any, onUpdate: () => void) => void\n  go: (n: number) => void\n  back: () => void\n  forward: () => void\n  createHref: (path: string) => string\n  flush?: () => void\n  destroy?: () => void\n}): RouterHistory {\n  let location = opts.getLocation()\n  let subscribers = new Set<() => void>()\n  let blockers: BlockerFn[] = []\n  let queue: (() => void)[] = []\n\n  const onUpdate = () => {\n    location = opts.getLocation()\n    subscribers.forEach((subscriber) => subscriber())\n  }\n\n  const tryUnblock = () => {\n    if (blockers.length) {\n      blockers[0]?.(tryUnblock, () => {\n        blockers = []\n        stopBlocking()\n      })\n      return\n    }\n\n    while (queue.length) {\n      queue.shift()?.()\n    }\n  }\n\n  const queueTask = (task: () => void) => {\n    queue.push(task)\n    tryUnblock()\n  }\n\n  return {\n    get location() {\n      return location\n    },\n    subscribe: (cb: () => void) => {\n      subscribers.add(cb)\n\n      return () => {\n        subscribers.delete(cb)\n      }\n    },\n    push: (path: string, state: any) => {\n      state = assignKey(state)\n      queueTask(() => {\n        opts.pushState(path, state, onUpdate)\n      })\n    },\n    replace: (path: string, state: any) => {\n      state = assignKey(state)\n      queueTask(() => {\n        opts.replaceState(path, state, onUpdate)\n      })\n    },\n    go: (index) => {\n      queueTask(() => {\n        opts.go(index)\n      })\n    },\n    back: () => {\n      queueTask(() => {\n        opts.back()\n      })\n    },\n    forward: () => {\n      queueTask(() => {\n        opts.forward()\n      })\n    },\n    createHref: (str) => opts.createHref(str),\n    block: (cb) => {\n      blockers.push(cb)\n\n      if (blockers.length === 1) {\n        addEventListener(beforeUnloadEvent, beforeUnloadListener, {\n          capture: true,\n        })\n      }\n\n      return () => {\n        blockers = blockers.filter((b) => b !== cb)\n\n        if (!blockers.length) {\n          stopBlocking()\n        }\n      }\n    },\n    flush: () => opts.flush?.(),\n    destroy: () => opts.destroy?.(),\n    notify: onUpdate,\n  }\n}\n\nfunction assignKey(state: HistoryState) {\n  if (!state) {\n    state = {} as HistoryState\n  }\n  return {\n    ...state,\n    key: createRandomKey(),\n  }\n}\n\n/**\n * Creates a history object that can be used to interact with the browser's\n * navigation. This is a lightweight API wrapping the browser's native methods.\n * It is designed to work with TanStack Router, but could be used as a standalone API as well.\n * IMPORTANT: This API implements history throttling via a microtask to prevent\n * excessive calls to the history API. In some browsers, calling history.pushState or\n * history.replaceState in quick succession can cause the browser to ignore subsequent\n * calls. This API smooths out those differences and ensures that your application\n * state will *eventually* match the browser state. In most cases, this is not a problem,\n * but if you need to ensure that the browser state is up to date, you can use the\n * `history.flush` method to immediately flush all pending state changes to the browser URL.\n * @param opts\n * @param opts.getHref A function that returns the current href (path + search + hash)\n * @param opts.createHref A function that takes a path and returns a href (path + search + hash)\n * @returns A history instance\n */\nexport function createBrowserHistory(opts?: {\n  getHref?: () => string\n  createHref?: (path: string) => string\n}): RouterHistory {\n  const getHref =\n    opts?.getHref ??\n    (() =>\n      `${window.location.pathname}${window.location.search}${window.location.hash}`)\n\n  const createHref = opts?.createHref ?? ((path) => path)\n\n  let currentLocation = parseLocation(getHref(), window.history.state)\n\n  const getLocation = () => currentLocation\n\n  let next:\n    | undefined\n    | {\n        // This is the latest location that we were attempting to push/replace\n        href: string\n        // This is the latest state that we were attempting to push/replace\n        state: any\n        // This is the latest type that we were attempting to push/replace\n        isPush: boolean\n      }\n\n  // Because we are proactively updating the location\n  // in memory before actually updating the browser history,\n  // we need to track when we are doing this so we don't\n  // notify subscribers twice on the last update.\n  let tracking = true\n\n  // We need to track the current scheduled update to prevent\n  // multiple updates from being scheduled at the same time.\n  let scheduled: Promise<void> | undefined\n\n  // This function is a wrapper to prevent any of the callback's\n  // side effects from causing a subscriber notification\n  const untrack = (fn: () => void) => {\n    tracking = false\n    fn()\n    tracking = true\n  }\n\n  // This function flushes the next update to the browser history\n  const flush = () => {\n    // Do not notify subscribers about this push/replace call\n    untrack(() => {\n      if (!next) return\n      window.history[next.isPush ? 'pushState' : 'replaceState'](\n        next.state,\n        '',\n        next.href,\n      )\n      // Reset the nextIsPush flag and clear the scheduled update\n      next = undefined\n      scheduled = undefined\n    })\n  }\n\n  // This function queues up a call to update the browser history\n  const queueHistoryAction = (\n    type: 'push' | 'replace',\n    path: string,\n    state: any,\n    onUpdate: () => void,\n  ) => {\n    const href = createHref(path)\n\n    // Update the location in memory\n    currentLocation = parseLocation(href, state)\n\n    // Keep track of the next location we need to flush to the URL\n    next = {\n      href,\n      state,\n      isPush: next?.isPush || type === 'push',\n    }\n    // Notify subscribers\n    onUpdate()\n\n    if (!scheduled) {\n      // Schedule an update to the browser history\n      scheduled = Promise.resolve().then(() => flush())\n    }\n  }\n\n  const onPushPop = () => {\n    currentLocation = parseLocation(getHref(), window.history.state)\n    history.notify()\n  }\n\n  var originalPushState = window.history.pushState\n  var originalReplaceState = window.history.replaceState\n\n  const history = createHistory({\n    getLocation,\n    pushState: (path, state, onUpdate) =>\n      queueHistoryAction('push', path, state, onUpdate),\n    replaceState: (path, state, onUpdate) =>\n      queueHistoryAction('replace', path, state, onUpdate),\n    back: () => window.history.back(),\n    forward: () => window.history.forward(),\n    go: (n) => window.history.go(n),\n    createHref: (path) => createHref(path),\n    flush,\n    destroy: () => {\n      window.history.pushState = originalPushState\n      window.history.replaceState = originalReplaceState\n      window.removeEventListener(pushStateEvent, onPushPop)\n      window.removeEventListener(popStateEvent, onPushPop)\n    },\n  })\n\n  window.addEventListener(pushStateEvent, onPushPop)\n  window.addEventListener(popStateEvent, onPushPop)\n\n  window.history.pushState = function () {\n    let res = originalPushState.apply(window.history, arguments as any)\n    if (tracking) history.notify()\n    return res\n  }\n\n  window.history.replaceState = function () {\n    let res = originalReplaceState.apply(window.history, arguments as any)\n    if (tracking) history.notify()\n    return res\n  }\n\n  return history\n}\n\nexport function createHashHistory(): RouterHistory {\n  return createBrowserHistory({\n    getHref: () => window.location.hash.substring(1),\n    createHref: (path) => `#${path}`,\n  })\n}\n\nexport function createMemoryHistory(\n  opts: {\n    initialEntries: string[]\n    initialIndex?: number\n  } = {\n    initialEntries: ['/'],\n  },\n): RouterHistory {\n  const entries = opts.initialEntries\n  let index = opts.initialIndex ?? entries.length - 1\n  let currentState = {\n    key: createRandomKey(),\n  } as HistoryState\n\n  const getLocation = () => parseLocation(entries[index]!, currentState)\n\n  return createHistory({\n    getLocation,\n    pushState: (path, state) => {\n      currentState = state\n      entries.push(path)\n      index++\n    },\n    replaceState: (path, state) => {\n      currentState = state\n      entries[index] = path\n    },\n    back: () => {\n      index--\n    },\n    forward: () => {\n      index = Math.min(index + 1, entries.length - 1)\n    },\n    go: (n) => window.history.go(n),\n    createHref: (path) => path,\n  })\n}\n\nfunction parseLocation(href: string, state: HistoryState): HistoryLocation {\n  let hashIndex = href.indexOf('#')\n  let searchIndex = href.indexOf('?')\n\n  return {\n    href,\n    pathname: href.substring(\n      0,\n      hashIndex > 0\n        ? searchIndex > 0\n          ? Math.min(hashIndex, searchIndex)\n          : hashIndex\n        : searchIndex > 0\n        ? searchIndex\n        : href.length,\n    ),\n    hash: hashIndex > -1 ? href.substring(hashIndex) : '',\n    search:\n      searchIndex > -1\n        ? href.slice(searchIndex, hashIndex === -1 ? undefined : hashIndex)\n        : '',\n    state: state || {},\n  }\n}\n\n// Thanks co-pilot!\nfunction createRandomKey() {\n  return (Math.random() + 1).toString(36).substring(7)\n}\n"],"names":["pushStateEvent","popStateEvent","beforeUnloadEvent","beforeUnloadListener","event","preventDefault","returnValue","stopBlocking","removeEventListener","capture","createHistory","opts","location","getLocation","subscribers","Set","blockers","queue","onUpdate","forEach","subscriber","tryUnblock","length","shift","queueTask","task","push","subscribe","cb","add","delete","path","state","assignKey","pushState","replace","replaceState","go","index","back","forward","createHref","str","block","addEventListener","filter","b","flush","destroy","notify","key","createRandomKey","createBrowserHistory","getHref","window","pathname","search","hash","currentLocation","parseLocation","history","next","scheduled","tracking","isPush","href","undefined","fn","queueHistoryAction","type","Promise","resolve","then","onPushPop","originalPushState","originalReplaceState","n","res","apply","arguments","hashIndex","indexOf","searchIndex","substring","Math","min","slice","random","toString","initialEntries","entries","initialIndex","currentState"],"mappings":"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"}